<!DOCTYPE html>
<html>
<head>
<title>RDF Dataset Normalization</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script type="text/javascript" src="../respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" src="../respec-w3c-extensions.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
  var respecConfig = {
      // extend the bibliography entries
      "localBiblio": localBibliography,

      doRDFa: "1.1",
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "CG-DRAFT",
      //publishDate:          "2010-04-29",
      copyrightStart:       "2010",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "rdf-dataset-normalization",
      subtitle:             "A Standard RDF Dataset Normalization Algorithm",
      // if you wish the publication date to be other than today, set this
      // publishDate:  "2009-08-06",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      //previousPublishDate:  "2011-08-17",
      //previousMaturity:     "ED",
      //previousDiffURI:      "http://json-ld.org/spec/ED/20110817/index.html",
      //diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "http://json-ld.org/spec/latest/rdf-dataset-normalization/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      issueBase: "https://github.com/json-ld/json-ld.org/issues/",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS: [],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
          { name: "Manu Sporny", url: "http://manu.sporny.org/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" }
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:  [
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"}
      ],

      // name of the WG
      wg: "JSON for Linking Data W3C Community Group",

      // URI of the public WG page
      wgURI: "http://www.w3.org/community/json-ld/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-linked-json",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "",
      maxTocLevel: 2,
      preProcess: [ preProc ],
      //alternateFormats: [ {uri: "diff-20110817.html", label: "diff to previous version"} ]
  };
//]]>
</script>
<style type="text/css">
  .highlight { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td { padding: 5px; border-width: 1px; border-spacing: 0px; border-style: solid; border-collapse: collapse; }
</style>
</head>

<body>
<section id="abstract">
  <p>RDF [[RDF-CONCEPTS]] describes a graph-based data model for making claims
    about the world and provides the foundation for reasoning upon that graph
    of information. At times, it becomes necessary to compare the differences
    between sets of graphs, digitally sign them, or generate short identifiers
    for graphs via hashing algorithms. This document outlines an algorithm for
    normalizing <tref>RDF dataset</tref>s such that these operations can be
    performed.</p>
</section>

<section id="sotd">
  <p>This document is a work in progress.</p>
  <!-- <p>This document has been reviewed by W3C Members, by software
    developers, and by other W3C groups and interested parties, and is
    endorsed by the Director as a W3C Recommendation. It is a stable
    document and may be used as reference material or cited from another
    document. W3C's role in making the Recommendation is to draw attention
    to the specification and to promote its widespread deployment. This
    enhances the functionality and interoperability of the Web.</p> -->
</section>

<section>
  <h1>Introduction</h1>

  <p>When data scientists discuss normalization, they do so in the context of
    achieving a particular set of goals. Since the same information may
    sometimes be expressed in a variety of different ways, it often becomes
    necessary to be able to transform each of these different ways into a
    single, standard format. With a standard format, the differences between
    two different sets of data can be easily determined, a
    cryptographically-strong hash identifier can be generated for a particular
    set of data, and a particular set of data may be digitally-signed for later
    verification.</p>

  <p>In particular, this specification is about normalizing
    <tref>RDF dataset</tref>s, which are collections of graphs. Since
    a directed graph can express the same information in more than one
    way, it requires normalization to achieve the aforementioned goals
    and any others that may arise via surrendipity.</p>

  <p>Most <tref>RDF dataset</tref> can be normalized fairly quickly, in terms
    of algorithmic time complexity. However, those that contain nodes that do
    not have globally unique identifiers pose a greater challenge. Normalizing
    these datasets presents the <tdef>graph isomorphism</tdef> problem, a
    problem that is believed to be difficult to solve quickly. More formally,
    it is believed to be an NP-Intermediate problem, that is, neither known to
    be solvable in polynomial time nor NP-complete. Fortunately, existing real
    world data is rarely modeled in a way that manifests this problem and new
    data can be modeled to avoid it. In fact, software systems can detect a
    problematic dataset and may choose to assume it's an attempted denial of
    service attack, rather than a real input, and abort.</p>

  <p>This document outlines an algorithm for generating a normalized
    <tref>RDF dataset</tref> given an <tref>RDF dataset</tref> as input. The
    algorithm is called the
    <strong>Universal RDF Dataset Normalization Algorithm 2015</strong> or
    <strong>URDNA2015</strong>.</p>

  <section>
    <h2>How to Read this Document</h2>

    <p>This document is a detailed specification for an <tref>RDF dataset</tref>
      normalization algorithm. The document is primarily intended for the
      following audiences:</p>

    <ul>
      <li>Software developers that want to implement an <tref>RDF dataset</tref>
        normalization algorithm.</li>
      <li>Masochists.</li>
    </ul>

    <p>To understand the basics in this specification you must be familiar with
      basic RDF concepts [[!RDF-CONCEPTS]]. A working knowledge of
      <a href="http://en.wikipedia.org/wiki/Graph_theory">graph theory</a> and
      <a href="http://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a>
      is also recommended.</p>
  </section>

  <section>
    <h2>Contributing</h2>

    <p>There are a number of ways that one may participate in the development
      of this specification:</p>

    <ul>
      <li>Technical discussion typically occurs on the public mailing list:
        <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

      <li><a href="http://json-ld.org/minutes/">Public teleconferences</a> are
        held on Tuesdays at 1500UTC on the second and fourth week of each
        month.</li>

      <li>Specification bugs and issues should be reported in the
        <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>.</li>

      <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a> for the
        specification can be found on Github.</li>

      <li>The <a href="http://webchat.freenode.net/?channels=#json-ld">#json-ld</a>
        IRC channel is available for real-time discussion on
        <a href="irc.freenode.net">irc.freenode.net.</a></li>
    </ul>
  </section>
</section>

<section class="normative">
  <h1>Terminology</h1>

  <section class="normative">
    <h2>General Terminology</h2>

    <dl>
      <dt><tdef>string</tdef></dt><dd>
        A string is a sequence of zero or more Unicode characters,
        wrapped in double quotes, using backslash escapes (if necessary).</dd>
      <dt><tdef>true</tdef> and <tdef>false</tdef></dt><dd>
        Values that are used to express one of two possible boolean states.</dd>
      <dt><tdef><abbr title="Internationalized Resource Identifier">IRI</abbr></tdef></dt>
      <dd>An <tref>IRI</tref> (Internationalized Resource Identifier) is a string that conforms to the syntax
        defined in [[RFC3987]].</dd>
      <dt><tdef>RDF subject</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-subject">subject</tref>
        as specified by [[RDF11-CONCEPTS]].</dd>
      <dt><tdef>RDF predicate</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-predicate">predicate</tref>
        as specified by [[RDF11-CONCEPTS]].</dd>
      <dt><tdef>RDF object</tdef></dt>
      <dd>An <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-object">object</tref>
        as specified by [[RDF11-CONCEPTS]].</dd>
      <dt><tdef>RDF triple</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triple</tref>
        as specified by [[RDF11-CONCEPTS]].</dd>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graph</tref>
        as specified by [[RDF11-CONCEPTS]].</dd>
      <dt><tdef>RDF graph name</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-dataset">graph name</tref>
        as specified by [[RDF11-CONCEPTS]].</dd>
      <dt><tdef>RDF quad</tdef></dt>
      <dd>The pairing of an <tref>RDF triple</tref> with an <tref>RDF graph name</tref>.</dd>
      <dt><tdef>RDF dataset</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-dataset">dataset</tref>
        as specified by [[RDF11-CONCEPTS]].</dd>
      <dt><tdef>RDF blank node</tdef></dt>
      http://www.w3.org/TR/rdf11-concepts/#section-blank-nodes
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#section-blank-nodes">blank node</tref>
        as specified by [[RDF11-CONCEPTS]]. In short, a node in a graph that is
        neither an <tref>IRI</tref>, nor a
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</tref>.</dd>
      <dt><tdef>RDF blank node identifier</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node-identifier">blank node identifier</tref>
        as specified by [[RDF11-CONCEPTS]]. In short, a string that begins
        with <code>_:</code> that is used as an identifier for an
        <tref>RDF blank node</tref>. <tref>RDF blank node identifier</tref>s
        are typically implementation-specific local identifiers; this document
        specifies an algorithm for deterministically specifying them.</dd>
    </dl>
  </section>
</section>

<section>
  <h1>Normalization</h1>

  <p class="issue">This algorithm is a work in progress, do not implement it.</p>

  <p>Normalization is the process of transforming an
    <tref>input RDF dataset</tref> to a <tref>standard RDF dataset</tref>. That
    is, any two <tref>input RDF dataset</tref>s that contain the same
    information, regardless of their arrangement, will be transformed into
    identical <tref>standard RDF dataset</tref>s. The problem requires directed
    graphs to be deterministically ordered into sets of nodes and edges. This
    is easy to do when all of the nodes have globally unique names, but can be
    difficult to do when some of the nodes are not labeled. Any unlabeled nodes
    must be deterministically labeled.</p>

  <p>In time, there may be more than one normalization algorithm and,
    therefore, for identification purposes, this algorithm is named the
    "Universal RDF Dataset Normalization Algorithm 2015"
    (<abbr title="Universal RDF Dataset Normalization Algorithm 2015">URDNA2015</abbr>).</p>

  <section>
    <h1>Normalization Algorithm Terms</h1>
    <dl>
      <dt><tdef>input RDF dataset</tdef></dt>
      <dd>The abstract <tref>RDF dataset</tref> that is provided as input to
        the algorithm.</dd>
      <dt><tdef>standard RDF dataset</tdef></dt>
      <dd>The abstract <tref>RDF dataset</tref> and normalized
        <tref>RDF blank node identifier</tref>s that are produced as output by
        the algorithm.</dd>
      <dt><tdef>blank node labeler</tdef></dt>
      <dd>A blank node labeler maintains a mapping of existing
        <tref>RDF blank node identifier</tref>s to new ones. It also tracks the
        order in which new identifiers were assigned.</dd>
      <dt><tdef>hash algorithm</tdef></dt>
      <dd>The hash algorithm used by URDNA2015; namely SHA-256.</dd>
    </dl>
  </section>

  <section>
    <h1>Normalization State</h1>

    <p>When performing the steps required by the normalization algorithm,
      it is helpful to track state in a data structure called the
      <tdef>normalization state</tdef>. The information contained in the
      <tref>normalization state</tref> is described below.</p>

    <dl>
      <dt><tdef>blank node to quads map</tdef></dt>
      <dd>A data structure that maps <tref>RDF blank node identifier</tref>s to
        the <tref>RDF quad</tref>s in which they appear in the
        <tref>input RDF dataset</tref>.</dd>
      <dt><tdef>hash to blank nodes map</tdef></dt>
      <dd>A data structure that maps a hash to a list of
        <tref>RDF blank node identifier</tref>s.</dd>
      <dt><tdef>canonical labeler</tdef></dt>
      <dd>A <tref>blank node labeler</tref>, initialized with the
        prefix <code>_:c14n</code>, for assigning canonical
        <tref>RDF blank node identifier</tref>s.
      </dd>
    </dl>
  </section>

  <section>
    <h1>Blank Node Labeler State</h1>

    <p>During the normalization algorithm, it is sometimes necessary to
      assign identifiers, or labels, to <tref>RDF blank node</tref>s. The
      <a href="#node-relabeling">Node Relabeling algorithm</a> uses a
      <tref>blank node labeler</tref> to accomplish this task. The information
      a <tref>blank node labeler</tref> needs to keep track of is described
      below.</p>

    <dl>
      <dt><tdef>identifier prefix</tdef></dt>
      <dd>The identifier prefix is a string that is used at the beginning of an
        <tref>RDF blank node identifier</tref>. It should be initialized to a
        string that is specified by the normalization algorithm. When
        generating a new <tref>RDF blank node identifier</tref>, the prefix
        is concatenated with a <tref>identifier counter</tref>. For example,
        <code>_:c14n</code> is a proper initial value for the
        <tref>identifier prefix</tref> that would produce
        <tref>RDF blank node identifier</tref>s like <code>_:c14n1</code>.</dd>
      <dt><tdef>identifier counter</tdef></dt>
      <dd>A counter that is appended to the <tref>identifier prefix</tref> to
        create an <tref>RDF blank node identifier</tref>. It is initialized to
        <code>1</code>.</dd>
      <dt><tdef>labeler ordering list</tdef></dt>
      <dd>A list that tracks previous identifier assignments in the order in
        which they occurred. Each entry in the list maps the input
        <tref>RDF blank node identifier</tref> and its newly assigned
        identifier. This list also ensures only one new identifier is assigned
        to a given input.</dd>
  </section>

  <section>
    <h2>Normalization Algorithm</h2>

    <p>The normalization algorithm converts an <tref>input RDF dataset</tref>
      into a <tref>standard RDF dataset</tref>. This algorithm will assign
      deterministic identifiers to any <tref>RDF blank node</tref>s in the
      <tref>input RDF dataset</tref>.</p>

    <p class="issue">Documenting the algorithm is a WIP, various steps will
      become more detailed in time.</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>

      <ol class="algorithm">
        <li>Create the <tref>normalization state</tref>.</li>
        <li>For every <tref>RDF quad</tref> in <tref>input RDF dataset</tref>:
          <ol class="algorithm">
            <li>For each <tref>RDF blank node</tref> that occurs in the
              <tref>RDF quad</tref>, add a reference to the
              <tref>RDF quad</tref> using the
              <tref>RDF blank node identifier</tref> in the
              <tref>blank node to quads map</tref>, creating a new entry if
              necessary.
            </li>
          </ol>
        </li>
        <li>Create a list of non-normalized <tref>blank node identifier</tref>s
          <i>non-normalized identifiers</i> and populate it using the keys
          from the <tref>blank node to quads map</tref>.</li>
        <li>Initialize an <tdef>easy label</tdef> flag to
          <code>true</code>.</li>
        <li>While the <tref>easy label</tref> flag is <code>true</code>,
          canonically-label the easy-to-label <tref>RDF blank node</tref>s:</li>
          <ol class="algorithm">
            <li>Set the <tref>easy label</tref> flag to <code>false</code>.</li>
            <li>Clear the <tref>hash to blank nodes map</tref>.</li>
            <li>For each <tref>RDF blank node identifier</tref>
              <i>identifier</i> in <i>non-normalized identifiers</i>:</li>
              <ol class="algorithm">
                <li>Create a <i>hash</i> according to the
                  <a href="#hash-quads">Hash Quads algorithm</a>.</li>
                <li>Add <i>hash</i> and <i>identifier</i> to the
                  <tref>hash to blank nodes map</tref>, creating a new entry if
                  necessary.</li>
              </ol>
            <li>For each <i>hash</i> to <i>identifier list</i> mapping in the
              <tref>hash to blank nodes map</tref>, lexicographically-sorted by
              <i>hash</i>:
              <ol class="algorithm">
                <li>If the length of the entry's list of
                  <tref>RDF blank node identifier</tref>s is greater than
                  <code>1</code>, continue to the next entry.</li>
                <li>Use the
                  <a href="#node-relabeling">Node Relabeling algorithm</a>,
                  passing <i>canonical labeler</i> and the single
                  <tref>RDF blank node identifier</tref> in the entry's list,
                  <i>identifier</i>, to generate a canonical label for
                  <i>identifier</i>.</li>
                <li>Remove <i>identifier</i> from
                  <i>non-normalized identifiers</i>.</li>
                <li>Remove <i>hash</i> from the
                  <tref>hash to blank nodes map</tref>.</li>
                <li>Set the <tref>easy label</tref> flag to
                  <code>true</code>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>For each entry in the <tref>hash to blank nodes map</tref> in
          lexicographically-sorted order:</li>
          <ol class="algorithm">
            <li>Create a <tdef>hash path list</tdef>.</li>
            <li>For each <tref>RDF blank node identifier</tref>
              <i>identifier</i> in the entry's list:</li>
              <ol class="algorithm">
                <li>If <i>identifier</i> has already been assigned a canonical
                  label, continue to the next
                  <tref>RDF blank node identifier</tref>.</li>
                <li>Create a temporary <tref>blank node labeler</tref>,
                  <i>temporary labeler</i>, using the prefix
                  <code>_:b</code>.</li>
                <li>Use the
                  <a href="#node-relabeling">Node Relabeling algorithm</a>,
                  passing <i>temporary labeler</i> and
                  <i>identifier</i>, to assign
                  a new temporary <tref>RDF blank node identifier</tref> for
                  <i>identifier</i>.</li>
                <li>Run the <a href="#hash-paths">Hash Paths algorithm</a>,
                  passing <i>temporary labeler</i>, and append the
                  result to the <tref>hash path list</tref>.</li>
              </ol>
            </li>
            <li>For each entry in the <tref>hash path list</tref>,
              lexicographically-sorted by hash:</li>
              <ol class="algorithm">
                <li>For each <tref>RDF blank node identifier</tref> that
                  was assigned a temporary identifier by the entry's
                  <tref>blank node labeler</tref>, in the order in which they
                  were assigned, assign canonical labels using the
                  <a href="#node-relabeling">Node Relabeling algorithm</a>,
                  passing <tref>canonical labeler</tref> and the
                  <tref>RDF blank node identifier</tref>.
              </ol>
            </li>
          </ol>
        </li>
        <li>For each <tref>RDF quad</tref> <i>quad</i> in
          <tref>input RDF dataset</tref>:
          <ol class="algorithm">
            <li>Create a copy, <i>quad copy</i>, of <i>quad</i> and replace any
              <tref>RDF blank node identifier</tref>s using the
              <a href="#node-relabeling">Node Relabeling algorithm</a>,
              passing the <tref>canonical labeler</tref> and the
              <tref>RDF blank node identifier</tref>.</li>
            <li>Add <i>quad copy</i> to the
              <tref>standard RDF dataset</tref>.</li>
          </ol>
        </li>
        <li>Return the <tref>standard RDF dataset</tref>.</li>
      </ol>
    </section>
  </section>

  <section>
    <h2>Node Relabeling Algorithm</h2>

    <p class="issue">WIP; perhaps change name to Node Label
      Generation/Assignment Algorithm as the actual relabeling occurs
      elsewhere.</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>
    </section>

    <p>This algorithm generates a mapping from an existing
      <tref>RDF blank node identifier</tref> to a new unique
      <tref>RDF blank node identifier</tref>. It also tracks the order in
      which <tref>RDF blank node identifier</tref>s were assigned.</p>

    <p>The node relabeling algorithm is as follows:</p>

    <ol class="algorithm">
      <li>If the <tref>RDF blank node identifier</tref> has already been
        assigned, return the same unique new identifier that was returned
        previously.</li>
      <li>Append the existing <tref>RDF blank node identifier</tref> to the
        <tref>labeler ordering list</tref>.</li>
      <li>Generate the <tdef>new identifier</tdef> by concatenating the
        <tref>identifier prefix</tref> with the string value of the
        <tref>identifier counter</tref>.</li>
      <li>Increment the <tref>identifier counter</tref>.</li>
      <li>Return the <tref>new identifier</tref>.</li>
    </ol>
  </section>

  <section>
    <h2>Hash Quads</h2>

    <p class="issue">WIP</p>

    <p class="issue">Add note that it is safe to cache the result of
      hashing the quads for later reuse (to reduce unnecessary computation).</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>This algorithm takes the <tref>normalization state</tref> and a
        <tdef>reference blank node identifier</tdef> as inputs.</p>

      <ul>
        <li>Initialize <tdef>nquads</tdef> to an empty list. It will be
          used to store quads in N-Quads format.</li>
        <li>Get the list of quads <i>quads</i> associated with the
          <tref>reference blank node identifier</tref> in the
          <tref>blank node to quads map</tref>.</li>
        <li>For each <tref>RDF quad</tref> <i>quad</i> in <i>quads</i>:
          <ol class="algorithm">
            <li>Serialize the <tref>RDF quad</tref> in N-Quads format with the
              following special rule:
              <ol class="algorithm">
                <li>If any component in <i>quad</i> is an
                  <tref>RDF blank node</tref>, then serialize it using a
                  special identifier as follows:
                  <ol class="algorithm">
                    <li>If the <tref>blank node</tref>'s existing
                  <tref>RDF blank node identifier</tref> matches the
                  <tref>reference blank node identifier</tref> then use the
                  <tref>RDF blank node identifier</tref> <code>_:a</code>,
                  otherwise, use the <tref>RDF blank node identifier</tref>
                  <code>_:z</code>.</li>
                  </ol>if its existing
                  <tref>RDF blank node identifier</tref> matches the
                  <tref>reference blank node identifier</tref> then use the
                  <tref>RDF blank node identifier</tref> <code>_:a</code>,
                  otherwise, use the <tref>RDF blank node identifier</tref>
                  <code>_:z</code>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Sort <tref>nquads</tref> in lexicographical order.</li>
        <li>Return the lowercase, hexadecimal representation of the
          message digest that results from passing the sorted, joined
          <tref>nquads</tref> through the <tref>hash algorithm</tref>.</li>
      </ul>
    </section>
  </section>

  <section>
    <h2>Hash Paths</h2>

    <p class="issue">WIP</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>Usually, when trying to determine if two nodes in a graph are
        equivalent, you simply compare their identifiers. However, what if the
        nodes don't have identifiers? Then you must determine if the two nodes
        have equivalent connections to equivalent nodes all throughout the
        whole graph. This is called the graph isomorphism problem. This
        algorithm approaches this problem by considering how one might draw
        a graph on paper. You can test to see if two nodes are equivalent
        by drawing the graph twice. The first time you draw the graph the
        first node is drawn in the center of the page. If you can draw the
        graph a second time such that it looks just like the first, except
        the second node is in the center of the page, then the nodes are
        equivalent. This algorithm essentially defines a determinitsic way to
        draw a graph where, if you begin with a particular node, the graph
        will always be drawn the same way. If two graphs are drawn the same way
        with two different nodes, then the nodes are equivalent. A hash is used
        to indicate a particular way that the graph has been drawn and can
        be used to compare nodes.</p>

      <p>This algorithm works in concert with the main normalization algorithm
        to produce a unique, deterministic identifier for a particular blank
        node. This hash incorporates all of the information that is connected
        to the blank node as well as how it is connected. It does this by
        creating deterministic paths that emanate out from the blank node
        through any other adjacent blank nodes. The process is as follows:</p>

      <ul>
        <li>Start by taking the perspective that the
          <tref>RDF blank node</tref> is at the center of the graph. This is
          the starting point for which all paths will radiate outward.</li>
        <li>Create a <tref>blank node labeler</tref> and assign a label
          to the starting <tref>RDF blank node</tref>.</li>
        <li>Start the main message digest hash.</li>
        <li>For each adjacent <tref>RDF blank node</tref>, determine a label for
          it, first using the canonical label if already assigned, second
          using the label from the local <tref>blank node labeler</tref> if
          already assigned, and lastly, use the result of the
          <a href="#hash-quads">Hash Quads algorithm</a> as the label.</li>
        <li>Create a group message digest hash, digesting data representing
          the direction of the <tref>RDF blank node</tref> relationship
          (<tref>RDF subject</tref> to <tref>RDF object</tref> or
          <tref>RDF object</tref> from <tref>RDF subject</tref>) relative to
          the original <tref>RDF blank node</tref>, the
          <tref>RDF predicate</tref>, and the <tref>RDF blank node</tref>
          label. Store a record of this group hash and its matching
          <tref>RDF blank node</tref>.</li>
        <li>Now iterate over each of the group hashes and related
          <tref>RDF blank node</tref>s. For each group, use the main hash to
          digest the group hash and create a copy of the
          <tref>blank node labeler</tref> to be used in case recursion is
          needed. Then, proceed to construct a path. For each permutation of
          <tref>RDF blank node</tref>s in the group, concatenate the canonical
          label for it, if already assigned, to the path. If not, and the
          <tref>blank node labeler</tref> has not assigned it a label, take
          note of this and then assign it one. If a path has already been
          selected as the canonical path, stop permutating.</li>
        <li>If no path has been chosen as the canonical one, recurse into
          each of the <tref>RDF blank node</tref>s that was assigned a label
          in the previous step, passing the copy of the
          <tref>blank node labeler</tref> to use in the algorithm. Append the
          resulting hash of the recursion to the path and update the reference
          to the copy of the <tref>blank node labeler</tref> to the one
          given in the result of the algorithm.</li>
        <li>If no path has been chosen or the current path is shorter than
          the currently chosen path, update the chosen path to the current
          path. Set the chosen namer to match the one used to produce the
          path.</li>
        <li>Use the main hash to digest the chosen path and return it
          and the chosen namer as the result of the algorithm.</li>
      </ul>
    </section>

    <p class="issue">When processing adjacent blank nodes, can they be skipped
      if they've already been canonically labeled?</p>

    <p class="issue">When creating group hashes, does the graph name also
      need to be digested (not just direction of relationship, predicate,
      and blank node label)? It may not be necessary as any structural
      differences would get picked up by the Hash Quads algorithm or by
      recursion. If there are no differences then it won't matter because
      the same hash will be produced anyway.
    </p>

    <section>
      <h3>Algorithm</h3>

      <!-- <ol class="algorithm">
        <li>Digest the group hash.</li>
        <li>Build the shortest, lexicographically least *path* of
          blank nodes in the group that visits all nodes in the group
          without cycling and that serializes them using the hash that
          results from recursively calling this algorithm. Track the order
          the blank nodes were visited.
         </li>
         <li>Digest the chosen path.</li>
      </ol>
      <li>Process the resulting group hashes in sorted order,
        labeling any remaining blank nodes by using the order in which
        the nodes were visited when constructing the associated
        shortest *path*.</li> -->
  </section>
</section>

<section class="appendix">
  <h1>Acknowledgements</h1>

  <p>The editors would like to thank Jeremy Carroll for his work on the
    graph normalization problem, Gavin Carothers for providing valuable
    feedback and testing input for the algorithm defined in this
    specification, Sir Tim Berners Lee for his thoughts on graph normalization
    over the years, and Jes√∫s Arias Fisteus for his work on a similar
    algorithm. Finally, a huge thank you goes out to Dave Longley who designed
    and implemented the algorithms used in this specification, which turned out
    to be a monumentally difficult design challenge.</p>
</section>

</body>
</html>
