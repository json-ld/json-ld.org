<!DOCTYPE html>
<html>
<head>
<title>RDF Dataset Normalization</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script type="text/javascript" src="../respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" src="../respec-w3c-extensions.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
  var respecConfig = {
      // extend the bibliography entries
      "localBiblio": localBibliography,

      doRDFa: "1.1",
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "CG-DRAFT",
      //publishDate:          "2010-04-29",
      copyrightStart:       "2010",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "rdf-dataset-normalization",
      subtitle:             "A Standard RDF Dataset Normalization Algorithm",
      // if you wish the publication date to be other than today, set this
      // publishDate:  "2009-08-06",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      //previousPublishDate:  "2011-08-17",
      //previousMaturity:     "ED",
      //previousDiffURI:      "http://json-ld.org/spec/ED/20110817/index.html",
      //diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "http://json-ld.org/spec/latest/rdf-dataset-normalization/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      issueBase: "https://github.com/json-ld/json-ld.org/issues/",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS: [],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
          { name: "Manu Sporny", url: "http://manu.sporny.org/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"}
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:  [
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
          { name: "Manu Sporny", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" }
      ],

      // name of the WG
      wg: "JSON for Linking Data W3C Community Group",

      // URI of the public WG page
      wgURI: "http://www.w3.org/community/json-ld/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-linked-json",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "",
      maxTocLevel: 2,
      preProcess: [ preProc ],
      //alternateFormats: [ {uri: "diff-20110817.html", label: "diff to previous version"} ]
  };
//]]>
</script>
<style type="text/css">
  .highlight { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td { padding: 5px; border-width: 1px; border-spacing: 0px; border-style: solid; border-collapse: collapse; }
</style>
</head>

<body>
<section id="abstract">
  <p>RDF [[RDF-CONCEPTS]] describes a graph-based data model for making claims
    about the world and provides the foundation for reasoning upon that graph
    of information. At times, it becomes necessary to compare the differences
    between datasets of graphs, digitally sign them, or generate short
    identifiers for graphs via hashing algorithms. This document outlines an
    algorithm for normalizing RDF datasets such that these operations can be
    performed.</p>
</section>

<section id="sotd">
  <p>This document is an experimental work in progress.</p>
  <!-- <p>This document has been reviewed by W3C Members, by software
    developers, and by other W3C groups and interested parties, and is
    endorsed by the Director as a W3C Recommendation. It is a stable
    document and may be used as reference material or cited from another
    document. W3C's role in making the Recommendation is to draw attention
    to the specification and to promote its widespread deployment. This
    enhances the functionality and interoperability of the Web.</p> -->
</section>

<section>
  <h1>Introduction</h1>

  <p>When data scientists discuss normalization, they do so in the context of
    achieving a particular set of goals. Since the same information may
    sometimes be expressed in a variety of different ways, it often becomes
    necessary to be able to transform each of these different ways into a
    single, standard format. With a standard format, the differences between
    two different sets of data can be easily determined, a
    cryptographically-strong hash identifier can be generated for a particular
    set of data, and a particular set of data may be digitally-signed for later
    verification.</p>

  <p>In particular, this specification is about normalizing
    <tref>RDF dataset</tref>s, which are collections of graphs. Since
    a directed graph can express the same information in more than one
    way, it requires normalization to achieve the aforementioned goals
    and any others that may arise via surrendipity.</p>

  <p>Most <tref>RDF dataset</tref> can be normalized fairly quickly, in terms
    of algorithmic time complexity. However, those that contain nodes that do
    not have globally unique identifiers pose a greater challenge. Normalizing
    these datasets presents the <tdef>graph isomorphism</tdef> problem, a
    problem that is believed to be difficult to solve quickly. More formally,
    it is believed to be an NP-Intermediate problem, that is, neither known to
    be solvable in polynomial time nor NP-complete. Fortunately, existing real
    world data is rarely modeled in a way that manifests this problem and new
    data can be modeled to avoid it. In fact, software systems can detect a
    problematic dataset and may choose to assume it's an attempted denial of
    service attack, rather than a real input, and abort.</p>

  <p>This document outlines an algorithm for generating a normalized
    <tref>RDF dataset</tref> given an <tref>RDF dataset</tref> as input. The
    algorithm is called the
    <strong>Universal RDF Dataset Normalization Algorithm 2015</strong> or
    <strong>URDNA2015</strong>.</p>

  <section>
    <h2>How to Read this Document</h2>

    <p>This document is a detailed specification for an <tref>RDF dataset</tref>
      normalization algorithm. The document is primarily intended for the
      following audiences:</p>

    <ul>
      <li>Software developers that want to implement an <tref>RDF dataset</tref>
        normalization algorithm.</li>
      <li>Masochists.</li>
    </ul>

    <p>To understand the basics in this specification you must be familiar with
      basic RDF concepts [[!RDF-CONCEPTS]]. A working knowledge of
      <a href="http://en.wikipedia.org/wiki/Graph_theory">graph theory</a> and
      <a href="http://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a>
      is also recommended.</p>
  </section>

  <section>
    <h2>Contributing</h2>

    <p>There are a number of ways that one may participate in the development
      of this specification:</p>

    <ul>
      <li>Technical discussion typically occurs on the public mailing list:
        <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

      <li><a href="http://json-ld.org/minutes/">Public teleconferences</a> are
        held on Tuesdays at 1500UTC on the second and fourth week of each
        month.</li>

      <li>Specification bugs and issues should be reported in the
        <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>.</li>

      <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a> for the
        specification can be found on Github.</li>

      <li>The <a href="http://webchat.freenode.net/?channels=#json-ld">#json-ld</a>
        IRC channel is available for real-time discussion on
        <a href="irc.freenode.net">irc.freenode.net.</a></li>
    </ul>
  </section>
</section>

<section class="normative">
  <h1>Terminology</h1>

  <section class="normative">
    <h2>General Terminology</h2>

    <!-- FIXME: remove any unnecessary JSON terminology -->

    <p>This document uses the following terms as defined in JSON [[!RFC4627]]. Refer
      to the <em>JSON Grammar</em> section in [[!RFC4627]] for formal definitions.</p>

    <dl>
      <dt><tdef>JSON object</tdef></dt><dd>
        An object structure is represented as a pair of curly brackets surrounding
        zero or more key-value pairs. A key is a <tref>string</tref>.
        A single colon comes after each key, separating the key from the value.
        A single comma separates a value from a following key.</dd>
      <dt><tdef>array</tdef></dt>
      <dd>An array structure is represented as square brackets surrounding zero
        or more values. Values are separated by commas.
        In JSON, an array is an <em>ordered</em> sequence of zero or more values.</dd>
      <dt><tdef>string</tdef></dt><dd>
        A string is a sequence of zero or more Unicode characters,
        wrapped in double quotes, using backslash escapes (if necessary).</dd>
      <dt><tdef>number</tdef></dt>
      <dd>A number is similar to that used in most programming languages, except
        that the octal and hexadecimal formats are not used and leading zeros
        are not allowed.</dd>
      <dt><tdef>true</tdef> and <tdef>false</tdef></dt><dd>
        Values that are used to express one of two possible boolean states.</dd>
      <dt><tdef>null</tdef></dt>
      <dd></dd>
      <dt><tdef>RDF dataset</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-dataset">dataset</tref>
        as specified by [[RDF11-CONCEPTS]] representing a collection of
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</tref>.</dd>
    </dl>
  </section>
</section>

<section>
  <h1>Normalization</h1>

  <p class="issue">This algorithm is a work in progress, do not implement it.</p>

  <p>Normalization is the process of transforming an <tref>input dataset</tref>
    to a <tref>standard dataset</tref>. That is, for two
    <tref>input dataset</tref>s containing the same information, regardless
    of their arrangement, will be transformed into identical
    <tref>standard dataset</tref>s. The problem is a fairly difficult technical
    problem to solve because it requires directed graphs to be deterministically
    ordered into sets of nodes and edges. This is easy to do when all of the
    nodes have globally unique names, but difficult to do when some of the nodes
    are not labeled. Any unlabeled nodes must be deterministically labeled.</p>

  <p>In time, there may be more than one normalization algorithm and,
    therefore, for identification purposes, this algorithm is named the
    "Universal RDF Datset Normalization Algorithm 2015"
    (<abbr title="Universal RDF Dataset Normalization Algorithm 2015">URDNA2015</abbr>).</p>

  <section>
    <h1>Normalization Algorithm Terms</h1>
    <dl>
      <dt><tdef>input dataset</tdef></dt>
      <dd>
        The abstract <tref>RDF dataset</tref> that is provided as input to the
        algorithm.
      </dd>
      <dt><tdef>standard dataset</tdef></dt>
      <dd>
        The abstract <tref>RDF dataset</tref> that is produced as output by the
        algorithm.
      </dd>
      <dt><tdef>quad</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>subject</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>predicate</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>object</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>graph name</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>blank node</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>blank node labeler</tdef></dt>
      <dd>
        A blank node labeler maintains a mapping of existing blank node
        labels to new ones. It also tracks the order in which new labels
        were assigned.
      </dd>
      <dt><tdef>label</tdef></dt>
      <dd>
        The subject IRI associated with a graph node.
      </dd>
    </dl>
  </section>

  <section>
    <h1>Normalization State</h1>

    <p>When performing the steps required by the normalization algorithm,
      it is helpful to track state in a data structure called the
      <tdef>normalization state</tdef>. The information contained in the
      <tref>normalization state</tref> is described below.</p>

    <dl>
      <dt><tdef>blank node to quads map</tdef></dt>
      <dd>A data structure that maps <tref>blank node</tref> labels to
        the <tref>quad</tref>s in which they appear in the
        <tref>input dataset</tref>.</dd>
      <dt><tdef>hash to blank nodes map</tdef></dt>
      <dd>A data structure that maps a hash to a list of <tref>blank node</tref>
        labels.</dd>
      <dt><tdef>canonical labeler</tdef></dt>
      <dd>A unique labeler that uses the prefix <code>_:c14n</code> to
        assign labels to <tref>blank node</tref>s.
      </dd>
      <dt><tdef>list of non-normalized blank nodes</tdef></dt>
      <dd>TODO</dd>
    </dl>
  </section>

  <section>
    <h1>Blank Node Labeler State</h1>

    <p>When relabeling <tref>blank node</tref>s during the normalization
      algorithm, <tref>blank node labeler</tref>s need to keep track of
      state. The information they need to track is described below.</p>

    <dl>
      <dt><tdef>labeling prefix</tdef></dt>
      <dd>
        The labeling prefix is a string that is used as the beginning of a
        <tref>blank node</tref> label. It should be initialized to a
        string that is specified by the normalization algorithm. The prefix is
        used to help generate unique new labels for <tref>blank node</tref>s.
        It is concatenated with a <tref>labeling counter</tref> to produce
        a <tref>blank node</tref> label. For example, <code>_:c14n</code> is
        a proper initial value for the <tref>labeling prefix</tref> that would
        produce <tref>blank node</tref> labels like <code>_:c14n1</code>.
      </dd>
      <dt><tdef>labeling counter</tdef></dt>
      <dd>
        A counter that is used to label <tref>blank node</tref>s. It is
        appended to the <tref>labeling prefix</tref> to create a
        <tref>blank node</tref> label. It is initialized to <code>1</code>.
      </dd>
      <dt><tdef>labeler ordering list</tdef></dt>
      <dd>
        A list that tracks the order in which existing <tref>blank node</tref>
        labels were relabeled.
      </dd>
    </dl>
  </section>

  <section>
    <h2>Normalization Algorithm</h2>

    <p>The normalization algorithm converts an <tref>input dataset</tref>
      into a <tref>standard dataset</tref>. This algorithm will assign
      deterministic labels to any <tref>blank node</tref>s in the
      <tref>input dataset</tref>.</p>

    <p class="issue">Documenting the algorithm is a WIP, various steps will
      become more detailed in time.</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>

      <ol class="algorithm">
        <li>Create the <tref>normalization state</tref>.</li>
        <li>For every <tref>quad</tref> in <tref>input dataset</tref>:
          <ol class="algorithm">
            <li>For each <tref>blank node</tref> that occurs in the
              <tref>quad</tref>'s <tref>subject</tref>, <tref>object</tref>, or
              <tref>graph name</tref> position, add a reference to the
              <tref>quad</tref> using the <tref>blank node</tref>'s
              label in the <tref>blank node to quads map</tref>, creating a
              new entry in the map if necessary.
            </li>
          </ol>
        </li>
        <li>Populate the <tref>list of non-normalized blank nodes</tref> using
          the keys from the <tref>blank node to quads map</tref>.</li>
        <li>Initialize an <tdef>easy label</tdef> flag to
          <code>true</code>.</li>
        <li>While the <tref>easy label</tref> flag is <code>true</code>,
          canonically-label the easy-to-label <tref>blank node</tref>s:</li>
          <ol class="algorithm">
            <li>Set the <tref>easy label</tref> flag to <code>false</code>.</li>
            <li>Clear the <tref>hash to blank nodes map</tref>.</li>
            <li>For each <tref>blank node</tref> label in
              <tref>list of non-normalized blank nodes</tref>:</li>
              <ol class="algorithm">
                <li>Create a hash according to the
                  <a href="#hash-quads">Hash Quads algorithm</a>.</li>
                <li>Add the hash and <tref>blank node</tref> label to the
                  <tref>hash to blank nodes map</tref>, creating a new entry
                  if necessary.</li>
              </ol>
            <li>For each entry in the <tref>hash to blank nodes map</tref> in
              lexicographically-sorted order:
              <ol class="algorithm">
                <li>If the length of the list of
                  <tref>blank node</tref> labels is greater than
                  <code>1</code>, continue to the next entry.</li>
                <li>Create the canonical label for the single
                  <tref>blank node</tref> label in the list of
                  <tref>blank node</tref> labels using the
                    <a href="#node-relabeling">Node Relabeling algorithm</a>.
                </li>
                <li>Remove the entry from the
                  <tref>hash to blank nodes map</tref>.</li>
                <li>Set the <tref>easy label</tref> flag to
                  <code>true</code>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>For each entry in the <tref>hash to blank nodes map</tref> in
          lexicographically-sorted order:</li>
          <ol class="algorithm">
            <li>Create a <tdef>hash path list</tdef>.</li>
            <li>For each <tref>blank node</tref> label in the entry's list:</li>
              <ol class="algorithm">
                <li>If the <tref>blank node</tref> label has already
                  been mapped to a canonical label, continue to the next
                  <tref>blank node</tref>.</li>
                <li>Create a blank node labeler using the prefix
                  <code>_:b</code>.</li>
                <li>Assign the <tref>blank node</tref> label a new
                  label using the blank node labeler.</li>
                <li>Run the <a href="#hash-paths">Hash Paths algorithm</a>,
                  passing the blank node labeler, and append the result to the
                  <tref>hash path list</tref>.</li>
              </ol>
            </li>
            <li>For each entry in the <tref>hash path list</tref>, sorted
              by hash:</li>
              <ol class="algorithm">
                <li>Assign a canonical label to each <tref>blank node</tref>
                  label in the entry's blank node labeler, in the order in
                  which they were assigned temporary labels.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>For each <tref>quad</tref> in <tref>input dataset</tref>:
          <ol class="algorithm">
            <li>Create a copy the <tref>quad</tref> and replace any
              <tref>blank node</tref> labels using the
              <tref>canonical labeler</tref>.</li>
            <li>Add the copied <tref>quad</tref> to the
            <tref>standard dataset</tref>.</li>
          </ol>
        </li>
        <li>Return the <tref>standard dataset</tref>.</li>
      </ol>
    </section>
  </section>

  <section>
    <h2>Node Relabeling Algorithm</h2>

    <p class="issue">WIP; perhaps change name to Node Label
      Generation/Assignment Algorithm as the actual relabeling occurs
      elsewhere.</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>
    </section>

    <p>This algorithm generates a mapping from an old <tref>blank node</tref>
    label to a new unique <tref>blank node</tref> label. It also tracks
    the order in which <tref>blank node</tref> labels were assigned.

    <p>The node relabeling algorithm is as follows:</p>

    <ol class="algorithm">
      <li>If the <tref>blank node</tref> has already been relabeled,
        return the same unique new label that was returned previously.</li>
      <li>Append the <tref>blank node</tref>'s label to the
        <tref>labeler ordering list</tref>.</li>
      <li>Generate the <tdef>new label</tdef> by concatenating the
        <tref>labeling prefix</tref> with the string value of the
        <tref>labeling counter</tref>.</li>
      <li>Increment the <tref>labeling counter</tref>.</li>
      <li>Return the <tref>new label</tref>.</li>
    </ol>
  </section>

  <section>
    <h2>Hash Quads</h2>

    <p class="issue">TODO</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>
    </section>
  </section>

  <section>
    <h2>Hash Paths</h2>

    <p class="issue">TODO</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>Usually, when trying to determine if two nodes in a graph are
        equivalent, you simply compare their identifiers. However, what if the
        nodes don't have identifiers? Then you must determine if the two nodes
        have equivalent connections to equivalent nodes all throughout the
        whole graph. This is called the graph isomorphism problem. This
        algorithm approaches this problem by considering how one might draw
        a graph on paper. You can test to see if two nodes are equivalent
        by drawing the graph twice. The first time you draw the graph the
        first node is drawn in the center of the page. If you can draw the
        graph a second time such that it looks just like the first, except
        the second node is in the center of the page, then the nodes are
        equivalent. This algorithm essentially defines a determinitsic way to
        draw a graph where, if you begin with a particular node, the graph
        will always be drawn the same way. If two graphs are drawn the same way
        with two different nodes, then the nodes are equivalent. A hash is used
        to indicate a particular way that the graph has been drawn and can
        be used to compare nodes.</p>

      <p>This algorithm works in concert with the main normalization algorithm
        to produce a unique, deterministic identifier for a particular blank
        node. This hash incorporates all of the information that is connected
        to the blank node as well as how it is connected. It does this by
        creating deterministic paths that emanate out from the blank node
        through any other adjacent blank nodes. The process is as follows:</p>

      <ul>
        <li>Start by taking the perspective that the <tref>blank node</tref> is
          at the center of the graph. This is the starting point for which all
          paths will radiate outward.</li>
        <li>Create a <tref>blank node labeler</tref> and assign a label
          to the starting <tref>blank node</tref>.</li>
        <li>Start the main message digest hash.</li>
        <li>For each adjacent <tref>blank node</tref>, determine a label for
          it, first using the canonical label if already assigned, second
          using the label from the local <tref>blank node labeler</tref> if
          already assigned, and lastly, use the result of the
          <a href="#hash-quads">Hash Quads algorithm</a> as the label.</li>
        <li>Create a group message digest hash, digesting data representing
          the direction of the <tref>blank node</tref> relationship (subject
          to object or object from subject) relative to the original
          <tref>blank node</tref>, the predicate, and the
          <tref>blank node</tref> label. Store a record of this group hash
          and its matching <tref>blank node</tref>.</li>
        <li>Now iterate over each of the group hashes and related
          <tref>blank node</tref>s. For each group, use the main hash to
          digest the group hash and create a copy of the
          <tref>blank node labeler</tref> to be used in case recursion is
          needed. Then, proceed to construct a path. For each permutation of
          <tref>blank node</tref>s in the group, concatenate the canonical
          label for it, if already assigned, to the path. If not, and the
          <tref>blank node labeler</tref> has not assigned it a label, take
          note of this and then assign it one. If a path has already been
          selected as the canonical path, stop permutating.</li>
        <li>If no path has been chosen as the canonical one, recurse into
          each of the <tref>blank node</tref>s that was assigned a label
          in the previous step, passing the copy of the
          <tref>blank node labeler</tref> to use in the algorithm. Append the
          resulting hash of the recursion to the path and update the reference
          to the copy of the <tref>blank node labeler</tref> to the one
          given in the result of the algorithm.</li>
        <li>If no path has been chosen or the current path is shorter than
          the currently chosen path, update the chosen path to the current
          path. Set the chosen namer to match the one used to produce the
          path.</li>
        <li>Use the main hash to digest the chosen path and return it
          and the chosen namer as the result of the algorithm.</li>
      </ul>
    </section>

    <p class="issue">When processing adjacent blank nodes, can they be skipped
      if they've already been canonically labeled?</p>

    <p class="issue">When creating group hashes, does the graph name also
      need to be digested (not just direction of relationship, predicate,
      and blank node label)? It may not be necessary as any structural
      differences would get picked up by the Hash Quads algorithm or by
      recursion. If there are no differences then it won't matter because
      the same hash will be produced anyway.
    </p>

    <section>
      <h3>Algorithm</h3>

      <!-- <ol class="algorithm">
        <li>Digest the group hash.</li>
        <li>Build the shortest, lexicographically least *path* of
          blank nodes in the group that visits all nodes in the group
          without cycling and that serializes them using the hash that
          results from recursively calling this algorithm. Track the order
          the blank nodes were visited.
         </li>
         <li>Digest the chosen path.</li>
      </ol>
      <li>Process the resulting group hashes in sorted order,
        labeling any remaining blank nodes by using the order in which
        the nodes were visited when constructing the associated
        shortest *path*.</li> -->
  </section>
</section>

<section class="appendix">
  <h1>Acknowledgements</h1>

  <p>The editors would like to thank Jeremy Carroll for his work on the
    graph normalization problem, Gavin Carothers for providing valuable
    feedback and testing input for the algorithm defined in this
    specification, Sir Tim Berners Lee for his thoughts on graph normalization
    over the years, and Jes√∫s Arias Fisteus for his work on a similar
    algorithm. Finally, a huge thank you goes out to Dave Longley who designed
    and implemented the algorithms used in this specification, which turned out
    to be a monumentally difficult design challenge.</p>
</section>

</body>
</html>
