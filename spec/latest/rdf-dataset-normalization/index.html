<!DOCTYPE html>
<html>
<head>
<title>RDF Dataset Normalization</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script type="text/javascript" src="../respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" src="../respec-w3c-extensions.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
  var respecConfig = {
      // extend the bibliography entries
      "localBiblio": localBibliography,

      doRDFa: "1.1",
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "CG-DRAFT",
      //publishDate:          "2010-04-29",
      copyrightStart:       "2010",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "rdf-dataset-normalization",
      subtitle:             "A Standard RDF Dataset Normalization Algorithm",
      // if you wish the publication date to be other than today, set this
      // publishDate:  "2009-08-06",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      //previousPublishDate:  "2011-08-17",
      //previousMaturity:     "ED",
      //previousDiffURI:      "http://json-ld.org/spec/ED/20110817/index.html",
      //diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "http://json-ld.org/spec/latest/rdf-dataset-normalization/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      issueBase: "https://github.com/json-ld/json-ld.org/issues/",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS: [],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
          { name: "Manu Sporny", url: "http://manu.sporny.org/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"}
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:  [
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
          { name: "Manu Sporny", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" }
      ],

      // name of the WG
      wg: "JSON for Linking Data W3C Community Group",

      // URI of the public WG page
      wgURI: "http://www.w3.org/community/json-ld/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-linked-json",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "",
      maxTocLevel: 2,
      preProcess: [ preProc ],
      //alternateFormats: [ {uri: "diff-20110817.html", label: "diff to previous version"} ]
  };
//]]>
</script>
<style type="text/css">
  .highlight { font-weight: bold; color: #0a3; }
  .comment { color: #999; }
  table, thead, tr, td { padding: 5px; border-width: 1px; border-spacing: 0px; border-style: solid; border-collapse: collapse; }
</style>
</head>

<body>
<section id="abstract">
  <p>RDF [[RDF-CONCEPTS]] describes a graph-based data model for making claims
    about the world and provides the foundation for reasoning upon that graph
    of information. At times, it becomes necessary to compare the differences
    between datasets of graphs, digitally sign them, or generate short
    identifiers for graphs via hashing algorithms. This document outlines an
    algorithm for normalizing RDF datasets such that these operations can be
    performed.</p>
</section>

<section id="sotd">
  <p>This document is an experimental work in progress.</p>
  <!-- <p>This document has been reviewed by W3C Members, by software
    developers, and by other W3C groups and interested parties, and is
    endorsed by the Director as a W3C Recommendation. It is a stable
    document and may be used as reference material or cited from another
    document. W3C's role in making the Recommendation is to draw attention
    to the specification and to promote its widespread deployment. This
    enhances the functionality and interoperability of the Web.</p> -->
</section>

<section>
  <h1>Introduction</h1>

  <p>When data scientists discuss normalization, they do so in the context of
    achieving a particular set of goals. Since the same information may
    sometimes be expressed in a variety of different ways, it often becomes
    necessary to be able to transform each of these different ways into a
    single, standard format. With a standard format, the differences between
    two different sets of data can be easily determined, a
    cryptographically-strong hash identifier can be generated for a particular
    set of data, and a particular set of data may be digitally-signed for later
    verification.</p>

  <p>In particular, this specification is about normalizing
    <tref>RDF dataset</tref>s, which are collections of graphs. Since
    a directed graph can express the same information in more than one
    way, it requires normalization to achieve the aforementioned goals
    and any others that may arise via surrendipity.</p>

  <p>Most <tref>RDF dataset</tref> can be normalized fairly quickly, in terms
    of algorithmic time complexity. However, those that contain nodes that do
    not have globally unique identifiers pose a greater challenge. Normalizing
    these datasets presents the <tdef>graph isomorphism</tdef> problem, a
    problem that is believed to be difficult to solve quickly. More formally,
    it is believed to be an NP-Intermediate problem, that is, neither known to
    be solvable in polynomial time nor NP-complete. Fortunately, existing real
    world data is rarely modeled in a way that manifests this problem and new
    data can be modeled to avoid it. In fact, software systems can detect a
    problematic dataset and may choose to assume it's an attempted denial of
    service attack, rather than a real input, and abort.</p>

  <p>This document outlines an algorithm for generating a normalized
    <tref>RDF dataset</tref> given an <tref>RDF dataset</tref> as input. The
    algorithm is called the
    <strong>Universal RDF Dataset Normalization Algorithm 2015</strong> or
    <strong>URDNA2015</strong>.</p>

  <section>
    <h2>How to Read this Document</h2>

    <p>This document is a detailed specification for an <tref>RDF dataset</tref>
      normalization algorithm. The document is primarily intended for the
      following audiences:</p>

    <ul>
      <li>Software developers that want to implement an <tref>RDF dataset</tref>
        normalization algorithm.</li>
      <li>Masochists.</li>
    </ul>

    <p>To understand the basics in this specification you must be familiar with
      basic RDF concepts [[!RDF-CONCEPTS]]. A working knowledge of
      <a href="http://en.wikipedia.org/wiki/Graph_theory">graph theory</a> and
      <a href="http://en.wikipedia.org/wiki/Graph_isomorphism">graph isomorphism</a>
      is also recommended.</p>
  </section>

  <section>
    <h2>Contributing</h2>

    <p>There are a number of ways that one may participate in the development
      of this specification:</p>

    <ul>
      <li>Technical discussion typically occurs on the public mailing list:
        <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

      <li><a href="http://json-ld.org/minutes/">Public teleconferences</a> are
        held on Tuesdays at 1500UTC on the second and fourth week of each
        month.</li>

      <li>Specification bugs and issues should be reported in the
        <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>.</li>

      <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a> for the
        specification can be found on Github.</li>

      <li>The <a href="http://webchat.freenode.net/?channels=#json-ld">#json-ld</a>
        IRC channel is available for real-time discussion on
        <a href="irc.freenode.net">irc.freenode.net.</a></li>
    </ul>
  </section>
</section>

<section class="normative">
  <h1>Terminology</h1>

  <section class="normative">
    <h2>General Terminology</h2>

    <!-- FIXME: remove any unnecessary JSON terminology -->

    <p>This document uses the following terms as defined in JSON [[!RFC4627]]. Refer
      to the <em>JSON Grammar</em> section in [[!RFC4627]] for formal definitions.</p>

    <dl>
      <dt><tdef>JSON object</tdef></dt><dd>
        An object structure is represented as a pair of curly brackets surrounding
        zero or more key-value pairs. A key is a <tref>string</tref>.
        A single colon comes after each key, separating the key from the value.
        A single comma separates a value from a following key.</dd>
      <dt><tdef>array</tdef></dt>
      <dd>An array structure is represented as square brackets surrounding zero
        or more values. Values are separated by commas.
        In JSON, an array is an <em>ordered</em> sequence of zero or more values.</dd>
      <dt><tdef>string</tdef></dt><dd>
        A string is a sequence of zero or more Unicode characters,
        wrapped in double quotes, using backslash escapes (if necessary).</dd>
      <dt><tdef>number</tdef></dt>
      <dd>A number is similar to that used in most programming languages, except
        that the octal and hexadecimal formats are not used and leading zeros
        are not allowed.</dd>
      <dt><tdef>true</tdef> and <tdef>false</tdef></dt><dd>
        Values that are used to express one of two possible boolean states.</dd>
      <dt><tdef>null</tdef></dt>
      <dd></dd>
      <dt><tdef>RDF dataset</tdef></dt>
      <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-dataset">dataset</tref>
        as specified by [[RDF11-CONCEPTS]] representing a collection of
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</tref>.</dd>
    </dl>
  </section>
</section>

<section>
  <h1>Normalization</h1>

  <p class="issue">This algorithm is a work in progress, do not implement it.</p>

  <p>Normalization is the process of transforming an <tref>input dataset</tref>
    to a <tref>standard dataset</tref>. That is, for two
    <tref>input dataset</tref>s containing the same information, regardless
    of their arrangement, will be transformed into identical
    <tref>standard dataset</tref>s. The problem is a fairly difficult technical
    problem to solve because it requires directed graphs to be deterministically
    ordered into sets of nodes and edges. This is easy to do when all of the
    nodes have globally unique names, but difficult to do when some of the nodes
    are not labeled. Any unlabeled nodes must be deterministically labeled.</p>

  <p>In time, there may be more than one normalization algorithm and,
    therefore, for identification purposes, this algorithm is named the
    "Universal RDF Datset Normalization Algorithm 2015"
    (<abbr title="Universal RDF Dataset Normalization Algorithm 2015">URDNA2015</abbr>).</p>

  <section>
    <h1>Normalization Algorithm Terms</h1>
    <dl>
      <dt><tdef>input dataset</tdef></dt>
      <dd>
        The abstract <tref>RDF dataset</tref> that is provided as input to the
        algorithm.
      </dd>
      <dt><tdef>standard dataset</tdef></dt>
      <dd>
        The abstract <tref>RDF dataset</tref> that is produced as output by the
        algorithm.
      </dd>
      <dt><tdef>quad</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>subject</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>predicate</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>object</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>graph name</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>blank node</tdef></dt>
      <dd>TODO</dd>
      <dt><tdef>blank node labeler</tdef></dt>
      <dd>
        A blank node labeler maintains a mapping of existing blank node
        labels to new ones. It also tracks the order in which new labels
        were assigned.
      </dd>
      <!--
      <dt><tdef>input graph</tdef></dt>
      <dd></dd>
      <dt><tdef>output graph</tdef></dt>
      <dd></dd>
      <dt><tdef>label</tdef></dt>
      <dd>
        The subject IRI associated with a graph node.
      </dd>
      <dt><tdef>list of expanded nodes</tdef></dt>
      <dd>
        A list of all nodes in the <tref>input graph</tref>.
      </dd>
      <dt><tdef>alpha</tdef> and <tdef>beta</tdef> values</dt>
      <dd>
        The words <tref>alpha</tref> and <tref>beta</tref> refer to the first and
        second nodes or values being examined in an algorithm. The names are
        merely used to refer to each input value to a comparison algorithm.
      </dd>
      <dt><tdef>renaming counter</tdef></dt>
      <dd>
        A counter that is used during the
        <a href="#node-relabeling-algorithm">Node Relabeling Algorithm</a>. The
        counter typically starts at one (1) and counts up for every node that is
        relabeled. There will be two such renaming counters in an implementation
        of the normalization algorithm. The first is the
        <tref>labeling counter</tref> and the second is the
        <tdef>deterministic labeling counter</tdef>.
      </dd>
      <dt><tdef>serialization label</tdef></dt>
      <dd>
        An identifier that is created to aid in the normalization process in the
        <a href="#deep-comparison-algorithm">Deep Comparison Algorithm</a>. The
        value typically takes the form of <code>s&lt;NUMBER&gt;</code> or
        <code>c&lt;NUMBER&gt;</code>.
      </dd>
      <dt><tdef>serialization labels map</tdef></dt>
      <dd></dd> -->
    </dl>
  </section>

  <section>
    <h1>Normalization State</h1>

    <p>When performing the steps required by the normalization algorithm,
      it is helpful to track state in a data structure called the
      <tdef>normalization state</tdef>. The information contained in the
      <tref>normalization state</tref> is described below.</p>

    <dl>
      <dt><tdef>blank node to quads map</tdef></dt>
      <dd>A data structure that maps <tref>blank node</tref> labels to
        the <tref>quad</tref>s in which they appear in the
        <tref>input dataset</tref>.</dd>
      <dt><tdef>hash to blank nodes map</tdef></dt>
      <dd>A data structure that maps a hash to a list of <tref>blank node</tref>
        labels.</dd>
      <dt><tdef>canonical labeler</tdef></dt>
      <dd>A unique labeler that uses the prefix <code>_:c14n</code> to
        assign labels to <tref>blank node</tref>s.
      </dd>
      <dt><tdef>list of non-normalized blank nodes</tdef></dt>
      <dd>TODO</dd>

<!--
       <dt><tdef>node state</tdef></dt>
       <dd>
         Each node in the graph will be assigned a <tref>node state</tref>. This
         state contains the information necessary to deterministically
         <tref>label</tref> all nodes in the graph. A <tref>node state</tref>
         includes:
         <dl>
            <dt><tdef>node reference</tdef></dt>
            <dd>
              A <tref>node reference</tref> is a reference to a node in the graph.
              For a given <tref>node state</tref>, its <tref>node reference</tref>
              refers to the node that the state is for. When a
              <tref>node state</tref> is created, its <tref>node reference</tref>
              should be to the node it is created for.
            </dd>
            <dt><tdef>outgoing list</tdef></dt>
            <dd>
              Lists the <tref>label</tref>s for all nodes that are properties of
              the <tref>node reference</tref>. This list should be initialized
              by iterating over every object associated with a property in the
              <tref>node reference</tref> adding its label if it is another node.
            </dd>
            <dt><tdef>incoming list</tdef></dt>
            <dd>
              Lists the <tref>label</tref>s for all nodes in the graph for which
              the <tref>node reference</tref> is a property. This list is
              initialized to an empty list.
            </dd>
            <dt><tdef>outgoing serialization map</tdef></dt>
            <dd>
              Maps node <tref>label</tref>s to <tref>serialization label</tref>s.
              This map is initialized to an empty map. When this map is populated,
              it will be filled with keys that are the <tref>label</tref>s of every node in the
              graph with a label that begins with <code>_:</code> and that has a
              path, via properties, that starts with the
              <tref>node reference</tref>.
            </dd>
            <dt><tdef>outgoing serialization</tdef></dt>
            <dd>
              A string that can be lexicographically compared to the
              <tref>outgoing serialization</tref>s of other
              <tref>node state</tref>s. It is a representation of the
              <tref>outgoing serialization map</tref> and other related
              information. This string is initialized to an empty string.
            </dd>
            <dt><tdef>serialization map</tdef></dt>
            <dd></dd>
            <dt><tdef>incoming serialization map</tdef></dt>
            <dd>
              Maps node <tref>label</tref>s to <tref>serialization label</tref>s.
              This map is initialized to an empty map. When this map is populated,
              it will be filled with keys that are the <tref>label</tref>s of every
              node in the graph with a <tref>label</tref> that begins with
              <code>_:</code> and that has a path, via properties, that ends with
              the <tref>node reference</tref>.
            </dd>
            <dt><tdef>incoming serialization</tdef></dt>
            <dd>
              A string that can be lexicographically compared to the
              <tref>outgoing serialization</tref>s of other
              <tref>node state</tref>s. It is a representation of the
              <tref>incoming serialization map</tref> and other related
              information. This string is initialized to an empty string.
            </dd>
         </dl>
       </dd>
       <dt><tdef>node state map</tdef></dt>
       <dd>
         A mapping from a node's <tref>label</tref> to a <tref>node state</tref>.
         It is initialized to an empty map.
       </dd>
       <dt><tdef>labeling prefix</tdef></dt>
       <dd>
         The labeling prefix is a string that is used as the beginning of a node
         <tref>label</tref>. It should be initialized to a random base string that
         starts with the characters <code>_:</code>, is not used by any other
         node's <tref>label</tref> in the <tref>input graph</tref>, and does not
         start with the characters <code>_:c14n</code>. The prefix has two uses.
         First it is used to temporarily name nodes during the normalization
         algorithm in a way that doesn't collide with the names that already
         exist as well as the names that will be generated by the normalization
         algorithm. Second, it will eventually be set to <code>_:c14n</code> to
         generate the final, deterministic labels for nodes in the graph. This
         prefix will be concatenated with the <tref>labeling counter</tref> to
         produce a node <tref>label</tref>. For example, <code>_:j8r3k</code> is
         a proper initial value for the <tref>labeling prefix</tref>.
       </dd>
       <dt><tdef>labeling counter</tdef></dt>
       <dd>
         A counter that is used to label nodes. It is appended to the
         <tref>labeling prefix</tref> to create a node <tref>label</tref>. It is
         initialized to <code>1</code>.
       </dd>
       <dt><tdef>map of flattened nodes</tdef></dt>
       <dd>
         A map containing a representation of all nodes in the graph where the
         key is a node <tref>label</tref> and the value is a single
         <tref>JSON object</tref> that has no nested sub-objects
         and has had all properties for the same node merged into a single
         <tref>JSON object</tref>.
       </dd>
      -->
    </dl>
  </section>

  <section>
    <h2>Normalization Algorithm</h2>

    <p>The normalization algorithm converts an <tref>input dataset</tref>
      into a <tref>standard dataset</tref>. This algorithm will assign
      deterministic labels to any <tref>blank node</tref>s in the
      <tref>input dataset</tref>.</p>

    <p class="issue">Documenting the algorithm is a WIP, various steps will
      become more detailed in time.</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>

      <ol class="algorithm">
        <li>Create the <tref>normalization state</tref>.</li>
        <li>For every <tref>quad</tref> in <tref>input dataset</tref>:
          <ol class="algorithm">
            <li>For each <tref>blank node</tref> that occurs in the
              <tref>quad</tref>'s <tref>subject</tref>, <tref>object</tref>, or
              <tref>graph name</tref> position, add a reference to the
              <tref>quad</tref> using the <tref>blank node</tref>'s
              label in the <tref>blank node to quads map</tref>, creating a
              new entry in the map if necessary.
            </li>
          </ol>
        </li>
        <li>Populate the <tref>list of non-normalized blank nodes</tref> using
          the keys from the <tref>blank node to quads map</tref>.</li>
        <li>Initialize an <tdef>easy label</tdef> flag to
          <code>true</code>.</li>
        <li>While the <tref>easy label</tref> flag is <code>true</code>,
          canonically-label the easy-to-label <tref>blank node</tref>s:</li>
          <ol class="algorithm">
            <li>Set the <tref>easy label</tref> flag to <code>false</code>.</li>
            <li>Clear the <tref>hash to blank nodes map</tref>.</li>
            <li>For each <tref>blank node</tref> label in
              <tref>list of non-normalized blank nodes</tref>:</li>
              <ol class="algorithm">
                <li>Create a hash according to the
                  <a href="#hash-quads">Hash Quads algorithm</a>.</li>
                <li>Add the hash and <tref>blank node</tref> label to the
                  <tref>hash to blank nodes map</tref>, creating a new entry
                  if necessary.</li>
              </ol>
            <li>For each entry in the <tref>hash to blank nodes map</tref> in
              lexicographically-sorted order:
              <ol class="algorithm">
                <li>If the length of the list of
                  <tref>blank node</tref> labels is greater than
                  <code>1</code>, continue to the next entry.</li>
                <li>Create the canonical label for the single
                  <tref>blank node</tref> label in the list of
                  <tref>blank node</tref> labels using the
                    <a href="#node-relabeling">Node Relabeling algorithm</a>.
                </li>
                <li>Remove the entry from the
                  <tref>hash to blank nodes map</tref>.</li>
                <li>Set the <tref>easy label</tref> flag to
                  <code>true</code>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>For each entry in the <tref>hash to blank nodes map</tref> in
          lexicographically-sorted order:</li>
          <ol class="algorithm">
            <li>Create a <tdef>hash path list</tdef>.</li>
            <li>For each <tref>blank node</tref> label in the entry's list:</li>
              <ol class="algorithm">
                <li>If the <tref>blank node</tref> label has already
                  been mapped to a canonical label, continue to the next
                  <tref>blank node</tref>.</li>
                <li>Create a blank node labeler using the prefix
                  <code>_:b</code>.</li>
                <li>Assign the <tref>blank node</tref> label a new
                  label using the blank node labeler.</li>
                <li>Run the <a href="#hash-paths">Hash Paths algorithm</a>,
                  passing the blank node labeler, and append the result to the
                  <tref>hash path list</tref>.</li>
              </ol>
            </li>
            <li>For each entry in the <tref>hash path list</tref>, sorted
              by hash:</li>
              <ol class="algorithm">
                <li>Assign a canonical label to each <tref>blank node</tref>
                  label in the entry's blank node labeler, in the order in
                  which they were assigned temporary labels.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>For each <tref>quad</tref> in <tref>input dataset</tref>:
          <ol class="algorithm">
            <li>Create a copy the <tref>quad</tref> and replace any
              <tref>blank node</tref> labels using the
              <tref>canonical labeler</tref>.</li>
            <li>Add the copied <tref>quad</tref> to the
            <tref>standard dataset</tref>.</li>
          </ol>
        </li>
        <li>Return the <tref>standard dataset</tref>.</li>
      </ol>
    </section>
  </section>

  <section>
    <h2>Node Relabeling Algorithm</h2>

    <p class="issue">This algorithm is out-of-date, don't implement it.</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>
    </section>

    <!--

    <p>This algorithm renames a node by generating a unique
    <tdef>new label</tdef> and updating all references to that <tref>label</tref>
    in the <tref>node state map</tref>. The <tdef>old label</tdef> and the
    <tref>normalization state</tref> must be given as an input to the
    algorithm. The <tref>old label</tref> is the current <tref>label</tref> of
    the node that is to be relabeled.

    <p>The node relabeling algorithm is as follows:</p>

    <ol class="algorithm">
      <li>If the <tref>labeling prefix</tref> is <code>_:c14n</code> and the
        <tref>old label</tref> begins with <code>_:c14n</code> then return as
        the node has already been renamed.
      </li>
      <li>Generate the <tref>new label</tref> by concatenating the
        <tref>labeling prefix</tref> with the string value of the
        <tref>labeling counter</tref>. Increment the <tref>labeling counter</tref>.
      </li>
      <li>For the <tref>node state</tref> associated with the
      <tref>old label</tref>, update every node in the <tref>incoming list</tref>
      by changing all the properties that reference the <tref>old label</tref> to
      the <tref>new label</tref>.
      </li>
      <li>Change the <tref>old label</tref> key in the <tref>node state map</tref>
        to the <tref>new label</tref> and set the associated
        <tref>node reference</tref>'s <tref>label</tref> to the
        <tref>new label</tref>.
      </li>
    </ol> -->
  </section>

  <section>
    <h2>Hash Quads</h2>

    <p class="issue">TODO</p>

    <section class="informative">
      <h3>Overview</h3>
    </section>

    <section>
      <h3>Algorithm</h3>
    </section>
  </section>

  <section>
    <h2>Hash Paths</h2>

    <p class="issue">TODO</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>Usually, when trying to determine if two nodes in a graph are
        equivalent, you simply compare their identifiers. However, what if the
        nodes don't have identifiers? Then you must determine if the two nodes
        have equivalent connections to equivalent nodes all throughout the
        whole graph. This is called the graph isomorphism problem. This
        algorithm approaches this problem by considering how one might draw
        a graph on paper. You can test to see if two nodes are equivalent
        by drawing the graph twice. The first time you draw the graph the
        first node is drawn in the center of the page. If you can draw the
        graph a second time such that it looks just like the first, except
        the second node is in the center of the page, then the nodes are
        equivalent. This algorithm essentially defines a determinitsic way to
        draw a graph where, if you begin with a particular node, the graph
        will always be drawn the same way. If two graphs are drawn the same way
        with two different nodes, then the nodes are equivalent. A hash is used
        to indicate a particular way that the graph has been drawn and can
        be used to compare nodes.</p>

      <p>This algorithm works in concert with the main normalization algorithm
        to produce a unique, deterministic identifier for a particular blank
        node. This hash incorporates all of the information that is connected
        to the blank node as well as how it is connected. It does this by
        creating deterministic paths that emanate out from the blank node
        through any other adjacent blank nodes. The process is as follows:</p>

      <ul>
        <li>Start by taking the perspective that the <tref>blank node</tref> is
          at the center of the graph. This is the starting point for which all
          paths will radiate outward.</li>
        <li>Create a <tref>blank node labeler</tref> and assign a label
          to the starting <tref>blank node</tref>.</li>
        <li>Start the main message digest hash.</li>
        <li>For each adjacent <tref>blank node</tref>, determine a label for
          it, first using the canonical label if already assigned, second
          using the label from the local <tref>blank node labeler</tref> if
          already assigned, and lastly, use the result of the
          <a href="#hash-quads">Hash Quads algorithm</a> as the label.</li>
        <li>Create a group message digest hash, digesting data representing
          the direction of the <tref>blank node</tref> relationship (subject
          to object or object from subject) relative to the original
          <tref>blank node</tref>, the predicate, and the
          <tref>blank node</tref> label. Store a record of this group hash
          and its matching <tref>blank node</tref>.</li>
        <li>Now iterate over each of the group hashes and related
          <tref>blank node</tref>s. For each group, use the main hash to
          digest the group hash and create a copy of the
          <tref>blank node labeler</tref> to be used in case recursion is
          needed. Then, proceed to construct a path. For each permutation of
          <tref>blank node</tref>s in the group, concatenate the canonical
          label for it, if already assigned, to the path. If not, and the
          <tref>blank node labeler</tref> has not assigned it a label, take
          note of this and then assign it one. If a path has already been
          selected as the canonical path, stop permutating.</li>
        <li>If no path has been chosen as the canonical one, recurse into
          each of the <tref>blank node</tref>s that was assigned a label
          in the previous step, passing the copy of the
          <tref>blank node labeler</tref> to use in the algorithm. Append the
          resulting hash of the recursion to the path and update the reference
          to the copy of the <tref>blank node labeler</tref> to the one
          given in the result of the algorithm.</li>
        <li>If no path has been chosen or the current path is shorter than
          the currently chosen path, update the chosen path to the current
          path. Set the chosen namer to match the one used to produce the
          path.</li>
        <li>Use the main hash to digest the chosen path and return it
          and the chosen namer as the result of the algorithm.</li>
      </ul>
    </section>

    <p class="issue">When processing adjacent blank nodes, can they be skipped
      if they've already been canonically labeled?</p>

    <p class="issue">When creating group hashes, does the graph name also
      need to be digested (not just direction of relationship, predicate,
      and blank node label)? It may not be necessary as any structural
      differences would get picked up by the Hash Quads algorithm or by
      recursion. If there are no differences then it won't matter because
      the same hash will be produced anyway.
    </p>

    <section>
      <h3>Algorithm</h3>

      <!-- <ol class="algorithm">
        <li>Digest the group hash.</li>
        <li>Build the shortest, lexicographically least *path* of
          blank nodes in the group that visits all nodes in the group
          without cycling and that serializes them using the hash that
          results from recursively calling this algorithm. Track the order
          the blank nodes were visited.
         </li>
         <li>Digest the chosen path.</li>
      </ol>
      <li>Process the resulting group hashes in sorted order,
        labeling any remaining blank nodes by using the order in which
        the nodes were visited when constructing the associated
        shortest *path*.</li> -->
  </section>

  <!-- <section>
    <h4>Deterministic Labeling Algorithm</h4>

    <p class="issue">This algorithm is out-of-date, don't implement it.</p>

    <p>The deterministic labeling algorithm takes the
    <tref>normalization state</tref>
    and produces a <tdef>list of finished nodes</tdef> that is sorted and
    contains deterministically named and expanded nodes from the graph.

    <ol class="algorithm">
      <li>Set the <tref>labeling prefix</tref> to <code>_:c14n</code>, the
        <tref>labeling counter</tref> to <code>1</code>,
        the <tref>list of finished nodes</tref> to an empty array, and create
        an empty array, the <tdef>list of unfinished nodes</tdef>.</li>
      <li>For each <tref>node reference</tref> in the <tref>node state map</tref>:
        <ol class="algorithm">
          <li>If the node's <tref>label</tref> does not start with <code>_:</code>
            then put the <tref>node reference</tref> in the
            <tref>list of finished nodes</tref>.
          </li>
          <li>If the node's <tref>label</tref> does start with <code>_:</code>
            then put the <tref>node reference</tref> in the
            <tref>list of unfinished nodes</tref>.
          </li>
        </ol>
      </li>
      <li>Append to the <tref>list of finished nodes</tref> by processing
        the remainder of the <tref>list of unfinished nodes</tref> until it is
        empty:
        <ol class="algorithm">
          <li>Sort the <tref>list of unfinished nodes</tref> in descending order
            according to the
            <a href="#deep-comparison-algorithm">Deep Comparison Algorithm</a> to
            determine the sort order.</li>
          <li>Create a <tdef>list of labels</tdef> and initialize it to an
            empty array.</li>
          <li>For the first node from the <tref>list of unfinished nodes</tref>:
            <ol class="algorithm">
              <li>Add its <tref>label</tref> to the <tref>list of labels</tref>.
              </li>
              <li>For each key-value pair from its associated
                <tref>outgoing serialization map</tref>, add the key to a list and
                then sort the list according to the lexicographical order of the
                keys' associated values. Append the list to the
                <tdef>list of nodes to label</tdef>.
              </li>
              <li>For each key-value pair from its associated
                <tref>incoming serialization map</tref>, add the key to a list and
                then sort the list according to the lexicographical order of the
                keys' associated values. Append the list to the
                <tref>list of nodes to label</tref>.
              </li></ol></li>
          <li>For each <tref>label</tref> in the <tref>list of labels</tref>,
            relabel the associated node according to the
            <a href="#node-relabeling-algorithm">Node Relabeling Algorithm</a>. If
            any <tref>outgoing serialization map</tref> contains a key that
            matches the <tref>label</tref>, clear the map and set the associated
            <tref>outgoing serialization</tref> to an empty string. If any
            <tref>incoming serialization map</tref> contains a key that
            matches the <tref>label</tref>, clear the map and set the associated
            <tref>incoming serialization</tref> to an empty string.
          </li>
          <li>
            Remove each node with a <tref>label</tref> that starts with
            <code>_:c14n</code> from the <tref>list of unfinished nodes</tref> and
            add it to the <tref>list of finished nodes</tref>.
          </li>
        </ol>
      </li>
      <li>Sort the <tref>list of finished nodes</tref> in descending order
        according to the
        <a href="#deep-comparison-algorithm">Deep Comparison Algorithm</a> to
        determine the sort order.</li>
    </ol>

  </section> -->

  <!-- <section>
    <h4>Node Serialization Algorithm</h4>

    <p class="issue">This algorithm is out-of-date, don't implement it.</p>

    <p>
    The node serialization algorithm takes a <tref>node state</tref>, a
    <tref>mapping state</tref>, and a <tdef>direction</tdef> (either
    <code>outgoing direction</code> or <code>incoming direction</code>) as
    inputs and generates a deterministic serialization for the
    <tref>node reference</tref>.
    </p>

    <ol class="algorithm">
    <li>If the <tref>label</tref> exists in the
      <tref>processed labels map</tref>, terminate the algorithm as the
      <tref>serialization label</tref> has already been created.
    </li>
    <li>Set the value associated with the <tref>label</tref> in the
      <tref>processed labels map</tref> to <code>true</code>.
    </li>
    <li>Generate the next <tref>serialization label</tref> for the
      <tref>label</tref> according to the
      <a href="#serialization-label-generation-algorithm">Serialization Label Generation Algorithm</a>.
    </li>
    <li>Create an empty map called the <tdef>adjacent serialized labels map</tdef>
    that will store mappings from <tref>serialization label</tref>s to adjacent
    node <tref>label</tref>s.</li>
    <li>Create an empty array called the
    <tdef>adjacent unserialized labels list</tdef> that will store
    <tref>label</tref>s of adjacent nodes that haven't been assigned
    <tref>serialization label</tref>s yet.
    </li>
    <li>For every <tref>label</tref> in a list, where the list the <tref>outgoing list</tref> if
    the <tref>direction</tref> is <code>outgoing direction</code> and the
    <tref>incoming list</tref> otherwise, if the <tref>label</tref> starts with
    <code>_:</code>, it is the <tdef>target node label</tdef>:
      <ol class="algorithm">
        <li>Look up the <tref>target node label</tref> in the
          <tref>processed labels map</tref> and if a mapping exists,
          update the <tref>adjacent serialized labels map</tref> where the key is
          the value in the <tref>serialization map</tref> and the value is the
          <tref>target node label</tref>.</li>
        <li>Otherwise, add the <tref>target node label</tref> to the
          <tref>adjacent unserialized labels list</tref>.
      </ol>
    </li>
    <li>Set the <tdef>maximum serialization combinations</tdef> to
      <code>1</code> or the length of the
      <tref>adjacent unserialized labels list</tref>, whichever is greater.</li>
    <li>While the <tref>maximum serialization combinations</tref> is greater than
      <code>0</code>, perform the
      <a href="#combinatorial-serialization-algorithm">Combinatorial Serialization Algorithm</a>
      passing the <tref>node state</tref>, the <tref>mapping state</tref> for the
      first iteration and a copy of it for each subsequent iteration, the
      generated <tref>serialization label</tref>, the <tref>direction</tref>,
      the <tref>adjacent serialized labels map</tref>, and the
      <tref>adjacent unserialized labels list</tref>.
      Decrement the <tref>maximum serialization combinations</tref> by
      <code>1</code> for each iteration.
    </ol>
  </section> -->

  <!-- <section>
    <h4>Serialization Label Generation Algorithm</h4>

    <p class="issue">This algorithm is out-of-date, don't implement it.</p>

    <p>
    The algorithm generates a <tref>serialization label</tref> given a
    <tref>label</tref> and a <tref>mapping state</tref> and returns the
    <tref>serialization label</tref>.
    </p>

    <ol class="algorithm">
      <li>If the <tref>label</tref> is already in the
        <tref>serialization labels map</tref>, return its associated value.
      </li>
      <li>If the <tref>label</tref> starts with the string <code>_:c14n</code>,
        the <tref>serialization label</tref> is the letter <code>c</code>
        followed by the number that follows <code>_:c14n</code> in the
        <tref>label</tref>.
      </li>
      <li>Otherwise, the <tref>serialization label</tref> is the
        letter <code>s</code> followed by the string value of
        <tref>mapping counter</tref>. Increment the <tref>mapping counter</tref> by
        <code>1</code>.
      </li>
      <li>Create a new key-value pair in the <tref>serialization labels map</tref>
        where the key is the <tref>label</tref> and the value is the
        generated <tref>serialization label</tref>.
      </li>
    </ol>
  </section> -->
</section>

<section class="appendix">
  <h1>Acknowledgements</h1>

  <p>The editors would like to thank Jeremy Carroll for his work on the
    graph normalization problem, Gavin Carothers for providing valuable
    feedback and testing input for the algorithm defined in this
    specification, Sir Tim Berners Lee for his thoughts on graph normalization
    over the years, and Jes√∫s Arias Fisteus for his work on a similar
    algorithm. Finally, a huge thank you goes out to Dave Longley who designed
    and implemented the algorithms used in this specification, which turned out
    to be a monumentally difficult design challenge.</p>
</section>

</body>
</html>
