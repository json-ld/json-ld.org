<!DOCTYPE html>
<html>
<head>
<title>JSON-LD Syntax 1.0</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<!--
  === NOTA BENE ===
  For the three scripts below, if your spec resides on dev.w3 you can check them
  out in the same tree and use relative links so that they'll work offline,
  -->
<script type="text/javascript" src="../respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
    var preProc = {
          apply:  function(c) {
                    // extend the bibliography entries
                    berjon.biblio["MICRODATA"] = "<cite><a href=\"http://www.w3.org/TR/2012/WD-microdata-20120329/\">HTML Microdata</a></cite> Ian Hickson Editor. World Wide Web Consortium (work in progress). 29 March 2012. This edition of the HTML Microdata specification is http://www.w3.org/TR/2012/WD-microdata-20120329/. The <a href=\"http://www.w3.org/TR/microdata/\">latest edition of HTML Microdata</a> is available at http://www.w3.org/TR/microdata/";
                    berjon.biblio["JSON-LD-API"] = "<cite><a href=\"http://json-ld.org/spec/ED/json-ld-api/20120524/\">The JSON-LD API 1.0</a></cite> Manu Sporny, Gregg Kellogg, Dave Longley, Markus Lanthaler, Editors. World Wide Web Consortium (work in progress). 24 May 2012. Editor's Draft. This edition of the JSON-LD Syntax specification is http://json-ld.org/spec/ED/json-ld-api/20120524/. The <a href=\"http://json-ld.org/spec/latest/json-ld-api/\">latest edition of the JSON-LD Syntax</a> is available at http://json-ld.org/spec/latest/json-ld-api/";
                    berjon.biblio["RDF-CONCEPTS"] = "<cite><a href=\"http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/\">RDF 1.1 Concepts and Abstract Syntax</a></cite> Richard Cyganiak, David Wood, Editors. World Wide Web Consortium (work in progress). 30 May 2012. Editor's Draft. This edition of the JSON-LD Syntax specification is http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/. The <a href=\"http://www.w3.org/TR/rdf11-concepts/\">latest edition of the JSON-LD Syntax</a> is available at http://www.w3.org/TR/rdf11-concepts/";
                    berjon.biblio["TURTLE-TR"] = "Eric Prud'hommeaux, Gavin Carothers. <cite><a href=\"http://www.w3.org/TR/2011/WD-turtle-20110809/\">Turtle: Terse RDF Triple Language.</a></cite> 09 August 2011. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/2011/WD-turtle-20110809/\">http://www.w3.org/TR/2011/WD-turtle-20110809/</a>";
                    berjon.biblio["RFC5988"] = "<cite><a href=\"http://tools.ietf.org/rfc/rfc5988\">Web Linking</a></cite> M. Nottingham. Editor. October 2010. IETF Standard. URL: <a href=\"http://tools.ietf.org/rfc/rfc5988.txt\">http://tools.ietf.org/rfc/rfc5988.txt</a>";

                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local type references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'type';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // external type references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\n/g, '_') ;
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    var tdefs = [];
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( tdefs[ref]) {
                          throw "Duplicate definition of term '" + ref + "'" ;
                        }

                        var sp = document.createElement( 'dfn' ) ;
                        tdefs[ref] = sp ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( !tdefs[ref]) {
                          throw "Reference to undefined term '" + ref + "'" ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;


      var respecConfig = {
          doRDFa: "1.1",
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          // if you wish the publication date to be other than today, set this
          //publishDate:          "2012-08-30",
          copyrightStart:       "2010",

          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "json-ld-syntax",
          subtitle:             "A Context-based JSON Serialization for Linking Data",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2012-08-30",
          previousMaturity:     "FPWD",
          previousDiffURI:      "http://www.w3.org/TR/2012/WD-json-ld-syntax-20120830/",
          diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://dvcs.w3.org/hg/json-ld/raw-file/default/spec/latest/json-ld-syntax/index.html",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          issueBase: "https://github.com/json-ld/json-ld.org/issues/",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          // extraCSS:             [],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", url: "http://manu.sporny.org/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
              { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
                company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
          ],

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.
          authors:  [
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Dave Longley", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
              { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
                company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" },
              { name: "Mark Birbeck", url: "http://webbackplane.com/",
                company: "Backplane Ltd.", companyURL: "http://webbackplane.com/" }
          ],

          // name of the WG
          wg:           "RDF Working Group",

          // URI of the public WG page
          wgURI:        "http://www.w3.org/2011/rdf-wg/",

          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-rdf-comments",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/46168/status",
          maxTocLevel: 4,
          preProcess: [ preProc ]
          //alternateFormats: [ {uri: "diff-20120626.html", label: "diff to previous version"} ],
      };

      function _esc(s) {
          s = s.replace(/&/g,'&amp;');
          s = s.replace(/>/g,'&gt;');
          s = s.replace(/"/g,'&quot;');
          s = s.replace(/</g,'&lt;');
          return s;
      }

      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = _esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="diff">$1</span>') ;
        return content ;
      }
//]]>
  </script>
<style type="text/css">
.diff { font-weight:bold; color:#0a3; }
.issue.resolved { display: none; }
</style>
</head>

<body>
<section id="abstract">
<p>
JSON has proven to be a highly useful object serialization and messaging format.
In an attempt to harmonize the representation of <tref>Linked Data</tref>
in JSON, this specification outlines a common JSON representation format for
expressing directed graphs; mixing both Linked Data and non-Linked Data in
a single document.
</p>
</section>

<section id='sotd'>
<p>This document has been under development for over 18 months in the
JSON for Linking Data Community Group. The document has recently been
transferred to the RDF Working Group for review, improvement, and publication
along the Recommendation track. The specification has undergone significant
development, review, and changes during the course of the last 18 months.
</p>
<p>
There are currently
<a href="http://json-ld.org/#impl">five interoperable implementations</a>
of this specification. There is
a <a href="https://github.com/json-ld/json-ld.org/tree/master/test-suite">fairly complete test suite</a>
and a
<a href="http://json-ld.org/playground/">live JSON-LD editor</a>
that is capable of demonstrating the features described in
this document. While development on implementations, the test suite
and the live editor will continue, they are believed to be mature enough
to be integrated into a non-production system at this point in time with
the expectation that they could be used in a production system within the
next year.
</p>

<p>There are a number of ways that one may participate in the development of
this specification:</p>

<ul>
  <li>If you want to make sure that your feedback is formally addressed by
    the RDF Working Group, you should send it to public-rdf-comments:
    <a href="http://lists.w3.org/Archives/Public/public-rdf-comments/">public-rdf-comments@w3.org</a></li>

  <li>Ad-hoc technical discussion primarily occurs on the public community mailing list:
    <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

  <li><a href="http://json-ld.org/minutes/">Public JSON-LD Community Group teleconferences</a>
  are held on Tuesdays at 1500UTC every week.</li>

  <li>RDF Working Group teleconferences are held on Wednesdays at 1500UTC
  every week. Participation is limited to RDF Working Group members.</li>

  <li>Specification bugs and issues should be reported in the
    <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>
    if you do not want to send an e-mail to the public-rdf-comments mailing
    list.</li>

  <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a>
    for the specification can be found on Github.</li>

  <li>The <a href="http://webchat.freenode.net/?channels=json-ld">#json-ld</a>
    IRC channel is available for real-time discussion on irc.freenode.net.</li>
</ul>

</section>

<section class="informative">
<h1>Introduction</h1>

<p>
JSON, as specified in [[!RFC4627]], is a simple language for representing
data on the Web. <tref>Linked Data</tref> is a technique for creating a network
of inter-connected data across different Web documents and Web sites.
A <em>document</em> in this data network is typically identified using an
<tref>IRI</tref> (Internationalized Resource Identifier). A software program
can typically follow an IRI just like you follow a URL by putting it into your
browser's location bar. By following IRIs, a software program can find
more information about the <em>document</em> and the <em>thing</em>s that
the document describes.
These <em>things</em> may also be identified using <tref>IRI</tref>s. The
<tref>IRI</tref> allows a software program to start at one
<em>document</em> and follow links to other
<em>documents</em> or <em>things</em> in order to learn more about all of
the <em>documents</em> and <em>things</em> described on the Web.
</p>

<p>
JSON-LD is designed as a lightweight syntax that can be used to express
<tref>Linked Data</tref>. It is primarily intended to be a way to use Linked Data
in Javascript and other Web-based programming environments. It is also
useful when building inter-operable Web services and when storing Linked
Data in JSON-based document storage engines. It is practical and designed
to be as simple as possible, utilizing the large number of JSON parsers
and libraries available today.
</p>

<p>
The syntax does not necessarily require applications to change their JSON, but
allows one to easily add meaning by simply adding or referencing a context.
The syntax is designed to not disturb already deployed systems
running on JSON, but provide a smooth upgrade path from JSON to JSON-LD.
Finally, the format is intended to be easy to parse, efficient
to generate, and only requires a very small memory footprint in order to
operate.
</p>

<section>
<h2>How to Read this Document</h2>

<p>
This document is a detailed specification for a serialization of Linked
Data in JSON. The document is primarily intended for the following audiences:
</p>

<ul>
  <li>Software developers that want to encode Linked Data in a way that is
  cross-language compatible via JSON.</li>
  <li>Software developers that want to understand the design decisions and
  language syntax for JSON-LD.</li>
  <li>Software developers that want to implement processors and APIs for
  JSON-LD.</li>
</ul>

<p>This specification does not describe the programming interfaces for the
JSON-LD Syntax. The specification that describes the programming interfaces
for JSON-LD documents is the JSON-LD Application Programming Interface
[[JSON-LD-API]].</p>

<p>
To understand the basics in this specification you must first be familiar with
JSON, which is detailed in [[!RFC4627]].</p>

</section>

<section>
  <h3>General Terminology</h3>

  <p>The following is an explanation of the general terminology used in this document:</p>

  <dl>
    <dt><tdef>JSON object</tdef></dt><dd>
      An object structure is represented as a pair of curly brackets
      surrounding zero or more name-value pairs. A name is a
      <tref>string</tref>. A single colon comes after each name, separating the
      name from the value. A single comma separates a value from a following
      name. The names within an object SHOULD be unique.
    </dd>
    <dt><tdef>array</tdef></dt>
    <dd>
      In JSON, an array is an <em>ordered</em> sequence of zero or more values.
      An array is represented as square brackets surrounding
      zero or more values that are separated by commas.
      While JSON-LD uses the same array representation as JSON,
      the collection is <em>unordered</em> by default. While order is
      preserved in regular JSON arrays, it is not in regular JSON-LD arrays
      unless specific markup is provided
      (see <a href="#sets-and-lists"></a>).</dd>
    <dt><tdef>string</tdef></dt><dd>
      A string is a sequence of zero or more Unicode characters,
      wrapped in double quotes, using backslash escapes (if necessary). A
      character is represented as a single character string.</dd>
    <dt><tdef>number</tdef></dt>
    <dd>
      A number is similar to that used in most programming languages, except
      that the octal and hexadecimal formats are not used and that leading
      zeros are not allowed.</dd>
    <dt><tdef>true</tdef> and <tdef>false</tdef></dt><dd>
      Values that are used to express one of two possible boolean states.</dd>
    <dt><tdef>null</tdef></dt><dd>
      The null value is used to make the JSON-LD processor "forget" any
      previously defined JSON key that is associated with the null value.
      If a previous definition doesn't exist, the entire key-value is ignored.
      If a previous definition of the key does exist, the previous
      definition is undefined.</dd>
    <dt><tdef>node definition</tdef></dt><dd>
      A <tref>JSON object</tref> used to represent a <tref>node</tref> and
      one or more properties of that node. A <tref>JSON object</tref> is a
      node definition if it does not contain the keys <code>@value</code>,
      <code>@list</code> or <code>@set</code> and it has one or more keys other
      than <code>@id</code>. A node definition MAY be spread among different
      parts of a document or even between different documents.</dd>
    <dt><tdef>node reference</tdef></dt><dd>
      A <tref>JSON object</tref> used to reference a node having only the
      <code>@id</code> key.</dd>
  </dl>
</p>

</section>

</section>

<section class="informative">
<h1>Design Goals and Rationale</h1>

<p>A number of design goals were established before the creation of this
  markup language:</p>

<dl>
 <dt>Simplicity</dt>
 <dd>No extra
 processors or software libraries should be necessary to use JSON-LD in its most
 basic form. The language will provide developers with a very easy
 learning curve. Developers need only know JSON and two
 <tref title="keyword">keywords</tref> (<code>@context</code>
 and <code>@id</code>) to use the basic functionality in JSON-LD.</dd>
 <dt>Compatibility</dt>
 <dd>The JSON-LD markup must be 100% compatible with JSON. This ensures that
 all of the standard JSON libraries work seamlessly with JSON-LD documents.</dd>
 <dt>Expressiveness</dt>
 <dd>The syntax must be able to express directed graphs, which have been proven
 to be able to express almost every real world data model.</dd>
 <dt>Terseness</dt>
 <dd>The JSON-LD syntax must be very terse and human readable, requiring as
 little effort as possible from the developer.</dd>
 <!--<dt>Pragmatism</dt>
 <dd>Mixing the expression of pure Linked Data with data that is not
 linked was an approach that was driven by pragmatism. JSON-LD attempts to be
 more practical than theoretical in its approach to Linked Data.</dd>-->
 <dt>Zero Edits, most of the time</dt>
 <dd>JSON-LD must provide a
 <a href="#referencing-contexts-from-json-documents">mechanism</a>
 that allows developers to specify <tref>context</tref> in a way that is
 out-of-band.
 This allows organizations that have
 already deployed large JSON-based infrastructure to add meaning to their
 JSON documents in a way that is not disruptive to their day-to-day operations and is
 transparent to their current customers. At times, mapping JSON to
 a graph representation can become difficult. In these instances, rather than
 having JSON-LD support an esoteric use case, we chose not to support the
 use case and support a simplified syntax instead. So, while Zero Edits is
 a design goal, it is not always possible without adding great complexity to
 the language.
 </dd>
 <dt>One-pass Processing</dt>
 <dd>JSON-LD supports one-pass processing, which results in a very small memory
 footprint when processing documents. For example, to expand a JSON-LD document
 from a compacted form, only one pass is required over the data.</dd>
 <dt>Linked Data-centric</dt>
 <dd>The focus on Linked Data is placed at a much higher priority than the
 focus on the Semantic Web. One outcome of this ordering of
 priorities is an aggressively reduced focus on the Semantic Web stack
 (RDF [[RDF-CONCEPTS]], TURTLE [[TURTLE-TR]], triple stores, and
 SPARQL [[RDF-SPARQL-QUERY]]).
 While this may be off-putting to proponents of the Semantic Web, the audience
 for this specification are Web developers that want a gentler introduction
 and a simpler technology stack for using Linked Data in their Web applications.
 Semantic Web concepts, such as conversion to and from RDF, are fully supported
 by JSON-LD, but the implementation of these features are not elaborated upon
 in this specification. See <a href="#relationship-to-other-linked-data-formats-and-data-models"></a>
 for more information about how JSON-LD integrates into the more traditional
 Semantic Web stack.
 </dd>
</dl>
</section>

<section class="normative">
<h1>Basic Concepts</h1>

<em>This section is normative.</em>

<p>JSON-LD is designed to ensure that <tref>Linked Data</tref> concepts can be
marked up in a way that is simple to understand and create by Web authors.
In many cases, regular JSON markup can become Linked Data with the
simple addition of a <tref>context</tref>. As more JSON-LD features are
used, more semantics are added to the JSON markup.</p>

<section>
<h2>Linked Data</h2>

<p>
The following definition for <tref>Linked Data</tref> is the one that will
be used for this specification.
</p>
<ol>
  <li><tdef>Linked Data</tdef> is a set of documents, each containing a representation of a <tref>linked data graph</tref>.</li>
  <li>A <tdef>linked data graph</tdef> is an unordered labeled directed graph, where <tdef title="node">nodes</tdef> are <tref title="IRI">IRIs</tref> or <tref title="Blank Node">Blank Nodes</tref>, or other values.</li>
  <li>A <tref>node</tref> having an outgoing edge MUST be an <tref>IRI</tref> or <tref>Blank Node</tref>.</li>
  <li>A <tref>node</tref> having an incoming edge MUST be an <tref>IRI</tref>, <tref>Blank Node</tref>, or value such as a number or string.</li>
  <li>A <tref>node</tref> MAY have both incoming and outgoing edges.</li>
  <li>An edge MUST be labeled with an <tref>absolute IRI</tref>, within the JSON-LD syntax, this label is called a <tdef>property</tdef>.</li>
  <li><tref title="IRI">IRIs</tref> used within a <tref>linked data graph</tref> SHOULD be dereferenceable to a <tref>Linked Data</tref> document describing the resource denoted by that <tref>IRI</tref>.</li>
</ol>

<div class="note">
  <p>A <tref>Linked Data</tref> document does not necessarily need to be expressed in JSON-LD. The notion of
    <tref>Linked Data</tref> is a concept independent of any given serialization format. In particular, any document based on
    an RDF serialization format is a <tref>Linked Data</tref> document.</p>

  <p>This definition of <tref>Linked Data</tref> is entirely consistent with that in [[RDF-CONCEPTS]], although
    <tref>Linked Data</tref> may not be a valid RDF document, any RDF document is an expression of <tref>Linked Data</tref>.</p>
</div>

<p class="issue">An illustration of a linked data graph would probably help here.</p>

<div class="issue" data-number="47">
  <p>Richard Cyganiak suggests that the data model is at odds with [[RDF-CONCEPTS]] and should
    be more closely aligned with it instead of creating new terminology.</p>
  <p>Note that this definition is provisional, and may be reverted to something closer to the original depending on community feedback.</p>
  <ol>
    <li><tref>Linked Data</tref> is a set of documents, each containing a representation of a <tref>linked data graph</tref>.</li>
    <li>A <tref>linked data graph</tref> is an unordered labeled directed graph, where nodes are <em>subject</em>s or <em>object</em>s, and edges are labeled using <tref title="property">properties</tref>.</li>
    <li>A <em>subject</em> is any node in a <tref>linked data graph</tref> with at least one outgoing edge.</li>
    <li>A <em>subject</em> SHOULD be labeled with an <tref><abbr title="Internationalized Resource Identifier">IRI</abbr></tref> (an Internationalized Resource Identifier as described in [[!RFC3987]]).</li>
    <li>An <em>object</em> is a node in a <tref>linked data graph</tref> with at least one incoming edge.</li>
    <li>An <em>object</em> MAY be labeled with an <tref>IRI</tref> or a label that is not an <tref>IRI</tref> such as plain text, internationalized text, or a strictly-typed data value.</li>
    <li>A node MAY be a <em>subject</em> and an <em>object</em> at the same time.</li>
    <li>A <tref>property</tref> is the label on an edge in a
      <tref>linked data graph</tref>.</li>
    <li>A <tref>property</tref> SHOULD be an <tref>IRI</tref>.</li>
    <li>An <tref>IRI</tref> that is a label in a <tref>linked data graph</tref> SHOULD be dereferencable to a <tref>Linked Data</tref> document describing the labeled <em>subject</em>, <tref>property</tref> or <em>object</em>.</li>
  </ol>
</div>

<p class="note">JSON-LD allows properties to be BNodes, while RDF does
  not. When used as just JSON-LD, this is not unreasonable;
  it only becomes an issue (and could raise an exception) when
  transformed to RDF.</p>

<p>Note that the definition for <tref>Linked Data</tref> above is silent on the
topic of <tref title="unlabeled node">unlabeled nodes</tref>. Nevertheless, this specification allows for the expression
of <tref title="unlabeled node">unlabeled nodes</tref>, as most graph-based data sets on the Web contain a number
of associated nodes that are not named and thus are not directly
de-referenceable.
</p>

<p>JSON-LD defines a mechanism to map JSON terms, i.e., keys and values, to IRIs. This does not mean
that JSON-LD requires every key or value to be an IRI, but rather ensures that
keys and values can be mapped to IRIs if the developer desires to transform
their data into <tref>Linked Data</tref>. There are a few techniques that can ensure
that developers will generate good Linked Data for the Web. JSON-LD
formalizes those techniques.
</p>

<p>We will be using the following JSON markup as the example for the
rest of this section:
</p>

<pre class="example" data-transform="updateExample"
     title="Sample JSON object">
<!--
{
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>

</section>

<section>
<h2>Syntax Tokens and Keywords</h2>

<p>JSON-LD specifies a number of syntax tokens and <tdef title="keyword">keywords</tdef>
that are a core part of the language:</p>

<dl>
<dt><code>@context</code></dt>
<dd>Used to define the short-hand names that are used throughout a JSON-LD
  document. These short-hand names are called <tref>term</tref>s and help
  developers to express specific identifiers in a compact manner. The
  <code>@context</code> keyword is described in detail in the section titled
  <a href="#the-context"></a>.</dd>
<dt><code>@graph</code></dt><dd>Used to explicitly label a <tref>linked data graph</tref>.
  This keyword is described in <a href="#named-graphs"></a>.</dd>
<dt><code>@id</code></dt>
<dd>Used to uniquely identify <em>things</em> that are being described in the document.
  This keyword is described in <a href="#node-identifiers"></a>.</dd>
<dt><code>@value</code></dt>
<dd>Used to specify the data that is associated with a particular
  <tref>property</tref> in the graph. This keyword is described in
  <a href="#string-internationalization"></a> and
  <a href="#typed-values"></a>.</dd>
<dt><code>@language</code></dt>
<dd>Used to specify the native language for a particular value or the default
  language of a JSON-LD document. This keyword is described in the section titled
  <a href="#string-internationalization"></a>.</dd>
<dt><code>@type</code></dt>
<dd>Used to set the data type of a <tref>node</tref> or
  <tref>typed value</tref>. This keyword is described in the section titled
  <a href="#typed-values"></a>.</dd>
<dt><code>@container</code></dt>
<dd>Used to set the container of a particular value.
  This keyword is described in the section titled <a href="#sets-and-lists"></a>.</dd>
<dt><code>@list</code></dt>
<dd>Used to express an ordered set of data.
  This keyword is described in the section titled <a href="#sets-and-lists"></a>.</dd>
<dt><code>@set</code></dt>
<dd>Used to express an unordered set of data.
  This keyword is described in the section titled <a href="#sets-and-lists"></a>.</dd>
<dt><code>@vocab</code></dt>
<dd>Used to set the base <tref>IRI</tref> for all property IRIs affected by the
  <tref>active context</tref>. This keyword is described in section <a href="#iris"></a>.</dd>
<dt><code>:</code></dt>
<dd>The separator for JSON keys and values that use
  <tref title="compact_iri">compact IRIs</tref>.</dd>
</dl>

<p>For the avoidance of doubt, all keys, <tref title="keyword">keywords</tref>, and values in JSON-LD are
case-sensitive.</p>
</section>

<section>
<h2>The Context</h2>

<p>In JSON-LD, a <tdef>context</tdef> is used to map <tref>term</tref>s, i.e., properties with associated
  values in an JSON document, to <tref>IRI</tref>s. A <tdef>term</tdef> is a short word that expands to an
  <tref>IRI</tref>. <tref>Term</tref>s MAY be defined as any valid JSON <tref>string</tref> other
  than a JSON-LD <tref>keyword</tref>. To avoid
  forward-compatibility issues, <tref>term</tref>s starting with an <code>@</code> character SHOULD NOT be used
  as they might be used as <tref title="keyword">keywords</tref> in future versions of JSON-LD. Furthermore,
  the use of empty terms (<code>""</code>) is discouraged as not all programming languages are able to handle
  empty property names.</p>
<p>The Web uses <tref title="IRI">IRIs</tref> for unambiguous identification. The
  idea is that these <tref>term</tref>s mean something that may be of use to other developers and that it is useful to
  give them an unambiguous identifier. That is, it is useful for <tref>term</tref>s to expand to IRIs so that
  developers don't accidentally step on each other's <tdef>vocabulary</tdef> terms and other resources. Furthermore, developers, and
  machines, are able to use this <tref>IRI</tref> (by plugging it directly into a web browser, for instance) to go to
  the term and get a definition of what the term means. This mechanism is analogous to the way we can use
  <a href="http://wordnet.princeton.edu/">WordNet</a> today to see the definition of words in the English language.
  Developers and machines need the same sort of definition of terms. <tref title="IRI">IRIs</tref> provide a way to
  ensure that these terms are unambiguous. For example, the term <code>name</code> may
  map directly to the IRI <code>http://xmlns.com/foaf/0.1/name</code>. This allows JSON-LD documents to be constructed
  using the common JSON practice of simple name/value pairs while ensuring that the data is useful outside of the
  page, API or database in which it resides. The value of a term mapping
  MUST be either; 1) a simple string with the lexical form of an <tref>absolute IRI</tref> or
  2) <tref>compact IRI</tref>, or 3) an <tref>JSON object</tref> containing an
  <code>@id</code>, <code>@type</code>, <code>@language</code>, or <code>@container</code> keyword
  (all other keywords are ignored by a JSON-LD processor).
</p>

<p>These Linked Data <tref>term</tref>s are typically collected in a
context document that would look something like this:</p>

<pre class="example" data-transform="updateExample"
     title="Context definition">
<!--
{
  "@context":
  {
    "name": "http://xmlns.com/foaf/0.1/name",
    "depiction":
    {
      "@id": "http://xmlns.com/foaf/0.1/depiction",
      "@type": "@id"
    },
    "homepage":
    {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    },
  }
}
-->
</pre>

<p>Assuming that this context document can be retrieved at <code>http://json-ld.org/contexts/person.jsonld</code>,
  it can be referenced from a JSON-LD document by adding a single line. The JSON markup shown in the previous
  section could be changed as follows:</p>

<pre class="example" data-transform="updateExample"
     title="Adding context reference to JSON document">
<!--
{
  ****"@context": "http://json-ld.org/contexts/person.jsonld",****
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>

<p>The additions above transform the previous JSON document into a JSON document
with added semantics because the <code>@context</code> specifies how the
<strong>name</strong>, <strong>homepage</strong>, and <strong>depiction</strong>
terms map to <tref title="IRI">IRIs</tref>.
Mapping those keys to IRIs gives the data global context. If two
developers use the same IRI to describe a property, they are more than likely
expressing the same concept. This allows both developers to re-use each others'
data without having to agree to how their data will interoperate on a
site-by-site basis. Contexts may also contain type information
for certain <tref>term</tref>s as well as other processing instructions for
the JSON-LD processor.</p>

<p class="note">External JSON-LD context documents MAY contain extra information
located outside of the <code>@context</code> key, such as documentation about the
<tref title="term">terms</tref> declared in the document. When importing a
<code>@context</code> value from an external JSON-LD context document, any extra
information contained outside of the <code>@context</code> value MUST be discarded.</p>

<p>Contexts MAY be specified in-line. This ensures that JSON-LD documents
can be processed when a JSON-LD processor does not have access to the Web.</p>

<pre class="example" data-transform="updateExample"
     title="In-line context definition">
<!--
{
  ****"@context":
  {
    "name": "http://xmlns.com/foaf/0.1/name",
    "depiction":
    {
      "@id": "http://xmlns.com/foaf/0.1/depiction",
      "@type": "@id"
    },
    "homepage":
    {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    },
  },****
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>

<p>Contexts MAY be used at any time a <tref>node definition</tref> is defined.
  A <tref>node definition</tref> MAY specify multiple contexts, using an
  <tref>array</tref>, which is processed in order. This is useful
  when an author would like to use an existing context and add
  application-specific terms to the existing context. Duplicate context
  <tref>term</tref>s MUST be overridden using a last-defined-overrides
  mechanism.</p>

<pre class="example" data-transform="updateExample"
     title="Scoped contexts within node definitions">
<!--
{
  ****"@context":
  {
    "name": "http://example.com/person#name",
    "details": "http://example.com/person#details"
  },****
  "****name****": "Markus Lanthaler",
  ...
  "details":
  {
    ****"@context": {
      "name": "http://example.com/organization#name"
    },****
    "****name****": "Graz University of Technology"
  }
}
-->
</pre>

<p>In the example above, the <code>name</code> prefix is overridden in the
  more deeply nested <code>details</code> structure. Note that this is
  rarely a good authoring practice and is typically used when there exist
  legacy applications that depend on the specific structure of the
  <tref>JSON object</tref>.</p>

<p class="note">If a <tref>term</tref> is re-defined within a context, all previous
  rules associated with the previous definition are removed. A <tref>term</tref> defined
  in a previous context MUST be removed, if it is re-defined to <code>null</code>.</p>

<p>The set of contexts defined within a specific <tref>node definition</tref> are
  referred to as <tdef>local context</tdef>s. Setting the context to <code>null</code>
  effectively resets the <tref>active context</tref> to an empty context. The
  <tdef>active context</tdef> refers to the accumulation of <tref>local context</tref>s
  that are in scope at a specific point within the document. The following example
  specifies an external context and then layers a local context on top of the external
  context:</p>

<pre class="example" data-transform="updateExample"
     title="Combining external and local contexts">
<!--
{
  ****"@context": [
    "http://json-ld.org/contexts/person.jsonld",
    {
      "pic": "http://xmlns.com/foaf/0.1/depiction"
    }
  ],****
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  ****"pic": "http://twitter.com/account/profile_image/manusporny"****
}
-->
</pre>

<p class="note">To ensure the best possible performance, it is a best practice to
  put the <tref>context</tref> definition at the top of the JSON-LD document. If it isn't listed
  first, processors have to save each key-value pair until the <tref>context</tref> is processed.
  This creates a memory and complexity burden for certain types of
  low-memory footprint JSON-LD processors.</p>

<p class="note">The <code>null</code> value is processed in a special way
  in JSON-LD. Unless otherwise specified, a JSON-LD processor MUST act as if a
  key-value pair in the body of a JSON-LD document was never declared when
  the value equals <em>null</em>. If <code>@value</code>, <code>@list</code>,
  or <code>@set</code> is set to <em>null</em> in expanded form, then the
  entire <tref>JSON object</tref> is ignored. If <code>@context</code> is set
  to <em>null</em>, the <tref>active context</tref> is reset and when used
  within a <tref>context</tref>, it removes any definition associated with
  the key, unless otherwise specified.</p>

</section>

<section>
<h2>From JSON to JSON-LD</h2>

<p>If a set of <tref>term</tref>s such as, <strong>name</strong>,
<strong>homepage</strong>, and <strong>depiction</strong>,
are defined in a <tref>context</tref>, and that context is used to resolve the
names in <tref title="JSON object">JSON objects</tref>, machines are able to automatically expand the terms to
something meaningful and unambiguous, like this:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded terms">
<!--
{
  "****http://xmlns.com/foaf/0.1/name****": "Manu Sporny",
  "****http://xmlns.com/foaf/0.1/homepage****": "http://manu.sporny.org"
  "****http://xmlns.com/foaf/0.1/depiction****": "http://twitter.com/account/profile_image/manusporny"
}
 -->
</pre>

<p>Doing this allows JSON to be unambiguously machine-readable without
requiring developers to drastically change their workflow.</p>

<p class="note">The example above does not use the <code>@id</code> <tref>keyword</tref>
to identify the node being described above. This type of node is called an
<tref>unlabeled node</tref>. It is advised that all nodes described in JSON-LD are
given unique identifiers via the <code>@id</code> keyword unless the data is not
intended to be linked to from other data sets.</p>

<p>A <tref>JSON object</tref> used to define property values is called a
  <tref>node definition</tref>. <tref title="node definition">Node definitions</tref>
  do not require an <code>@id</code>.
  <tref title="node definition">Node definitions</tref> that do not
  contain an <code>@id</code> are known as an <tref title="unlabeled node">unlabeled nodes</tref>.</p>

</section>

<section>
<h2>IRIs</h2>

<p><tref title="IRI">IRIs</tref> are fundamental to <tref>Linked Data</tref>
as that is how most <tref title="node">nodes</tref>s and all
<tref title="property">properties</tref> are
identified. <tref>IRI</tref>s can be expressed in a variety of different ways
in JSON-LD.</p>

<p>An <tdef><abbr title="Internationalized Resource Identifier">IRI</abbr></tdef>
  (an Internationalized Resource Identifier) is described in [[!RFC3987]])
  and the use with JSON-LD conforms to the definition of
  <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri">IRI</a></cite> in [[!RDF-CONCEPTS]].</p>

<ol>
  <li>Except within a <tref>context</tref> definition, <tref>term</tref>s in the key position in
    a <tref>JSON object</tref> that have a mapping or a vocabulary base <tref>IRI</tref> in the
    <tref>active context</tref> are expanded to an <tref>IRI</tref> by JSON-LD processors.</li>
  <li>An <tref>IRI</tref> is generated for the <tref>string</tref> value specified using
    <code>@id</code> or <code>@type</code>.</li>
  <li>An <tref>IRI</tref> is generated for the <tref>string</tref> value of any key for which there
    are <tref>coercion</tref> rules in effect that identify the value as an <code>@id</code>.</li>
</ol>

<p>IRIs may be represented as an <tref>absolute IRI</tref>, a <tref>relative IRI</tref>, a <tref>term</tref>,
  a <tref>compact IRI</tref>, or as a value relative to <code>@vocab</code>.</p>

<p>An <tdef>absolute IRI</tdef> is defined in [[!RFC3987]] containing a <em>scheme</em> along with
  <em>path</em> and optional <em>query</em> and <em>fragment</em> segments. A <tdef>relative IRI</tdef> is an IRI
  that is relative to some other <tref>absolute IRI</tref>. In JSON-LD all <tref>relative IRI</tref>s are resolved relative to the
  <tdef>base IRI</tdef> associated with the document (typically, the directory that contains the document or the document itself).</p>

<p>IRIs can be expressed directly in the key position like so:</p>

<pre class="example" data-transform="updateExample"
     title="IRI as a key">
<!--
{
...
  "****http://xmlns.com/foaf/0.1/name****": "Manu Sporny",
...
}
-->
</pre>

<p>In the example above, the key <code>http://xmlns.com/foaf/0.1/name</code> is interpreted
  as an <tref>IRI</tref> because it contains a colon
  (<code>:</code>) and the 'http' <tref>prefix</tref> does not exist in
  the context.</p>

<p>Term expansion occurs for IRIs if the value matches a <tref>term</tref> defined within the
<tref>active context</tref>:</p>

<pre class="example" data-transform="updateExample"
     title="Term expansion from context definition">
<!--
{
  "****@context****":
  {
    "****name****": "****http://xmlns.com/foaf/0.1/name****"
...
  },
  "****name****": "Manu Sporny",
  "status": "trollin'",
...
}
-->
</pre>

<p><tref>Term</tref>s are case sensitive, and MUST be matched using a case-sensitive comparison.</p>

<p>JSON keys that do not expand to an absolute IRI are ignored, or removed
in some cases, by the [[JSON-LD-API]]. However, JSON keys that do not include
a mapping in the <tref>context</tref> are still considered valid expressions
in JSON-LD documents - the keys just don't have any machine-readable,
semantic meaning.</p>

<p><tref>Prefix</tref>es are expanded when the form of the value is a
  <tref>compact IRI</tref> represented as a <code>prefix:suffix</code>
  combination, and the prefix matches a <tref>term</tref> defined within the
  <tref>active context</tref>:</p>

<pre class="example" data-transform="updateExample"
     title="Prefix expansion">
<!--
{
  "****@context****":
  {
    "****foaf****": "****http://xmlns.com/foaf/0.1/****"
...
  },
  "****foaf:name****": "Manu Sporny",
...
}
-->
</pre>

<p><code>foaf:name</code> above will automatically expand out to the IRI
<code>http://xmlns.com/foaf/0.1/name</code>. See <a href="#compact-iris"></a> for more details.</p>

<p>If the <code>@vocab</code> is set, all keys that do not match a <tref>term</tref> or a <tref>prefix</tref>
  are


It is often common that all types and properties come from the same vocabulary. JSON-LD's
<code>@vocab</code> keyword allows to set a base <tref>IRI</tref> to be used for all properties and types
that that do not match a <tref>term</tref>, a <tref>prefix</tref>, or an <tref>absolute IRI</tref>
(i.e., do not contain a colon). The <code>@vocab</code> mapping MUST have a value of a simple string with the
lexical form of an absolute IRI.</p>

<pre class="example" data-transform="updateExample"
     title="Vocabulary base IRI">
<!--
{
  ****"@context": {
    "@vocab": "http://xmlns.com/foaf/1.0/"
  },****
  "@type": ****"Person"****,
  ****"name"****: "Manu Sporny",
}
-->
</pre>

<p>An <tref>IRI</tref> is generated when a <tref>JSON object</tref> is used in the
  value position that contains an <code>@id</code> keyword:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded IRI definition">
<!--
{
...
  "homepage": { "****@id****": "http://manu.sporny.org" }
...
}
-->
</pre>

<p class="note">Specifying a <tref>JSON object</tref> with an
  <code>@id</code> key is used to identify that <tref>node</tref> using an
  <tref>IRI</tref>. When the object has only the <code>@id</code>, it
  is called a <tref>node reference</tref>.
  This facility MAY also be used to link to another
  <tref>node definition</tref> using a mechanism called
  <tref>embedding</tref>, which is covered in the section titled
  <a href="#embedding"></a>.</p>

<p>If type <tref>coercion</tref> rules are specified in the <code>@context</code> for
a particular <tref>term</tref> or property IRI, an IRI is generated:</p>

<pre class="example" data-transform="updateExample"
     title="Type coercion">
<!--
{****
  "@context":
  {
    ...
    "homepage":
    {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
    ...
  }****
...
  "homepage": "http://manu.sporny.org/",
...
}
-->
</pre>

<p>In the example above, even though the value
<code>http://manu.sporny.org/</code> is expressed as a JSON
<tref>string</tref>, the type <tref>coercion</tref> rules will transform
the value into an IRI when processed by a JSON-LD Processor.</p>

</section>

<section>
<h2>Node Identifiers</h2>

<p>To be able to externally reference nodes in a graph, it is important that each node has
  an unambiguous identifier. <tref>IRI</tref>s are a fundamental concept of
  <tref>Linked Data</tref>, and nodes should have a de-referencable
  identifier used to name and locate them. For nodes to be truly linked,
  de-referencing the identifier should result in a representation of that node
  (for example, using a URL to retrieve a web page).
  Associating an IRI with a node tells an application that the returned
  document contains a description of the node requested.</p>

<p>JSON-LD documents may also contain descriptions of other nodes, so it is necessary to be able to
  uniquely identify each node which may be externally referenced.</p>

<p>The node of a <tref>JSON object</tref> is identified using the <code>@id</code>
  <tref>keyword</tref>:</p>

<pre class="example" data-transform="updateExample"
     title="Identifying a node">
<!--
{
  "@context":
  {
    ...
    "homepage":
    {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
    ...
  },
  "****@id****": "****http://example.org/people#joebob****",
  "homepage": "http://manu.sporny.org/",
...
}
-->
</pre>

<p>The example above contains a node identified by the IRI
  <code>http://example.org/people#joebob</code>.</p>

<p>A <tref>JSON object</tref> used to define property values is called a
  <tref>node definition</tref>. <tref title="node definition">Node definitions</tref>
  do not require an <code>@id</code>. A <tref>node definition</tref>
  that does not contain an <code>@id</code> property defines properties of an
  <tref>unlabeled node</tref>. <tref title="node definition">Node definitions</tref> MAY
  be spread among different parts of a document or even between different documents.</p>

<p class="note">To ensure the best possible performance, when possible, it is a best practice
  to put JSON-LD <tref>keyword</tref>s, such as <code>@id</code> and
  <code>@context</code> before other key-value pairs in a <tref>JSON object</tref>.
  However, keys in a <tref>JSON object</tref> are not ordered,
  so processors MUST NOT depend on key ordering. If keywords are not listed
  first, processors have to save each key-value pair until at least the
  <code>@context</code> and the <code>@id</code> are processed. Not
  specifying those keywords first creates a memory and complexity burden for
  low-memory footprint processors, forcing them to use more memory and
  computing cycles than necessary.</p>


</section>

<section>
<h2>Specifying the Type</h2>

<p>The type of a particular node can be specified using the <code>@type</code>
  <tref>keyword</tref>. To be considered <tref>Linked Data</tref>, types MUST
  be uniquely identified by an <tref>IRI</tref>.</p>

<pre class="example" data-transform="updateExample"
     title="Specifying the type for a node">
<!--
{
...
  "@id": "http://example.org/people#joebob",
  "****@type****": "****http://xmlns.com/foaf/0.1/Person****",
...
}
-->
</pre>

<p>A node can be assigned more than one type by using the following markup
pattern:</p>

<pre class="example" data-transform="updateExample"
     title="Specifying multiple types for a node">
<!--
{
...
  "@id": "http://example.org/places#BrewEats",
  "****@type****": ****["http://schema.org/Restaurant", "http://schema.org/Brewery"]****
...
}
-->
</pre>


</section>

<section>
<h2>String Internationalization</h2>

<p>At times, it is important to annotate a <tref>string</tref>
  with its language. In JSON-LD this is possible in a variety of ways.
  Firstly, it is possible to define a default language for a JSON-LD document
  by setting the <code>@language</code> key in the <code>@context</code> or in a
  <tref>term</tref> definition:</p>

<pre class="example" data-transform="updateExample"
     title="String Internationalization">
<!--
{
  ****"@context":
  {
    ...
    "@language": "ja"
  },****
  "name": ****"花澄"****,
  "occupation": ****"科学者"****
}
-->
</pre>

<p>The example above would associate the <code>ja</code> language
  code with the two <tref>string</tref>s <em>花澄</em> and <em>科学者</em>.
  Languages MUST be well-formed language tags according to [[!BCP47]].</p>

<p>It is possible to override the default language by using the expanded
form of a value:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded value with language">
<!--
{
  "@context": {
    ...
    "@language": "ja"
  },
  "name": "花澄",
  "occupation": ****{
    "@value": "Scientist",
    "@language": "en"
  }****
}
-->
</pre>

<p>It is also possible to override the default language or specify a plain
value by omitting the <code>@language</code> tag or setting it to
<code>null</code> when expressing the expanded value:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded value to remove language">
<!--
{
  "@context": {
    ...
    "@language": "ja"
  },
  "name": ****{
    "@value": "Frank"
  },****
  "occupation": **** {
    "@value": "Ninja",
    "@language": "en"
  }****,
  "speciality": "手裏剣"
}
-->
</pre>

<p class="note">Please note that language associations MUST only be applied
  to plain literal <tref>string</tref>s. That is, <tref>typed value</tref>s
  or values that are subject to <a href="#type-coercion"></a>
  won't be language tagged.</p>

<p>To clear the default language for a subtree, <code>@language</code> can
be set to <code>null</code> in a <tref>local context</tref> as follows:</p>

<pre class="example" data-transform="updateExample"
     title="Clearing default language">
<!--
{
  "@context": {
    ...
    "@language": "ja"
  },
  "name": "花澄",
  "details": {
****    "@context": {
      "@language": null
    },****
    "occupation": "Ninja"
  }
}
-->
</pre>

<p class="note">JSON-LD allows one to associate language information with
  <tref>term</tref>s.
  See <a href="#expanded-term-definition"></a> for
  more details.</p>

</section>

<section>
  <h2>JSON-LD Syntax</h2>

  <p>A JSON-LD document is first, and foremost, a JSON document
    (as defined in [[!RFC4627]]), and any syntactically correct JSON document
    MUST be processed by a conforming JSON-LD processor. However, JSON-LD
    describes a specific syntax to use for expressing Linked Data. This
    includes the use of specific keywords, as identified in <a
    href="#syntax-tokens-and-keywords"></a> for
    expressing <a title="node definition">node definitions</a>, values,
    and the <a>context</a>. See <a
    href="#json-ld-grammar"></a> for authoring
    guidelines and a BNF description of JSON-LD.</p>

</section>
</section>

<section>
<h1>Advanced Concepts</h1>

<em>This section is normative.</em>

<p>JSON-LD has a number of features that provide functionality above and beyond
the core functionality described above. The following section describes this
advanced functionality in more detail.
</p>

<section>
  <h2>Compact IRIs</h2>
  <p>
    <tref>Term</tref>s in <tref>Linked Data</tref> documents may draw from
    a number of different <tref title="vocabulary">vocabularies</tref>.
    At times, declaring every single <tref>term</tref> that a document uses can require the
    developer to declare tens, if not hundreds of potential
    <tref>vocabulary</tref> <tref>term</tref>s that are used across an
    application. This is a concern for at least two reasons: the
    first is the cognitive load on the developer of remembering all of the
    <tref>term</tref>s, and the second is the serialized size of the
    <tref>context</tref> if it is specified inline. In order to address these issues,
    the concept of a <tref>compact IRI</tref> is introduced.</p>
  <p>
    A <tdef>compact IRI</tdef> is a way of expressing an <tref>IRI</tref>
    using a <em>prefix</em> and <em>suffix</em> separated by a colon (<code>:</code>) which is
    similar to the <cite><a href="http://www.w3.org/TR/rdfa-core/#s_curies">CURIE Syntax</a></cite>
    in [[RDFA-CORE]]. The <tdef>prefix</tdef> is a <tref>term</tref> taken from the
    <tref>active context</tref> and is a short string identifying a
    particular <tref>IRI</tref> in a JSON-LD document.
    For example, the prefix <code>foaf</code> may be used as a short
    hand for the Friend-of-a-Friend vocabulary, which is identified using
    the IRI <code>http://xmlns.com/foaf/0.1/</code>. A developer may append
    any of the FOAF <tref>vocabulary</tref> terms to the end of the prefix
    to specify a short-hand version of the <tref>absolute IRI</tref> for the
    <tref>vocabulary</tref> term. For example, <code>foaf:name</code> would
    be expanded out to the IRI <code>http://xmlns.com/foaf/0.1/name</code>.
    Instead of having to remember and type out the entire IRI, the developer
    can instead use the prefix in their JSON-LD markup.
  </p>
  <p>Terms are interpreted as <tref>compact IRI</tref>s if they contain at least one
    colon and the first colon is not followed by two slashes (<code>//</code>, as in
    <code>http://example.com</code>). To generate the full <tref>IRI</tref>,
    the value is first split into a <em>prefix</em> and <em>suffix</em> at the first
    occurrence of a colon (<code>:</code>). If the <tref>active context</tref>
    contains a term mapping for <em>prefix</em>, an IRI is generated by
    prepending the mapped <em>prefix</em> to the (possibly empty) <em>suffix</em>
    using textual concatenation.  If no prefix mapping is defined, the value is interpreted
    as an <tref>absolute IRI</tref>. If the prefix is an underscore
    (<code>_</code>), the IRI remains unchanged. This effectively means that every term
    containing a colon will be interpreted by a JSON-LD processor as an IRI.
  </p>
  <p>Consider the following example:</p>
  <pre class="example" data-transform="updateExample"
     title="Compact IRIs">
<!--
{
  "@context":
  {
    ****"dc": "http://purl.org/dc/elements/1.1/",****
    ****"ex": "http://example.org/vocab#"****
  },
  "@id": "http://example.org/library",
  "@type": ****"ex:Library"****,
  ****"ex:contains"****:
  {
    "@id": "http://example.org/library/the-republic",
    "@type": ****"ex:Book"****,
    ****"dc:creator"****: "Plato",
    ****"dc:title"****: "The Republic",
    ****"ex:contains"****:
    {
      "@id": "http://example.org/library/the-republic#introduction",
      "@type": ****"ex:Chapter"****,
      ****"dc:description"****: "An introductory chapter on The Republic.",
      ****"dc:title"****: "The Introduction"
    }
  }
}
-->
  </pre>
  <p>
    In this example, two different <tref title="vocabulary">vocabularies</tref>
    are referred to using prefixes. Those prefixes are then used as type and
    property values using the compact IRI <code>prefix:suffix</code> notation.
  </p>
  <p>It's also possible to use compact IRIs within the context as shown in the
    following example:</p>
  <pre class="example" data-transform="updateExample"
     title="Using vocabularies">
<!--
{
  "@context":
  {
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "foaf": "http://xmlns.com/foaf/0.1/",
    ****"foaf:homepage"****: { "@type": "@id" },
    "picture": { "@id": ****"foaf:depiction"****, "@type": "@id" }
  },
  "@id": "http://me.markus-lanthaler.com/",
  "@type": "foaf:Person",
  "foaf:name": "Markus Lanthaler",
  "foaf:homepage": "http://www.markus-lanthaler.com/",
  "picture": "http://twitter.com/account/profile_image/markuslanthaler"
}
-->
  </pre>
</section>

<section>
<h2>Typed Values</h2>

<p>
  A value with an associated type, also known as a
  <tdef>typed value</tdef>, is indicated by associating a value with
  an <tref>IRI</tref> which indicates the value's type. Typed values may be
  expressed in JSON-LD in three ways:
</p>

<ol>
  <li>By utilizing the <code>@type</code> <tref>keyword</tref> when defining
    a <tref>term</tref> within a <code>@context</code> section.</li>
  <li>By utilizing the expanded form for specifying values.</li>
  <li>By using a native JSON type such as <tref>number</tref>, <tref>true</tref>, or <tref>false</tref>.</li>
</ol>

<p>The first example uses the <code>@type</code> keyword to associate a
type with a particular <tref>term</tref> in the <code>@context</code>:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded term definition with type coercion">
<!--
{
  ****"@context":
  {
    "modified":
    {
      "@id": "http://purl.org/dc/terms/modified",
      "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
    }
  },****
...
  "modified": "2010-05-29T14:17:39+02:00",
...
}
-->
</pre>

<p>The <em>modified</em> key's value above is automatically type coerced to a
datetime value because of the information specified in the
<code>@context</code>.</p>

<p>The second example uses the expanded form of setting the type information
in the body of a JSON-LD document:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded value with type">
<!--
{
  "@context":
  {
    "modified":
    {
      "@id": "http://purl.org/dc/terms/modified"
    }
  },
...
  "modified":
  ****{
    "@value": "2010-05-29T14:17:39+02:00",
    "@type": "http://www.w3.org/2001/XMLSchema#dateTime"
  }****
...
}
-->
</pre>

<p>Both examples above would generate the value
  <code>2010-05-29T14:17:39+02:00</code> with the type
  <code>http://www.w3.org/2001/XMLSchema#dateTime</code>. Note that it is
  also possible to use a <tref>term</tref> or a <tref>compact IRI</tref> to
  express the value of a type.</p>

<p>The <code>@type</code> <tref>keyword</tref> is also used to associate a type
  with a <tref>node</tref>. The concept of an <tdef>node type</tdef> and
  a <tdef>value type</tdef> are different. This is similar to object-oriented
  programming languages where both scalar and structured types use the same
  class inheritance mechanism, even though scalar types and structured types are
  inherently different.</p>

<pre class="example" data-transform="updateExample"
     title="Example demonstrating the context-sensitivity for @type">
<!--
{
...
  "@id": "http://example.org/posts#TripToWestVirginia",
  ****"@type": "http://schema.org/BlogPosting"****,
  "modified":
  {
    "@value": "2010-05-29T14:17:39+02:00",
    ****"@type": "http://www.w3.org/2001/XMLSchema#dateTime"****
  }
...
}
-->
</pre>

<p>The first use of <code>@type</code> associates a <tref>node type</tref>
  (<code>http://schema.org/BlogPosting</code>) with the <tref>node</tref>,
  which is expressed using the <code>@id</code> <tref>keyword</tref>.
  The second use of <code>@type</code> associates a <tref>value type</tref>
  (<code>http://www.w3.org/2001/XMLSchema#dateTime</code>) with the
  value expressed using the <code>@value</code> <tref>keyword</tref>. As a
  general rule, when <code>@value</code> and <code>@type</code> are used in
  the same <tref>JSON object</tref>, the <code>@type</code>
  <tref>keyword</tref> is expressing a <tref>value type</tref>.
  Otherwise, the <code>@type</code> <tref>keyword</tref> is expressing a
  <tref>node type</tref>.</p>

</section>

<section>
<h2>Language-tagged Strings</h2>

<p>
  A string with an associated language, also known as a
  <tdef>language-tagged string</tdef>, is indicated by associating a string with
  an language code as defined in [[!BCP47]]. Language-tagged strings may be
  expressed in JSON-LD in four ways:
</p>

<ol>
  <li>By defining a global language using the <code>@language</code>
    <tref>keyword</tref> within a <code>@context</code> section.</li>
  <li>By utilizing the <code>@language</code> <tref>keyword</tref> when defining
    a <tref>term</tref> within a <code>@context</code> section.</li>
  <li>By utilizing the expanded form for specifying values.</li>
  <li>By utilizing the <code>@container</code> <tref>keyword</tref> with a
  value of <code>@language</code> when defining a <tref>term</tref> within
  a <code>@context</code> section. This usage pattern is called a
  <tdef>language map</tdef>.</li>
</ol>

<p>The first example uses the <code>@language</code> keyword to associate a
type with a particular <tref>term</tref> in the <code>@context</code>:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded term definition with language coercion">
<!--
{
  ****"@context":
  {
    "title":
    {
      "@id": "http://purl.org/dc/terms/title",
      "@language": "en"
    }
  },****
...
  "title": "JSON-LD Syntax",
...
}
-->
</pre>

<p>The <em>modified</em> key's value above is automatically
  language coerced to a English value because of the information specified in
  the <code>@context</code>.</p>

<p>The second example uses the expanded form of setting the language information
in the body of a JSON-LD document:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded value with language">
<!--
{
  "@context":
  {
    "title":
    {
      "@id": "http://purl.org/dc/terms/title"
    }
  },
...
  "title":
  ****{
    "@value": "JSON-LD Syntax",
    "@language": "en"
  }****
...
}
-->
</pre>

<p>Both examples above would generate the value <code>JSON-LD Syntax</code>
  tagged with the language <code>en</code>; which is the [[!BCP47]] code
  for the English language.</p>

<p>Systems that support multiple languages often need to express data values in
each language. Typically, such systems also try to ensure that developers have
a programatically easy way to navigate the datastructures for the
language-specific data. In this case, <tref>language map</tref>s
may be utilized.</p>

<pre class="example" data-transform="updateExample"
     title="Language map expressing a property in three languages">
<!--
{
  "@context":
  {
    "title":
    {
      "@id": "http://purl.org/dc/terms/title"
      "@container": "@language"
    }
  },
...
  "title":
  ****{
    "en": "JSON-LD Syntax",
    "ru": "JSON-LD Синтаксис",
    "ja": "JSON-LDの構文"
  }****
...
}
-->
</pre>

<p>In the example above, the title is expressed in three languages; English,
  Russian, and Japanese. To access the data above in a programming language
  supporting dot-notation accessors for object properties, a developer may
  use the <code>property.language</code> pattern. For example, to access the
  Japanese version of the title, a developer would use the following code
  snippet: <code>obj.title.ja</code>.</p>
</section>

<section>
<h2>Referencing Contexts from JSON Documents</h2>

<p>Ordinary JSON documents can be transformed into JSON-LD documents by referencing
to an external JSON-LD <tref>context</tref> in an HTTP Link Header. Doing this
allows JSON to be unambiguously machine-readable without requiring developers to
drastically change their workflow and provides an upgrade path for existing
infrastructure without breaking existing clients that rely on the <code>application/json</code>
media type.
</p>

<p>
In order to use an external context with an ordinary JSON document, an author
MUST specify an <tref>IRI</tref> to a valid JSON-LD document in an HTTP Link
Header [[!RFC5988]] using the <code>describedby</code> link relation.

The referenced document MUST have a top-level <tref>node definition</tref>. The
<code>@context</code> subtree within that object is added to the top-level
<tref>node definition</tref> of the referencing document. If an <tref>array</tref> is at the top-level of the
referencing document and its items are <tref title="node definition">node definitions</tref>, the <code>@context</code>
subtree is added to all <tref>array</tref> items. All extra information located outside
of the <code>@context</code> subtree in the referenced document MUST be
discarded.
</p>

<p>The following example demonstrates the use of an external context with an
ordinary JSON document:</p>

<pre class="example" data-transform="updateExample"
     title="Specifing context through HTTP header">
<!--
GET /ordinary-json-document.json HTTP/1.1
Host: example.com
Accept: application/ld+json,application/json,*/*;q=0.1

====================================

HTTP/1.0 200 OK
...
Content-Type: ****application/json****
****Link: <http://json-ld.org/contexts/person.jsonld>; rel="describedby"; type="application/ld+json"****

{
  "name": "Markus Lanthaler",
  "homepage": "http://www.markus-lanthaler.com/",
  "depiction": "http://twitter.com/account/profile_image/markuslanthaler"
}
-->
</pre>

<p class="note">JSON-LD documents served with the <code>application/ld+json</code> media type
  MUST have all context information, including references to external contexts, within the
  body of the document.</p>
</section>

<section>
<h3>Expanded Term Definition</h3>

<p>Within a <tref>context</tref> definition, <tref>term</tref>s MAY be
   defined using an expanded notation to allow for additional information
   associated with the <tref>term</tref> to be specified (see also
   <a href="#type-coercion"></a> and
   <a href="#sets-and-lists"></a>).</p>

<p>Instead of using a string representation of an IRI, the IRI MAY be
specified using a <tref>JSON object</tref> having an <code>@id</code> key.
The value of the <code>@id</code> key MUST be either a <tref>term</tref>, a
<tref>compact IRI</tref>, or an <tref>absolute IRI</tref>. Such
an object is called a <tref>node reference</tref>.</p>

<pre class="example" data-transform="updateExample"
     title="Expanded term definition">
<!--
{
  "@context":
  {
    "foaf": ****{ "@id": "http://xmlns.com/foaf/0.1/" }****,
    "name": ****{ "@id": "http://xmlns.com/foaf/0.1/name" }****,
    "homepage": ****{ "@id": "foaf:homepage" }****,
    "depiction": ****{ "@id": "foaf:depiction" }****
  },
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>

<p>This allows additional information to be associated with the term. This
  MAY be used for <a href="#type-coercion"></a>,
  <a href="#sets-and-lists"></a>), or to associate language
  information with a <tref>term</tref> as shown in the following example:</p>

<pre class="example" data-transform="updateExample"
     title="Expanded term definition with language">
<!--
{
  "@context": {
    ...
    "ex": "http://example.com/",
    "@language": "ja",
    "name": { "@id": "ex:name", ****"@language": null**** },
    "occupation": { "@id": "ex:occupation" },
    "occupation_en": { "@id": "ex:occupation", ****"@language": "en"**** },
    "occupation_cs": { "@id": "ex:occupation", ****"@language": "cs"**** }
  },
  ****"name": "Yagyū Muneyoshi",
  "occupation": "忍者",
  "occupation_en": "Ninja",
  "occupation_cs": "Nindža",****
  ...
}
-->
</pre>

<p>The example above would associate <em>忍者</em> with the specified default
  language code <code>ja</code>, <em>Ninja</em> with the language code
  <code>en</code>, and <em>Nindža</em> with the language code <code>cs</code>.
  The value of <code>name</code>, <em>Yagyū Muneyoshi</em> wouldn't be
  associated with any language code since <code>@language</code> was reset to
  <tref>null</tref> in the expanded term definition.</p>

<p>Expanded terms MAY also be defined using <tref title="compact_iri">compact IRIs</tref> or
  <tref title="absolute_IRI">absolute IRIs</tref> as keys. If the definition does not include an
  <code>@id</code> key, the expanded IRI is determined by performing expansion of the key
  within the current active context. This mechanism is mainly used to associate type or language
  information with a <tref>compact IRI</tref> or an <tref>absolute IRI</tref>.</p>

<p class="note">While it is possible to define a
  <tref>compact IRI</tref>, or an absolute IRI to expand to some
  other unrelated IRI (for example, <code>foaf:name</code> expanding to
  <code>http://example.org/unrelated#species</code>),
  such usage is strongly discouraged.</p>
</section>

<section>
<h2>Type Coercion</h2>

<p>JSON-LD supports the coercion of values to particular data types.
Type <tdef>coercion</tdef> allows someone deploying JSON-LD to coerce the incoming or
outgoing values to the proper data type based on a mapping of data type <tref>IRI</tref>s to
<tref>term</tref>s. Using type coercion, value representation is preserved without requiring
the data type to be specified with each piece of data.</p>

<p>Type coercion is specified within an <a href="#expanded-term-definition"></a>
  using the <code>@type</code> key. The value of this key represents a type IRI and MUST take the form of
  a <tref>term</tref>, <tref>compact IRI</tref>, <tref>absolute IRI</tref>, or the <tref>keyword</tref> <code>@id</code>. Specifying
  <code>@id</code> indicates that within the body of a JSON-LD document, a string value of a <tref>term</tref> coerced to
  <code>@id</code> is to be interpreted as an <tref>IRI</tref>.</p>

<p><tref title="term">Terms</tref> or <tref title="compact_iri">compact IRIs</tref> used as the value of a
  <code>@type</code> key MAY be defined within the same context. This means that one may specify a
  <tref>term</tref> like <code>xsd</code> and then use <code>xsd:integer</code> within the same
  context definition - the JSON-LD processor will be able to determine the proper expansion for
  <code>xsd:integer</code>.</p>

<p>The example below demonstrates how a JSON-LD author can coerce values to
<tref>typed value</tref>s, IRIs and lists.</p>

<pre class="example" data-transform="updateExample"
     title="Expanded term definition with types">
<!--
{
  "@context":
  {
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "name": "http://xmlns.com/foaf/0.1/name",
    "age":
    ****{
      "@id": "http://xmlns.com/foaf/0.1/age",
      "@type": "xsd:integer"
    }****,
    "homepage":
    ****{
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id",
      "@container": "@list"
    }****
  },
  "name": "John Smith",
  "age": ****"41"****,
  "homepage":
  ****[
    "http://personal.example.org/",
    "http://work.example.com/jsmith/"
  ]****
}
-->
</pre>

<p>The example above would generate the following Turtle:</p>

<pre class="example" data-transform="updateExample">
<!--
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

[ foaf:name "John Smith";
  foaf:age  "41"^^xsd:integer;
  foaf:homepage ( <http://personal.example.org/> <http://work.example.com/jsmith/> )
] .
-->
</pre>

<p>Terms may also be defined using <tref title="absolute iri">absolute IRIs</tref> or <tref title="compact_iri">compact IRIs</tref>.
  This allows coercion rules to be applied to keys which are not represented as a simple <tref>term</tref>.
  For example:</p>

<pre class="example" data-transform="updateExample"
     title="Term definition with absolute IRI">
<!--
{
  "@context":
  {
    ****"foaf": "http://xmlns.com/foaf/0.1/"****,
    "****foaf:age****":
    {
      "@type": "xsd:integer"
    },
    "****foaf:homepage****":
    ****{
      "@type": "@id"
    }****
  },
  "foaf:name": "John Smith",
  "foaf:age": ****"41"****,
  "foaf:homepage":
  ****[
    "http://personal.example.org/",
    "http://work.example.com/jsmith/"
  ]****
}
-->
</pre>

<p>In this case the <code>@id</code> definition is optional, but if it does exist, the <tref>compact IRI</tref>
  or <tref>IRI</tref> is treated as a <tref>term</tref> (not a <code>prefix:suffix</code> construct)
  so that the actual definition of a <tref>prefix</tref> becomes unnecessary.</p>

<p class="note">Keys in the context are treated as <tref title="term">terms</tref> for the purpose of
  expansion and value coercion. At times, this may result in multiple representations for the same expanded IRI.
  For example, one could specify that <code>dog</code> and <code>cat</code> both expanded to <code>http://example.com/vocab#animal</code>.
  Doing this could be useful for establishing different type coercion or language specification rules. It also allows a <tref>compact IRI</tref> (or even an
  absolute <tref>IRI</tref>) to be defined as something else entirely. For example, one could specify that
  the <tref>term</tref> <code>http://example.org/zoo</code> should expand to
  <code>http://example.org/river</code>, but this usage is discouraged because it would lead to a
  great deal of confusion among developers attempting to understand the JSON-LD document.</p>

<p>Type coercion is performed using the unexpanded value of the key,
  which MUST have an exact match for an entry in the
  <tref>active context</tref>.</p>

</section>


<section>
<h2>Property Generators</h2>

<p>At times, an author may find that they need to express the same value for
multiple properties. The simplest approach to accomplish this goal would be
to do the following:</p>

<pre class="example" data-transform="updateExample"
     title="Verbose expression of multiple properties with the same value">
<!--
{
  "@context":
  {
    ****"title1": "http://purl.org/dc/terms/title"****,
    ****"title2": "http://schema.org/name"****,
    ****"title3": "http://www.w3.org/2000/01/rdf-schema#label"****
  },
  "@id": "http://example.com/book",
  ****"title1": "The Count of Monte Cristo"****,
  ****"title2": "The Count of Monte Cristo"****,
  ****"title3": "The Count of Monte Cristo"****
}
-->
</pre>

<p>Unfortunately, the approach above produces redundant data and would become a
publishing burden for large data sets.
In these situations, the author may use
a <tdef>property generator</tdef> to express a <tref>term</tref> once, but have
the JSON-LD processor expand the single statement into multiple statements.
This method can be accomplished by using the following markup pattern:</p>

<pre class="example" data-transform="updateExample"
     title="Generating multiple properties using a single term">
<!--
{
  "@context":
  {
    ****"title": { "@id": [ "http://purl.org/dc/terms/title",
                        "http://schema.org/name",
                        "http://www.w3.org/2000/01/rdf-schema#label" ] }****
  },
  "@id": "http://example.com/book",
  ****"title": "The Count of Monte Cristo"****
}
-->
</pre>

<p>While the term above is only used once outside of the <code>@context</code>,
a JSON-LD processor will internally transform the document above into
the following set of statements:</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.com/book>
  <http://purl.org/dc/terms/title>
    "The Count of Monte Cristo" .
<http://example.com/book>
  <http://schema.org/name>
    "The Count of Monte Cristo" .
<http://example.com/book>
  <http://www.w3.org/2000/01/rdf-schema#label>
    "The Count of Monte Cristo" .
-->
</pre>

</section>

<section>
  <h2>IRI Expansion Within a Context</h2>
  <p>In general, normal IRI expansion rules apply
    anywhere an IRI is expected (see <a href="#iris"></a>). Within
    a <tref>context</tref> definition, this can mean that terms defined
    within the context MAY also be used within that context as long as
    there are no circular dependencies. For example, it is common to use
    the <code>xsd</code> namespace when defining <tref>typed value</tref>s:</p>
<pre class="example" data-transform="updateExample"
     title="IRI expansion within context">
<!--
{
  "@context":
  {
    ****"xsd": "http://www.w3.org/2001/XMLSchema#"****,
    "name": "http://xmlns.com/foaf/0.1/name",
    "age":
    {
      "@id": "http://xmlns.com/foaf/0.1/age",
      "@type": ****"xsd:integer"****
    },
    "homepage":
    {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
  },
  ...
}
-->
</pre>
<p>In this example, the <code>xsd</code> <tref>term</tref> is defined
  and used as a <tref>prefix</tref> for the <code>@type</code> coercion
  of the <code>age</code> property.</p>

<p><tref>Term</tref>s MAY also be used when defining the IRI of another
<tref>term</tref>:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    ****"foaf": "http://xmlns.com/foaf/0.1/"****,
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "name": ****"foaf:name"****,
    "age":
    {
      "@id": ****"foaf:age"****,
      "@type": "xsd:integer"
    },
    "homepage":
    {
      "@id": ****"foaf:homepage"****,
      "@type": "@id"
    }
  },
  ...
}
-->
</pre>

<p><tref title="compact iri">Compact IRIs</tref>
  and <tref title="iri">IRIs</tref> MAY be used on the left-hand side of a
  <tref>term</tref> definition.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    ****"foaf": "http://xmlns.com/foaf/0.1/"****,
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "name": "foaf:name",
    "****foaf:age****":
    {
      "@type": "xsd:integer"
    },
    "****foaf:homepage****":
    ****{
      "@type": "@id"
    }****
  },
  ...
}
-->
</pre>

<p>
In this example, the <tref>compact IRI</tref> form is used in two different
ways.
In the first approach, <code>foaf:age</code> declares both the
<tref>IRI</tref> for the <tref>term</tref> (using short-form) as well as the
<code>@type</code> associated with the <tref>term</tref>. In the second
approach, only the <code>@type</code> associated with the <tref>term</tref> is
specified. The JSON-LD processor will derive the full <tref>IRI</tref> for
<code>foaf:homepage</code> by looking up the <code>foaf</code>
<tref>prefix</tref> in the
<tref>context</tref>.
</p>

<p>
<tref title="absolute iri">Absolute IRIs</tref> MAY also be used in the key position in a <tref>context</tref>:
</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    "foaf": "http://xmlns.com/foaf/0.1/",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "name": "foaf:name",
    "foaf:age":
    {
      "@id": "foaf:age",
      "@type": "xsd:integer"
    },
    "****http://xmlns.com/foaf/0.1/homepage****":
    {
      "@type": "@id"
    }
  },
  ...
}
-->
</pre>

<p>
In order for the <tref>absolute IRI</tref> to match above, the <tref>absolute IRI</tref> MUST also
be used in the JSON-LD document. Also note that <code>foaf:homepage</code>
will not use the <code>{ "@type": "@id" }</code> declaration because
<code>foaf:homepage</code> is not the same as
<code>http://xmlns.com/foaf/0.1/homepage</code>. That is, a JSON-LD
processor will use direct string comparison when looking up
<tref>term</tref>s in a <tref>context</tref> before it applies the
<tref>prefix</tref> lookup mechanism.
</p>

<p>The only exception for using terms in the <tref>context</tref> is that
  they MUST NOT be used in a circular manner. That is,
  a definition of <em>term-1</em> MUST NOT depend on the
  definition of <em>term-2</em> if <em>term-2</em> also depends on
  <em>term-1</em>. For example, the following <tref>context</tref> definition
  is illegal:</p>
<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    ****"term1": "term2:foo",
    "term2": "term1:bar"****
  },
  ...
}
-->
</pre>
</section>

<section>
<h2>Sets and Lists</h2>

<p>A JSON-LD author can express multiple values in a compact way by using
  <tref>array</tref>s. Since graphs do not describe ordering for links
  between nodes, arrays in JSON-LD do not provide an ordering of the
  contained elements by default. This is exactly the opposite from regular JSON
  arrays, which are ordered by default. For example, consider the following
  simple document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@id": "http://example.org/people#joebob",
  "nick": ****[ "joe", "bob", "jaybee" ]****,
...
}
-->
</pre>

<p>The markup shown above would result in three triples being generated,
  each relating the node to an individual value, with no inherent order:</p>

<p class="issue">Including an illustration might be better.</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/people#joebob> <http://xmlns.com/foaf/0.1/nick> "joe" .
<http://example.org/people#joebob> <http://xmlns.com/foaf/0.1/nick> "bob" .
<http://example.org/people#joebob> <http://xmlns.com/foaf/0.1/nick> "jaybee" .
-->
</pre>

<p>Multiple values may also be expressed using the expanded form:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@id": "http://example.org/articles/8",
  "dc:title": ****
  [
    {
      "@value": "Das Kapital",
      "@language": "de"
    },
    {
      "@value": "Capital",
      "@language": "en"
    }
  ]****
}-->
</pre>

<p>The markup shown above would generate the following triples, again with
  no inherent order:</p>

<p class="issue">Including an illustration might be better.</p>

<pre class="example" data-transform="updateExample">
<!--
<http://example.org/articles/8> <http://purl.org/dc/terms/title> "Das Kapital"@de .
<http://example.org/articles/8> <http://purl.org/dc/terms/title> "Capital"@en .
-->
</pre>


<p>As the notion of ordered collections is rather important in data
  modeling, it is useful to have specific language support. In JSON-LD,
  a list may be represented using the <code>@list</code> <tref>keyword</tref> as follows:</p>
<pre class="example" data-transform="updateExample">
<!--
{
...
  "@id": "http://example.org/people#joebob",
  "foaf:nick":
  ****{
    "@list": [ "joe", "bob", "jaybee" ]
  }****,
...
}
-->
</pre>

<p>This describes the use of this <tref>array</tref> as being ordered,
  and order is maintained when processing a document. If every use of a given multi-valued
  property is a list, this may be abbreviated by setting <code>@container</code>
  to <code>@list</code> in the <tref>context</tref>:</p>
<pre class="example" data-transform="updateExample">
<!--
{
  ****"@context":
  {
    ...
    "nick":
    {
      "@id": "http://xmlns.com/foaf/0.1/nick",
      "@container": "@list"
    }
  }****,
...
  "@id": "http://example.org/people#joebob",
  "nick": ****[ "joe", "bob", "jaybee" ]****,
...
}
-->
</pre>

<p class="note">List of lists are not allowed in this version of JSON-LD.
  If a list of lists is detected, a JSON-LD processor will throw an exception.
  This decision was made due to the extreme amount of added complexity when
  processing lists of lists.</p>

<p>Similarly to <code>@list</code>, there exists the <tref>keyword</tref> <code>@set</code> to
  describe unordered sets. While its use in the body of a JSON-LD document
  represents just syntactic sugar that MUST be optimized away when processing
  the document, it is very helpful when used within the context of a document.
  Values of terms associated with a <code>@set</code> or <code>@list</code> container
  are always represented in the form of an <tref>array</tref> - even if there is just a
  single value that would otherwise be optimized to a non-array form in a
  <a href="#compact-document-form"></a>. This makes post-processing of
  the data easier as the data is always in array form, even if the array only
  contains a single value.</p>

<p class="note">The use of <code>@container</code> in the body of a JSON-LD
  document, i.e., outside <code>@context</code> MUST be ignored by
  JSON-LD processors.</p>

</section>

<section>
  <h2>Embedding</h2>

  <p><tdef>Embedding</tdef> is a JSON-LD feature that allows an author to
    use <tref title="node definition">node definitions</tref> as
    <tref>property</tref> values. This is a commonly used mechanism for
    creating a parent-child relationship between two <tref>node</tref>s.</p>

  <p>The example shows two nodes related by a property from the first node:</p>

  <pre class="example" data-transform="updateExample">
  <!--
  {
  ...
    "name": "Manu Sporny",
    "****knows****":
    {
      "****@type****": "****Person****",
      "****name****": "****Gregg Kellogg****",
    }
  ...
  }
  -->
  </pre>

  <p>
    A <tref>node definition</tref>, like the one used above, MAY be used in
    any value position in the body of a JSON-LD document.</p>
</section>

<section>
  <h2>Named Graphs</h2>
  <p>The <code>@graph</code> <tref>keyword</tref> is used to express a set of
    JSON-LD <tref>node definition</tref>s that may not be directly related
    to one another through a property. The mechanism may also be used where
    <tref>embedding</tref> is not desirable to the application. For example:</p>

  <pre class="example" data-transform="updateExample">
  <!--
  {
    "@context": ...,
    "****@graph****":
    [
      {
        "@id": "http://manu.sporny.org/i/public",
        "@type": "foaf:Person",
        "name": "Manu Sporny",
        "knows": "http://greggkellogg.net/foaf#me"
      },
      {
        "@id": "http://greggkellogg.net/foaf#me",
        "@type": "foaf:Person",
        "name": "Gregg Kellogg",
        "knows": "http://manu.sporny.org/i/public"
      }
    ]
  }
  -->
  </pre>

  <p>In this case, embedding doesn't work as each
    <tref>node definition</tref> references the other. Using the
    <code>@graph</code> <tref>keyword</tref> allows multiple resources to be
    defined within an <tref>array</tref>, and allows the use of a shared
    <tref>context</tref>. When used in a <tref>JSON object</tref> that is not otherwise
    a <tref>node definition</tref>, this describes resources in the <em>default graph</em>.
    This is equivalent to using multiple <tref
    title="node definition">node definitions</tref> in array and defining
    the <code>@context</code> within each <tref>node definition</tref>:</p>

  <pre class="example" data-transform="updateExample">
  <!--
  ****[****
    {
      ****"@context": ...,****
      "@id": "http://manu.sporny.org/i/public",
      "@type": "foaf:Person",
      "name": "Manu Sporny",
      "knows": "http://greggkellogg.net/foaf#me"
    },
    {
      ****"@context": ...,****
      "@id": "http://greggkellogg.net/foaf#me",
      "@type": "foaf:Person",
      "name": "Gregg Kellogg",
      "knows": "http://manu.sporny.org/i/public"
    }
  ****]****
  -->
  </pre>

  <p>JSON-LD allows you to <em>name</em> things on the Web by assigning
    an <code>@id</code> to them, which is typically an <tref>IRI</tref>.
    This notion extends to the ability to identify graphs in the same
    manner. A developer may name data expressed using the <code>@graph</code>
    <tref>keyword</tref> by pairing it with an <code>@id</code>
    <tref>keyword</tref>. This enables the developer to make statements
    about a <tref>linked data graph</tref> itself,
    rather than just a single <tref>node</tref>.</p>

  <pre class="example" data-transform="updateExample">
  <!--
  {
    "@context": ...,
    ****"@id": "http://example.org/graphs/73",
    "asOf": { "@value": "2012-04-09", "@type": "xsd:date" },
    "@graph":****
    [
      {
        "@id": "http://manu.sporny.org/i/public",
        "@type": "foaf:Person",
        "name": "Manu Sporny",
        "knows": "http://greggkellogg.net/foaf#me"
      },
      {
        "@id": "http://greggkellogg.net/foaf#me",
        "@type": "foaf:Person",
        "name": "Gregg Kellogg",
        "knows": "http://manu.sporny.org/i/public"
      }
    ]
  }
  -->
  </pre>

  <p>The example above expresses a <em>named</em>
    <tref>linked data graph</tref> that is identified by the <tref>IRI</tref>
    <code>http://example.org/graphs/73</code>. That graph is composed of the
    statements about Manu and Gregg. Meta-data about the graph itself is also
    expressed via the <code>asOf</code> property, which specifies when the
    information was retrieved from the Web.</p>

  <p class="issue">These examples could all have TriG definitions of their RDF results,
    but that would involve adding RDF earlier in the document.</p>

</section>

<section>
<h2>Identifying Unlabeled Nodes</h2>

<p>At times, it becomes necessary to be able to express information without
being able to specify the node. Typically, this type of node is called
an <tdef>unlabeled node</tdef> or a <tdef>blank node</tdef> (see [[!RDF-CONCEPTS]] <cite><a href="http://www.w3.org/TR/rdf11-concepts/#section-blank-nodes">Section 3.4: Blank Nodes</a></cite>).
In JSON-LD, <tref>unlabeled node</tref> identifiers are
automatically created if a node is not specified using the
<code>@id</code> <tref>keyword</tref>. However, authors may provide identifiers for
<tref title="unlabeled node">unlabeled nodes</tref> by using the special <code>_</code> (underscore)
<tref>prefix</tref>. This allows one to reference the node locally within the
document, but makes it impossible to reference the node from an
external document. The <tref>unlabeled node</tref> identifier is scoped to the
document in which it is used.</p>

<pre class="example" data-transform="updateExample">
<!--
{
...
  "@id": "****_:foo****",
...
}
 -->
</pre>

<p>The example above would set the node to <code>_:foo</code>, which can
then be used elsewhere in the JSON-LD document to refer back to the
<tref>unlabeled node</tref>. If a developer finds that they refer to the unlabeled
node more than once, they should consider naming the node using a de-referenceable
<tref>IRI</tref> so that it can be referenced also from other documents.
</p>

</section>

<section>
<h2>Aliasing Keywords</h2>

<p>Each of the JSON-LD <tref title="keyword">keywords</tref>,
except for <code>@context</code>, MAY be aliased to application-specific
keywords. This feature allows legacy JSON content to be utilized
by JSON-LD by re-using JSON keys that already exist in legacy documents.
This feature also allows developers to design domain-specific implementations
using only the JSON-LD <tref>context</tref>.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
     ****"url": "@id"****,
     ****"a": "@type"****,
     "name": "http://schema.org/name"
  },
  "****url****": "http://example.com/about#gregg",
  "****a****": "http://schema.org/Person",
  "name": "Gregg Kellogg"
}
-->
</pre>

<p>In the example above, the <code>@id</code> and <code>@type</code>
<tref title="keyword">keywords</tref> have been given the aliases <strong>url</strong> and
<strong>a</strong>, respectively.
</p>

</section>

<section>
<h3>Expanded Document Form</h3>
<p>The JSON-LD API [[JSON-LD-API]] defines an method for <em>expanding</em> a
  JSON-LD document.
  Expansion is the process of taking a JSON-LD document and applying a
  <code>@context</code> such that all IRIs, types, and values
  are expanded so that the <code>@context</code> is no longer necessary.</p>

<p>For example, assume the following JSON-LD input document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
   "@context":
   {
      "name": "http://xmlns.com/foaf/0.1/name",
      "homepage": {
        "@id": "http://xmlns.com/foaf/0.1/homepage",
        "@type": "@id"
      }
   },
   "name": "Manu Sporny",
   "homepage": "http://manu.sporny.org/"
}
-->
</pre>

<p>Running the JSON-LD Expansion algorithm against the JSON-LD input document
  provided above would result in the following output:</p>

<pre class="example" data-transform="updateExample">
<!--
[
  {
    "http://xmlns.com/foaf/0.1/name": [
      { "@value": "Manu Sporny" }
    ],
    "http://xmlns.com/foaf/0.1/homepage": [
      { "@id": "http://manu.sporny.org/" }
    ]
  }
]
-->
</pre>

<p>Expanded document form is useful when an application has to process input
data in a deterministic form. It has been optimized to ensure that the code
that developers have to write is minimized compared to the code that would
have to be written to operate on
<a href="#compact-document-form"></a>.</p>

</section>

<section>
<h3>Compact Document Form</h3>
<p>The JSON-LD API [[JSON-LD-API]] defines a method for <em>compacting</em> a JSON-LD document.
  Compaction is the process of taking a JSON-LD document and applying a
  context such that the most compact form of the document is generated. JSON
  is typically expressed in a very compact, key-value format. That is, full
  IRIs are rarely used as keys. At times, a JSON-LD document may be received
  that is not in its most compact form. JSON-LD, via the API, provides a way
  to compact a JSON-LD document.</p>

<p>For example, assume the following JSON-LD input document:</p>

<pre class="example" data-transform="updateExample">
<!--
[
  {
    "http://xmlns.com/foaf/0.1/name": [ "Manu Sporny" ],
    "http://xmlns.com/foaf/0.1/homepage": [
      {
       "@id": "http://manu.sporny.org/"
      }
    ]
  }
]
-->
</pre>

<p>Additionally, assume the following developer-supplied JSON-LD context:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
  }
}
-->
</pre>

<p>Running the JSON-LD Compaction algorithm given the context supplied above
  against the JSON-LD input document provided above would result in the following
  output:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
  },
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/"
}
-->
</pre>

<p>The compaction algorithm enables a developer to map any document into an
  application-specific compacted form by first <a href="#expanded-document-form"></a>.
  While the context provided above mapped <code>http://xmlns.com/foaf/0.1/name</code>
  to <strong>name</strong>, it could have also mapped it to any arbitrary string
  provided by the developer. This powerful mechanism, along with another
  JSON-LD API technique called <em>framing</em>, allows the developer to
  re-shape the incoming JSON data into a format that is optimized for
  their application.</p>
</section>

</section>

<section class="appendix normative">
<h2>JSON-LD Grammar</h2>
<em>This section is normative</em>

<p class="issue resolved" data-number="114">This section is an attempt to formalize
a normative grammar for JSON-LD.</p>

<p>This appendix restates the syntactic conventions described in the
  previous sections more formally.</p>

<p>A JSON-LD processor SHOULD attempt to process non-conforming
  JSON-LD documents. Conformance violations MUST be reported through a
  callback mechanism defined in [[JSON-LD-API]].</p>

<p>For a JSON-LD document to be conforming, it MUST be a valid JSON document
  as described in [[!RFC4627]].</p>

<p>JSON-LD introduces a number of keywords of the form '<code>@</code>'
  followed by a set of one or more lower case alphabetic characters
  (<code>@[a-z]+</code>). JSON-LD documents SHOULD NOT define terms beginning
  with '<code>@</code>'.
  (See <a href="#syntax-tokens-and-keywords"></a> for a complete definition of JSON-LD keywords).</p>

<p class="note">The JSON-LD context allows <tref title="keyword">keywords</tref> to be
  aliased within the <tref>active context</tref>. Whenever a <tref>keyword</tref> is
  discussed, this is also understood to apply to an alias for that <tref>keyword</tref>
  For example, if the <tref>active context</tref> defines the <tref>term</tref> <code>id</code> as
  an alias for <code>@id</code>, that alias may be legitimately used as a substitution
  for <code>@id</code>. Note that <tref>keyword</tref> aliases are not expanded during
  context processing.</p>

<p>A JSON-LD document is either a
  a single <tref>node definition</tref>
  or a JSON <tref>array</tref> containing a set of
  one or more <tref title="node definition">node definitions</tref>.</p>
<pre class="example" data-transform="updateExample"
     title="Simple node definition">
<!--
{
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>
<pre class="example" data-transform="updateExample"
     title="Array of node definitions">
<!--
[
  {
    "name": "Manu Sporny",
    "homepage": "http://manu.sporny.org/",
    "depiction": "http://twitter.com/account/profile_image/manusporny"
  }, {
    "name": "Gregg Kellogg",
    "homepage": "http://greggkellogg.net/",
    "depiction": "http://twitter.com/account/profile_image/gkellogg"
  }
]
-->
</pre>

<section id="grammar-node-definition">
<h3>Node Definition</h3>
<p>A <tref>node definition</tref> is a <tref>JSON object</tref>
  containing one or more key/value pairs. Keys are <tref>IRI</tref>s,
  <tref>compact IRI</tref>s,
  <tref>term</tref>s defined within the <tref>active context</tref>, or one of the
  following keywords:</p>
<ul>
  <li><code>@context</code>,</li>
  <li><code>@graph</code>,</li>
  <li><code>@id</code>, or</li>
  <li><code>@type</code></li>
</ul>
<p>If the <tref>node definition</tref> contains the <code>@context</code>
  key, it's value MUST be one of the following:</p>
<ul>
  <li>a <tref>string</tref> with the lexical form of <tref>IRI</tref>,</li>
  <li>a <tref>JSON object</tref> conforming the the syntax requirements stated
    in <a href="#grammar-context"></a>, or</li>
  <li>an <tref>array</tref> composed of any number of the previous two expressions.</li>
</ul>
<pre class="example" data-transform="updateExample"
     title="Node definition with external context">
<!--
{
  ****"@context": "http://json-ld.org/contexts/person.jsonld"****,
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>
<p>See <a href="#node-identifiers"></a>, <a href="#compact-iris"></a>,
  and <a href="#identifying-unlabeled-nodes"></a> for further discussion on
  <code>@id</code> values.</p>

<p>If the <tref>node definition</tref> contains the <code>@id</code>
  key, it's value
  MUST be a <tref>string</tref> having the lexical form of <tref>IRI</tref>,
  <tref>compact IRI</tref> (including <tref>unlabeled node</tref>), or a
  <tref>term</tref> defined in the <tref>active context</tref> expanding
  into an <tref>IRI</tref> or an <tref>unlabeled node</tref>.</p>

<pre class="example" data-transform="updateExample"
     title="Node definition with @id">
<!--
{
  "@context": "http://json-ld.org/contexts/person.jsonld",
  ****"@id": "http://manu.sporny.org/i/public"****,
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>

<p>If the <tref>node definition</tref> contains the <code>@type</code>
  key, it's value
  MUST be either a <tref>string</tref> having the lexical form of
  <tref>absolute IRI</tref>, <tref>compact IRI</tref>, a <tref>term</tref> defined in the
  <tref>active context</tref> expanding into an <tref>absolute IRI</tref>,
  or an <tref>array</tref> of any of these.</p>

<p class="note">A JSON-LD processor SHOULD process non-conforming documents
  having <code>@type</code> values including <tref>node definition</tref> or
  <tref>node reference</tref> entries but MUST
  discard everything except for the value of the <code>@id</code> key.</p>

<pre class="example" data-transform="updateExample"
     title="Node definition with @type">
<!--
{
  "@context": "http://json-ld.org/contexts/person.jsonld",
  "@id": "http://manu.sporny.org/i/public",
  ****"@type": "Person"****,
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/",
  "depiction": "http://twitter.com/account/profile_image/manusporny"
}
-->
</pre>
<p>See <a href="#specifying-the-type"></a> for further discussion on
  <code>@type</code> values.</p>

<p>If the <tref>node definition</tref> contains the <code>@graph</code>
  key, it's value MUST
  be a <tref>node definition</tref> or an <tref>array</tref> of zero or more
  <tref title="node definition">node definitions</tref>. If the
  <tref>node definition</tref> contains an <code>@id</code> keyword,
  its value is used as the label of a named graph.</p>

<p class="note">As a special case, if the <tref>JSON object</tref> contains no
  keys other than <code>@graph</code> and <code>@context</code>, and the
  <tref>JSON object</tref> is the root of the JSON-LD document, the
  <tref>JSON object</tref> is not treated as a <tref>node definition</tref>; this
  is used as a way of defining <tref title="node definition">node
  definitions</tref> that may not form a connected graph. This allows a
  <tref>context</tref> to be defined which is shared by all of the constituent
  <tref title="node definition">node definitions</tref>.</p>


<pre class="example" data-transform="updateExample"
     title="Multiple node definitions with a single context using @graph">
<!--
{
  "@context": ...,
  "****@graph****":
  [
    {
      "@id": "http://manu.sporny.org/i/public",
      "@type": "foaf:Person",
      "name": "Manu Sporny",
      "knows": "http://greggkellogg.net/foaf#me"
    },
    {
      "@id": "http://greggkellogg.net/foaf#me",
      "@type": "foaf:Person",
      "name": "Gregg Kellogg",
      "knows": "http://manu.sporny.org/i/public"
    }
  ]
}
-->
</pre>

<p>See <a href="#named-graphs"></a> for further discussion on
  <code>@graph</code> values.</p>

<p>A JSON-LD document MUST NOT contain any other <tref>keyword</tref> or
  alias expanding to any other keyword.</p>

<p>Other keys MUST expand to an <tref>absolute IRI</tref> using the
  <tref>active context</tref>. The values associated with these keys
  may be any of the following:</p>

<ul>
  <li><tref>string</tref>,</li>
  <li><tref>number</tref>,</li>
  <li><tref>true</tref>,</li>
  <li><tref>false</tref>,</li>
  <li><tref>null</tref>,</li>
  <li><tref>node reference</tref>,</li>
  <li><tref>node definition</tref>,</li>
  <li><tref>typed value</tref>,</li>
  <li><tref>language-tagged string</tref>,</li>
  <li><code>@set</code> or <code>@list</code>
    definition (see <a href="#sets-and-lists"></a>),</li>
  <li>an <tref>array</tref> zero or more of these, or</li>
  <li><tref>language map</tref>.</li>
</ul>

</section>

<section id="grammar-node-reference">
<h2>Node Reference</h2>
<p>A <tref>JSON object</tref> containing only the <code>@id</code> (or alias)
  is a <tref>node reference</tref> and not a
  <tref>node definition</tref>.
</p>
<pre class="example" data-transform="updateExample"
     title="Explicit node reference">
<!--
{
  "@context": ...,
  "@graph": [
    {
      "@id": "http://example.org/library",
      "@type": "ex:Library",
      ****"ex:contains": {"@id": "http://example.org/library/the-republic"}****
    }, {
      "@id": "http://example.org/library/the-republic",
      "@type": "ex:Book",
      "dc:creator": "Plato",
      "dc:title": "The Republic",
      ****"ex:contains": {"@id": "http://example.org/library/the-republic#introduction"}****
    }, {
      "@id": "http://example.org/library/the-republic#introduction",
      "@type": "ex:Chapter",
      "dc:description": "An introductory chapter on The Republic.",
      "dc:title": "The Introduction"
    }
  ]
}
}-->
</pre>
</section>

<section id="grammar-language-map">
<h2>Language Map</h2>
<p>A <tref>language map</tref> may be used as a term value within a
  <tref>node definition</tref> if the term is defined with
  <code>@container</code> set to <code>@language</code>.</p>
<p>The keys of a <tref>language map</tref> MUST be a [[BCP47]] string
  with an associated value that is any of the following types:</p>
<ul>
  <li><tref>string</tref>,</li>
  <li><tref>number</tref>,</li>
  <li><tref>true</tref>,</li>
  <li><tref>false</tref>,</li>
  <li><tref>null</tref>,</li>
  <li><tref>node reference</tref>,</li>
  <li><tref>node definition</tref>,</li>
  <li><tref>typed value</tref>,</li>
  <li><tref>language-tagged string</tref>,</li>
  <li><code>@set</code> or <code>@list</code>
    definition (see <a href="#sets-and-lists"></a>), or</li>
  <li>an <tref>array</tref> zero or more of these</li>
</ul>
<p class="issue resolved" data-number="133">We had also discussed values other than strings, such as those that might represent a more reified version of a value with other properties, such as is described using <a href="http://www.w3.org/TR/skos-reference/skos-xl.html">SKOS-XL</a>.</p>
<pre class="example" data-transform="updateExample"
     title="Language map expressing a property in three languages">
<!--
{
  "@context":
  {
    "title":
    {
      "@id": "http://purl.org/dc/terms/title"
      ****"@container": "@language"****
    }
  },
...
  "title":
  ****{
    "en": "JSON-LD Syntax",
    "ru": "JSON-LD Синтаксис",
    "ja": "JSON-LDの構文"
  }****
...
}
-->
</pre>
</section>

<section id="grammar-expanded-values">
<h2>Expanded Values</h2>
<p>An <tdef>expanded value</tdef> is a <tref>JSON object</tref> containing the
  <code>@value</code> key, or an alias for the <code>@value</code> value key.
  It MAY
  also contain the <code>@type</code> or <code>@language</code> keys, or their
  respective keyword aliases. An <tref>expanded value</tref> MUST NOT
  contain keys other than <code>@value</code>, <code>@language</code>, and
  <code>@type</code>.
  An <tref>expanded value</tref> MUST NOT contain both the
  <code>@language</code> and <code>@type</code> keys.</p>
  <p>The value of the <code>@value</code> key, or its alias, MUST be either a
  <tref>string</tref>, <tref>number</tref>, <tref>true</tref>, or
  <tref>false</tref>.</p>
<p>If an <tref>expanded value</tref> contains a <code>@language</code> key,
  it MUST NOT contain any other key except <code>@value</code>. The value of
  the <code>@language</code> key MUST have the lexical form described in
  [[!BCP47]], or be <tref>null</tref>.</p>
<p>If an <tref>expanded value</tref> contains a <code>@type</code> key, it
  MUST NOT contain any other key except <code>@value</code>. The value of
  <code>@type</code> MUST be a <tref>term</tref>, <tref>compact IRI</tref>,
  <tref>absolute IRI</tref>, or <code>null</code>.</p>
<p>See <a href="#typed-values"></a> and <a href="#language-tagged-strings"></a>
  for a further discussion of
  <tref title="expanded value">expanded values</tref>.</p>
</section>

<section id="grammar-set-list">
<h2>List and Set Values</h2>

<p>A <tdef>list</tdef> is a <tref>JSON object</tref> having only the <code>@list</code>
  <tref>keyword</tref>. Its value MUST be an <tref>array</tref> of any of the following:</p>
<ul>
  <li><tref>string</tref>,</li>
  <li><tref>node reference</tref>,</li>
  <li><tref>node definition</tref>,</li>
  <li><tref>typed value</tref>, or</li>
  <li><tref>language-tagged string</tref>.</li>
</ul>
<p>A <tdef>set</tdef> is a <tref>JSON object</tref> having only the <code>@set</code>
  <tref>keyword</tref>. Its value MUST be an <tref>array</tref> of any of the following:</p>
<ul>
  <li><tref>string</tref>,</li>
  <li><tref>node reference</tref>,</li>
  <li><tref>node definition</tref>,</li>
  <li><tref>typed value</tref>,</li>
  <li><tref>language-tagged string</tref>,</li>
  <li><code>@set</code> or <code>@list</code>
    definition (see <a href="#sets-and-lists"></a>), or</li>
  <li>an <tref>array</tref> zero or more of these.</li>
</ul>
<p>See <a href="#sets-and-lists"></a> for a further discussion of List and Set Values.</p>
</section>

<section id="grammar-context">
<h2>Context Definition</h2>
<p>A <tdef>context definition</tdef> is a <tref>JSON object</tref>
  containing one or more key/value pairs. Keys are non-keyword <tref title="string">strings</tref>
  or the <code>@language</code> or <code>@vocab</code> <tref title="keyword">keywords</tref>.
  A <tref>context definition</tref>
  SHOULD NOT contain any keys having the lexical form of <tref>keyword</tref> other than
  <code>@language</code> or <code>@vocab</code>.</p>
<p>If the <tref>context definition</tref> has a <code>@language</code> key,
  the value MUST have the lexical form described in [[!BCP47]] or be <tref>null</tref>.</p>
<p>If the <tref>context definition</tref> has a <code>@vocab</code> key,
  the value MUST have the lexical form of <tref>absolute IRI</tref> or be <tref>null</tref>.</p>
<p>Other keys are <tref>term</tref> definitions. Their values MUST be either a
  <tref>string</tref>, or a <tref>JSON object</tref> having the form of an <tref>expanded term
  definition</tref> (see <a href="#expanded-term-definition"></a>).</p>
<p>An <tdef>expanded term definition</tdef> is composed of zero or more keys from <code>@id</code>,
  <code>@type</code>, <code>@language</code> or <code>@container</code>. An
  <tref>expanded term definition</tref> SHOULD NOT contain any other keys.
  All values associated with <code>@id</code> MUST expand to an <tref>absolute IRI</tref>.</p>
<p>If the <tref>term</tref> definition is not a <tref>compact IRI</tref> or <tref>absolute IRI</tref>,
  the <tref>expanded term
  definition</tref> MUST include the <code>@id</code> key.</p>
<p>If the <tref>expanded term definition</tref> contains the <code>@id</code> <tref>keyword</tref>,
  it MUST be a <tref>string</tref> having the lexical form of <tref>IRI</tref>,
  <tref>compact IRI</tref>, a <tref>term</tref> defined in the defining <tref>context
  definition</tref> or the <tref>active context</tref>, or an <tref>array</tref> composed of any of the previous allowed values.</p>
<p>If the <tref>expanded term definition</tref> contains the <code>@type</code> <tref>keyword</tref>,
  it MUST be a <tref>string</tref> having the lexical form of <tref>absolute IRI</tref>,
  <tref>compact IRI</tref>, or a <tref>term</tref> defined in the defining <tref>context
  definition</tref> or the <tref>active context</tref>.</p>
<p>If the <tref>expanded term definition</tref> contains the <code>@language</code> <tref>keyword</tref>,
  the value MUST have the lexical form described in [[!BCP47]] or be <tref>null</tref>.</p>
<p>If the <tref>expanded term definition</tref> contains the <code>@container</code> <tref>keyword</tref>,
  the value MUST be either <code>@list</code>, <code>@set</code>, <code>@language</code>, or be <tref>null</tref>.
  If the value is <code>@language</code>, when the <tref>term</tref> is used outside of the <code>@context</code>, the
  associated value MUST be a <tref>JSON object</tref> whose keys are <tref>string</tref>s that are [[BCP47]] language identifiers.
  The values associated with each [[BCP47]] language string MUST be a <tref>string</tref> or an <tref>array</tref> of <tref>string</tref>s.</p>
<p>See <a href="#the-context"></a> and <a href="#expanded-term-definition"></a>
  for a further discussion of contexts.</p>
</section>
<pre class="example" data-transform="updateExample"
     title="Context definition with simple terms, expanded term definitions and @language">
<!--
{
  "@language": "en",
  "xsd": "http://www.w3.org/2001/XMLSchema#",
  "foaf": "http://xmlns.com/foaf/0.1/",
  "name": "foaf:name",
  "depiction": {"@id": "foaf:depiction", "@type": "@id"},
  "modified": {"@id": "http://purl.org/dc/terms/modified", "@type": "xsd:dateTime"},
  "homepage": {"@id": "foaf:homepage", "@type": "@id", "@container": "@list"}
}
-->
</pre>
</section>

<section class="appendix informative">
<h2>Relationship to Other Linked Data Formats and Data Models</h2>

<p class="issue">
The intent of the Working Group and the Editors of this specification is to
eventually align terminology used in this document with the terminology used
in the RDF Concepts document [[!RDF-CONCEPTS]] to the extent to which it makes sense to do so.
In general, if there is an analogue to terminology used in this document in
the RDF Concepts document, the preference is to use the terminology in the
RDF Concepts document.
</p>

<p>JSON-LD is a specification for representing <tref>Linked Data</tref> in JSON. A common
  way of working with Linked Data is through <tdef>RDF</tdef>, the Resource Description Framework.
  RDF can be expressed using JSON-LD by associating JSON-LD concepts such as <code>@id</code>
  and <code>@type</code> with the equivalent <tref>IRI</tref>s in RDF. Further information about
  RDF may be found in the [[RDF-PRIMER]].</p>

<p>The JSON-LD markup examples below demonstrate how JSON-LD can be used to
  express semantic data marked up in other languages and data models
  such as RDF, Turtle, RDFa, Microformats,
  and Microdata. These sections are merely provided as evidence that JSON-LD is
  very flexible in what it can express across different <tref>Linked Data</tref> approaches.
  Further information on transforming JSON-LD into RDF are detailed in the
  [[JSON-LD-API]].</p>

<section>
  <h3>RDF</h3>

  <p>The RDF data model, as outlined in [[RDF-CONCEPTS]], is an abstract
  syntax for representing a directed graph of information. JSON-LD is
  capable of serializing any RDF graph, and performing full RDF to
  JSON-LD to RDF round-tripping. A complete description of how JSON-LD maps
  to RDF and algorithms detailing how one can convert from RDF to
  JSON-LD and from JSON-LD to RDF are included in the JSON-LD API
  [[JSON-LD-API]] specification.
  </p>

</section>

<section>
  <h3>Turtle</h3>

  <p>The following are examples of converting <tref>RDF</tref>
  expressed in [[TURTLE-TR]] into JSON-LD.</p>

<section>
<h4>Prefix definitions</h4>
<p>The JSON-LD context has direct equivalents for the Turtle
  <code>@prefix</code> declaration:</p>

<pre class="example" data-transform="updateExample">
<!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<http://manu.sporny.org/i/public> a foaf:Person;
  foaf:name "Manu Sporny";
  foaf:homepage <http://manu.sporny.org/> .
-->
</pre>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    "foaf": "http://xmlns.com/foaf/0.1/"
  },
  "@id": "http://manu.sporny.org/i/public",
  "@type": "foaf:Person",
  "foaf:name": "Manu Sporny",
  "foaf:homepage": { "@id": "http://manu.sporny.org/" }
}
-->
</pre>

<p class="note">JSON-LD has no equivalent for the Turtle <code>@base</code> declaration.</p>

</section>

<section>
<h4>Embedding</h4>
<p>Both Turtle and JSON-LD allow embedding, although Turtle only allows embedding of
  <tref title="unlabeled node">unlabeled nodes</tref>.</p>
</section>

<pre class="example" data-transform="updateExample">
<!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<http://manu.sporny.org/i/public>
  a foaf:Person;
  foaf:name "Manu Sporny";
  foaf:knows [ a foaf:Person; foaf:name "Gregg Kellogg" ] .
-->
</pre>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    "foaf": "http://xmlns.com/foaf/0.1/"
  },
  "@id": "http://manu.sporny.org/i/public",
  "@type": "foaf:Person",
  "foaf:name": "Manu Sporny",
  "foaf:knows":
  {
    "@type": "foaf:Person",
    "foaf:name": "Gregg Kellogg"
  }
}
-->
</pre>
<section>
<h4>Lists</h4>
<p>Both JSON-LD and Turtle can represent sequential lists of values.</p>

<pre class="example" data-transform="updateExample">
<!--
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<http://example.org/people#joebob> a foaf:Person;
  foaf:name "Joe Bob";
  foaf:nick ( "joe" "bob" "jaybee" ) .
-->
</pre>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    "foaf": "http://xmlns.com/foaf/0.1/"
  },
  "@id": "http://example.org/people#joebob",
  "@type": "foaf:Person",
  "foaf:name": "Joe Bob",
  "foaf:nick":
  {
    "@list": [ "joe", "bob", "jaybee" ]
  }
}
-->
</pre>
</section>

</section>

<section>
<h3>RDFa</h3>

<p>The following example describes three people with their respective names and
homepages.</p>

<pre class="example" data-transform="updateExample">
<!--
<div ****prefix="foaf: http://xmlns.com/foaf/0.1/"****>
   <ul>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/bob/" property="foaf:name" ****>Bob</a>
      </li>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/eve/" property="foaf:name" ****>Eve</a>
      </li>
      <li ****typeof="foaf:Person"****>
        <a ****rel="foaf:homepage" href="http://example.com/manu/" property="foaf:name" ****>Manu</a>
      </li>
   </ul>
</div>
-->
</pre>

<p>An example JSON-LD implementation using a single <tref>context</tref> is
described below.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    "foaf": "http://xmlns.com/foaf/0.1/"
  },
  "@graph":
  [
    {
      "@type": "foaf:Person",
      "foaf:homepage": "http://example.com/bob/",
      "foaf:name": "Bob"
    },
    {
      "@type": "foaf:Person",
      "foaf:homepage": "http://example.com/eve/",
      "foaf:name": "Eve"
    },
    {
      "@type": "foaf:Person",
      "foaf:homepage": "http://example.com/manu/",
      "foaf:name": "Manu"
    }
  ]
}
-->
</pre>

</section>

<section>
<h3>Microformats</h3>

<p>The following example uses a simple Microformats hCard example to express
how the Microformat is represented in JSON-LD.</p>

<pre class="example" data-transform="updateExample">
<!--
<div class="vcard">
 <a class="url fn" href="http://tantek.com/">Tantek Çelik</a>
</div>
-->
</pre>

<p>The representation of the hCard expresses the Microformat terms in the
<tref>context</tref> and uses them directly for the <code>url</code> and <code>fn</code>
properties. Also note that the Microformat to JSON-LD processor has
generated the proper URL type for <code>http://tantek.com/</code>.</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context":
  {
    "vcard": "http://microformats.org/profile/hcard#vcard",
    "url":
    {
      "@id": "http://microformats.org/profile/hcard#url",
      "@type": "@id"
    },
    "fn": "http://microformats.org/profile/hcard#fn"
  },
  "@type": "vcard",
  "url": "http://tantek.com/",
  "fn": "Tantek Çelik"
}
-->
</pre>

</section>

<section>
<h3>Microdata</h3>

<p>The microdata example below expresses book information as a microdata Work
item.
</p>

<pre class="example" data-transform="updateExample">
<!--
<dl itemscope
    itemtype="http://purl.org/vocab/frbr/core#Work"
    itemid="http://purl.oreilly.com/works/45U8QJGZSQKDH8N">
 <dt>Title</dt>
 <dd><cite itemprop="http://purl.org/dc/terms/title">Just a Geek</cite></dd>
 <dt>By</dt>
 <dd><span itemprop="http://purl.org/dc/terms/creator">Wil Wheaton</span></dd>
 <dt>Format</dt>
 <dd itemprop="http://purl.org/vocab/frbr/core#realization"
     itemscope
     itemtype="http://purl.org/vocab/frbr/core#Expression"
     itemid="http://purl.oreilly.com/products/9780596007683.BOOK">
  <link itemprop="http://purl.org/dc/terms/type" href="http://purl.oreilly.com/product-types/BOOK">
  Print
 </dd>
 <dd itemprop="http://purl.org/vocab/frbr/core#realization"
     itemscope
     itemtype="http://purl.org/vocab/frbr/core#Expression"
     itemid="http://purl.oreilly.com/products/9780596802189.EBOOK">
  <link itemprop="http://purl.org/dc/terms/type" href="http://purl.oreilly.com/product-types/EBOOK">
  Ebook
 </dd>
</dl>
-->
</pre>

<p>Note that the JSON-LD representation of the Microdata information stays
true to the desires of the Microdata community to avoid contexts and
instead refer to items by their full <tref>IRI</tref>.</p>

<pre class="example" data-transform="updateExample">
<!--
[
  {
    "@id": "http://purl.oreilly.com/works/45U8QJGZSQKDH8N",
    "@type": "http://purl.org/vocab/frbr/core#Work",
    "http://purl.org/dc/terms/title": "Just a Geek",
    "http://purl.org/dc/terms/creator": "Whil Wheaton",
    "http://purl.org/vocab/frbr/core#realization":
    [
      "http://purl.oreilly.com/products/9780596007683.BOOK",
      "http://purl.oreilly.com/products/9780596802189.EBOOK"
    ]
  },
  {
    "@id": "http://purl.oreilly.com/products/9780596007683.BOOK",
    "@type": "http://purl.org/vocab/frbr/core#Expression",
    "http://purl.org/dc/terms/type": "http://purl.oreilly.com/product-types/BOOK"
  },
  {
    "@id": "http://purl.oreilly.com/products/9780596802189.EBOOK",
    "@type": "http://purl.org/vocab/frbr/core#Expression",
    "http://purl.org/dc/terms/type": "http://purl.oreilly.com/product-types/EBOOK"
  }
]
-->
</pre>
</section>
</section>

<section class="appendix informative">
<h1>IANA Considerations</h1>

<p>This section is included merely for standards community review and will be
submitted to the Internet Engineering Steering Group if this specification
becomes a W3C Recommendation.</p>

<h3>application/ld+json</h3>
<dl>
  <dt>Type name:</dt>
  <dd>application</dd>
  <dt>Subtype name:</dt>
  <dd>ld+json</dd>
  <dt>Required parameters:</dt>
  <dd>None</dd>
  <dt>Optional parameters:</dt>
  <dd>
    <dl>
      <dt><code>form</code></dt>
      <dd>Determines the serialization form for the JSON-LD document. The only
        valid value at the moment is <code>expanded</code>. If no form is
        specified in an HTTP request header to an HTTP server, the server MAY
        choose any form. If no form is specified in an HTTP response, the form
        MUST NOT be assumed to take any particular form.</dd>
    </dl>
  </dd>
  <dt>Encoding considerations:</dt>
  <dd>The same as the <code>application/json</code> MIME media type.</dd>
  <dt>Security considerations:</dt>
  <dd>Since JSON-LD is intended to be a pure data exchange format for
    directed graphs, the serialization SHOULD NOT be passed through a
    code execution mechanism such as JavaScript's <code>eval()</code>
    function. It is RECOMMENDED that a conforming parser does not attempt to
    directly evaluate the JSON-LD serialization and instead purely parse the
    input into a language-native data structure. </dd>
  <dt>Interoperability considerations:</dt>
  <dd>Not Applicable</dd>
  <dt>Published specification:</dt>
  <dd>The <a href="http://json-ld.org/spec/latest/">JSON-LD</a> specification.</dd>
  <dt>Applications that use this media type:</dt>
  <dd>Any programming environment that requires the exchange of
    directed graphs. Implementations of JSON-LD have been created for
    JavaScript, Python, Ruby, PHP and C++.
  </dd>
  <dt>Additional information:</dt>
  <dd>
    <dl>
      <dt>Magic number(s):</dt>
      <dd>Not Applicable</dd>
      <dt>File extension(s):</dt>
      <dd>.jsonld</dd>
      <dt>Macintosh file type code(s):</dt>
      <dd>TEXT</dd>
    </dl>
  </dd>
  <dt>Person &amp; email address to contact for further information:</dt>
  <dd>Manu Sporny &lt;msporny@digitalbazaar.com&gt;</dd>
  <dt>Intended usage:</dt>
  <dd>Common</dd>
  <dt>Restrictions on usage:</dt>
  <dd>None</dd>
  <dt>Author(s):</dt>
  <dd>Manu Sporny, Gregg Kellogg, Markus Lanthaler, Dave Longley</dd>
  <dt>Change controller:</dt>
  <dd>W3C</dd>
</dl>

<p>Fragment identifiers used with <a href="#application-ld-json">application/ld+json</a>
  resources MAY identify a node in the <tref>linked data graph</tref> expressed in
  the resource. This idiom, which is also used in RDF [[RDF-CONCEPTS]], gives a
  simple way to "mint" new, document-local IRIs to label nodes and therefore contributes
  considerably to the expressive power of JSON-LD.</p>

</section>

<section class="appendix informative">
<h1>Acknowledgements</h1>

<p>A large amount of thanks goes out to the JSON-LD Community Group
participants who worked through many of the technical issues on the mailing
list and the weekly telecons - of special mention are Niklas Lindström,
François Daoust, and Zdenko 'Denny' Vrandečić.
The editors would like to thank Mark Birbeck, who provided a great deal of
the initial push behind the JSON-LD work via his work on RDFj.
The work of Dave Lehn and Mike Johnson are appreciated for reviewing,
and performing several implementations of the specification. Ian Davis is
thanked for this work on RDF/JSON. Thanks also to Nathan Rixham,
Bradley P. Allen,
Kingsley Idehen, Glenn McDonald, Alexandre Passant, Danny Ayers, Ted
Thibodeau Jr., Olivier Grisel, Josh Mandel, Eric Prud'hommeaux,
David Wood, Guus Schreiber, Pat Hayes, Sandro Hawke, and Richard
Cyganiak for their input on the specification.
</p>
</section>

</body>
</html>
