<!DOCTYPE html>
<html>
<head>
<title>The JSON-LD API 1.0</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<!--
  === NOTA BENE ===
  For the three scripts below, if your spec resides on dev.w3 you can check them
  out in the same tree and use relative links so that they'll work offline,
  -->
<script type="text/javascript"
  src="http://dev.w3.org/2009/dap/ReSpec.js/js/respec.js" class="remove">
 </script>
<script type="text/javascript" class="remove">
//<![CDATA[
    var preProc = {
          apply:  function(c) {
                    // extend the bibliography entries
                    berjon.biblio["MICRODATA"] = "Ian Hickson; et al. <a href=\"http://www.w3.org/TR/microdata/\"><cite>Microdata</cite></a> 04 March 2010. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/microdata/\">http://www.w3.org/TR/microdata/</a> ";
                    berjon.biblio["HTML-RDFA"] = "Manu Sporny; et al. <a href=\"http://www.w3.org/TR/rdfa-in-html/\"><cite>HTML+RDFa</cite></a> 04 March 2010. W3C Working Draft. URL: <a href=\"http://www.w3.org/TR/rdfa-in-html/\">http://www.w3.org/TR/rdfa-in-html/</a> ";
                    berjon.biblio["BCP47"] = "A. Phillips, M. Davis. <a href=\"http://tools.ietf.org/rfc/bcp/bcp47.txt\"><cite>Tags for Identifying Languages</cite></a> September 2009. IETF Best Current Practice. URL: <a href=\"http://tools.ietf.org/rfc/bcp/bcp47.txt\">http://tools.ietf.org/rfc/bcp/bcp47.txt</a>";
                    berjon.biblio["JSON-LD"] = "Manu Sporny, Gregg Kellogg. <a href=\"http://json-ld.org/spec/latest/json-ld-syntax/\"><cite>The JSON-LD Syntax</cite></a> Latest. W3C Editor's Draft. URL: <a href=\"http://json-ld.org/spec/latest/json-ld-syntax/\">http://json-ld.org/spec/latest/json-ld-syntax/</a>";
                    berjon.biblio["RDF-API"] = "Manu Sporny, Benjamin Adrian, Nathan Rixham; et al. <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-api/\"><cite>RDF API</cite></a> Latest. W3C Editor's Draft. URL: <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-api/\">http://www.w3.org/2010/02/rdfa/sources/rdf-api/</a>";
                    berjon.biblio["RDF-INTERFACES"] = "Nathan Rixham, Manu Sporny, Benjamin Adrian; et al. <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/\"><cite>RDF Interfaces</cite></a> Latest. W3C Editor's Draft. URL: <a href=\"http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/\">http://www.w3.org/2010/02/rdfa/sources/rdf-interfaces/</a>";
                    berjon.biblio["JSON-POINTER"] = "P. Bryan, Ed. <cite><a href=\"http://www.ietf.org/id/draft-pbryan-zyp-json-pointer-01.txt\">JSON Pointer</a></cite> Latest. IETF Draft. URL: <a href=\"http://www.ietf.org/id/draft-pbryan-zyp-json-pointer-01.txt\">http://www.ietf.org/id/draft-pbryan-zyp-json-pointer-01.txt</a>";
                    berjon.biblio["RDF-NORMALIZATION"] = "Manu Sporny, Dave Longley. <a href=\"http://json-ld.org/spec/latest/rdf-graph-normalization/\"><cite>RDF Graph Normalization</cite></a> Latest. W3C Editor's Draft. URL: <a href=\"http://json-ld.org/spec/latest/rdf-graph-normalization/\">http://json-ld.org/spec/latest/rdf-graph-normalization/</a>";
                    berjon.biblio["IEEE-754-1985"] = "IEEE. <cite>IEEE Standard for Binary Floating-Point Arithmetic.</cite> See <a href=\"http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html\">http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html</a>";

                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local datatype references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'datatype';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // external datatype references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    var tdefs = [];
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( tdefs[ref]) {
                          throw "Duplicate definition of term '" + ref + "'" ;
                        }

                        var sp = document.createElement( 'dfn' ) ;
                        tdefs[ref] = sp ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( !tdefs[ref]) {
                          throw "Reference to undefined term '" + ref + "'" ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;


      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "unofficial",
          //publishDate:          "2010-04-29",
          copyrightStart:       "2010",

          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "json-ld-api",
          subtitle:             "An Application Programming Interface for the JSON-LD Syntax",
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2011-10-23",
          previousMaturity:     "ED",
          previousDiffURI:      "http://json-ld.org/spec/ED/json-ld-api/20111023/index.html",
          diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://json-ld.org/spec/latest/json-ld-api/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          extraCSS: [
              "http://dev.w3.org/2009/dap/ReSpec.js/css/respec.css",
              "spec.css"
          ],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", url: "http://manu.sporny.org/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
              { name: "Dave Longley", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"}
          ],

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          authors:  [
              { name: "Dave Longley", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
          ],

          // name of the WG
          wg:           "Linking Data in JSON Community Group",

          // URI of the public WG page
          wgURI:        "http://json-ld.org/",

          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-linked-json@w3c.org",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          maxTocLevel: 4,
          preProcess: [ preProc ],
          alternateFormats: [ {uri: "diff-20111023.html", label: "diff to previous version"} ],
      };

      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = doc._esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="diff">$1</span>') ;
        return content ;
      }

      function updateDTD(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/!ENTITY % ([^ \t\r\n]*)/g, '!ENTITY <span class="entity">% $1</span>');
        content = content.replace(/!ELEMENT ([^ \t$]*)/mg, '!ELEMENT <span class="element">$1</span>');
        return content;
      }

      function updateSchema(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="dtd">' + doc._esc(content) + '</pre>';
        content = content.replace(/&lt;xs:element\s+name=&quot;([^&]*)&quot;/g, '&lt;xs:element name="<span class="element" id="schema_element_$1">$1</span>"') ;
        return content;
      }

      function updateTTL(doc, content) {
        // perform transformations to
        // make it render and prettier
        content = '<pre class="sh_sourceCode">' + doc._esc(content) + '</pre>';
        content = content.replace(/@prefix/g, '<span class="sh_keyword">@prefix</span>');
        return content;
      }
//]]>
  </script>
<style>
.diff { font-weight:bold; color:#0a3; }
ol.algorithm.update { margin-left: 2em; }
ol.algorithm.update>li { list-style-type: none; }
ol.algorithm.update>li>span.list-number {
  display:block;
  float: left;
  margin-left: -3.5em;
}
</style>
</head>

<body>
<section id="abstract">
<p>
JSON [[!RFC4627]] has proven to be a highly useful object serialization and
messaging format. JSON-LD [[!JSON-LD]] harmonizes the representation of
Linked Data in JSON by outlining a common JSON representation format for
expressing directed graphs; mixing both Linked Data and non-Linked Data in
a single document. This document outlines an Application Programming
Interface and a set of algorithms for programmatically transforming
JSON-LD documents.
</p>
</section>

<section id='sotd'>
<p>This document is an experimental work in progress.</p>
<!-- <p>
This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from another
document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This
enhances the functionality and interoperability of the Web.
</p> -->
</section>

<section>
<h1>Introduction</h1>

<p>
JSON, as specified in [[!RFC4627]], is a simple language for representing
data on the Web. Linked Data is a technique for creating a graph of interlinked data across
different
documents or Web sites. Data entities are described using <tref>IRI</tref>s,
which are typically dereferencable and thus may be used to find more
information about an entity, creating a "Web of Knowledge". JSON-LD is intended to be a simple
publishing method for expressing not only Linked Data in JSON, but also for adding
semantics to existing JSON.
</p>

<p>
JSON-LD is designed as a light-weight syntax that can be used to express
Linked Data. It is primarily intended to be a way to use Linked Data
in Javascript and other Web-based programming environments. It is also
useful when building interoperable Web services and when storing Linked
Data in JSON-based document storage engines. It is practical and designed
to be as simple as possible, utilizing the large number of JSON parsers
and libraries available today. It is designed to be able to
express key-value pairs, RDF data, RDFa [[RDFA-CORE]] data, Microformats
[[MICROFORMATS]] data, and Microdata [[MICRODATA]]. That is, it supports
every major Web-based structured data model in use today.
</p>

<p>
The syntax does not necessarily require applications to change their JSON, but
allows to easily add meaning by adding context in a way that is either in-band or
out-of-band. The syntax is designed to not disturb already deployed systems
running on JSON, but provide a smooth upgrade path from JSON to JSON with
added semantics. Finally, the format is intended to be easy to parse, efficient to
generate, convertible to RDF in one pass, and require a very small memory footprint
in order to operate.
</p>

<section>
<h2>How to Read this Document</h2>

<p>
This document is a detailed specification for a serialization of Linked
Data in JSON. The document is primarily intended for the following audiences:
</p>

<ul>
  <li>Authors that want a very detailed view of how JSON-LD processors
  operate.</li>
  <li>Software developers that want to implement processors and APIs for
  JSON-LD.</li>
</ul>

<p>
To understand the basics in this specification you must first be familiar with
JSON, which is detailed in [[!RFC4627]]. You must also understand the
JSON-LD Syntax [[!JSON-LD]], which is the base syntax used by all of the
algorithms in this document. To understand the API and how it is
intended to operate  in a programming environment, it is useful to have working
knowledge of the JavaScript programming language [[ECMA-262]] and
WebIDL [[!WEBIDL]]. To understand how JSON-LD maps to RDF, it is helpful to be
familiar with the basic RDF concepts [[!RDF-CONCEPTS]].</p>

<p>
  Examples may contain references to existing vocabularies and use <tref>prefix</tref>es to refer to vocabularies. The following is a list of all vocabularies and their <tref>prefix</tref> abbreviations, as used in this document:
</p>
<ul>
  <li>The <a href="http://purl.org/dc/terms/">Dublin Core</a>
  vocabulary (abbreviation: <code>dc</code>, e.g., <code>dc:title</code>)</li>
  <li>The <a href="http://xmlns.com/foaf/0.1/">Friend of a Friend</a>
  vocabulary (abbreviation: <code>foaf</code>, e.g., <code>foaf:knows</code>)</li>
  <li>The <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">RDF</a>
  vocabulary (abbreviation: <code>rdf</code>, e.g., <code>rdf:type</code>)</li>
  <li>The <a href="http://www.w3.org/2001/XMLSchema#">XSD</a>
  vocabulary (abbreviation: <code>xsd</code>, e.g., <code>xsd:integer</code>)</li>
</ul>

<p>
  JSON [[RFC4627]] defines several terms which are used throughout this document:
  <dl>
    <dt><tdef>JSON Object</tdef></dt><dd>
      An object structure is represented as a pair of curly brackets surrounding zero or
      more name/value pairs (or members). A name is a <tref>string</tref>. A single colon comes after
      each name, separating the name from the value. A single comma separates a value
      from a following name. The names within an object SHOULD be unique.
    </dd>
    <dt><tdef>array</tdef></dt>
    <dd>
      An array is an ordered collection of values. An array structure is represented as square brackets surrounding zero or more values (or elements). Elements are separated by commas.  Within JSON-LD, array order is not preserved by default, unless
      specific markup is provided (see <a href="#lists">Lists</a>). This is because the basic data model of JSON-LD
      is a <tref>linked data graph</tref>, which is inherently unordered.
    </dd>
    <dt><tdef>string</tdef></dt><dd>
      A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A
      character is represented as a single character string.
    </dd>
    <dt><tdef>number</tdef></dt>
    <dd>
      A number is is similar to that used in most programming languages, except that the octal and hexadecimal formats are not used and that leading zeros are not allowed.</dd>
    <dt><tdef>true</tdef> and <tdef>false</tdef></dt><dd>
      Boolean values.
    </dd>
    <dt><tdef>null</tdef></dt><dd>
      The use of the <tref>null</tref> value within JSON-LD is used to ignore or reset values.
  </dl>
</p>
</section>

<section>
<h2>Linked Data</h2>
<p>
The following definition for <tref>Linked Data</tref> is the one that will
be used for this specification.
</p>
<ol>
  <li><tdef>Linked Data</tdef> is a set of documents, each containing a representation of a linked data graph.</li>
  <li>A <tdef>linked data graph</tdef> is an unordered labeled directed graph, where nodes are <tref>subject</tref>s or <tref>object</tref>s, and edges are properties.</li>
  <li>A <tdef>subject</tdef> is any node in a <tref>linked data graph</tref> with at least one outgoing edge.</li>
  <li>A <tref>subject</tref> SHOULD be labeled with an <tref>IRI</tref> (an Internationalized Resource Identifier as described in [[!RFC3987]]).</li>
  <li>An <tdef>object</tdef> is a node in a <tref>linked data graph</tref> with at least one incoming edge.</li>
  <li>An <tref>object</tref> MAY be labeled with an <tref>IRI</tref>.</li>
  <li>An object MAY be a <tref>subject</tref> and <tref>object</tref> at the same time.</li>
  <li>A <tdef>property</tdef> is an edge of the <tref>linked data graph</tref>.</li>
  <li>A <tref>property</tref> SHOULD be labeled with an <tref>IRI</tref>.</li>
  <li>An <tref>IRI</tref> that is a label in a <tref>linked data graph</tref> SHOULD be dereferencable to a <tref>Linked Data</tref> document describing the labeled <tref>subject</tref>, <tref>object</tref> or <tref>property</tref>.</li>
  <li>A <tdef>literal</tdef> is an <tref>object</tref> with a label that is not an <tref>IRI</tref></li>
</ol>

<p>
Note that the definition for <tref>Linked Data</tref> above is silent on the
topic of unlabeled nodes. Unlabeled nodes are not considered
<tref>Linked Data</tref>. However, this specification allows for the expression
of unlabled nodes, as most graph-based data sets on the Web contain a number
of associated nodes that are not named and thus are not directly
de-referenceable.
</p>
</section>

<section>
  <h2>Contributing</h2>

  <p>There are a number of ways that one may participate in the development of
    this specification:</p>

  <ul>
    <li>Technical discussion typically occurs on the public mailing list:
      <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

    <li><a href="http://json-ld.org/minutes/">Public teleconferences</a> are held
      on Tuesdays at 1500UTC on the second and fourth week of each month.</li>

    <li>Specification bugs and issues should be reported in the
      <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>.</li>

    <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a> for the
      specification can be found on Github.</li>

    <li>The <a href="http://webchat.freenode.net/?channels=#json-ld">#json-ld</a>
      IRC channel is available for real-time discussion on irc.freenode.net.</li>
  </ul>

</section>

</section>

<section>
  <h2>The Application Programming Interface</h2>

  <p>This API provides a clean mechanism that enables developers to convert
  JSON-LD data into a a variety of output formats that are easier to work with in
  various programming languages. If a JSON-LD API is provided in a programming
  environment, the entirety of the following API MUST be implemented.
  </p>

  <section>
    <h3>JsonLdProcessor</h3>
    <dl title="[NoInterfaceObject] interface JsonLdProcessor" class="idl">

      <dt>object expand()</dt>
      <dd><a href="#expansion">Expands</a> the given <code>input</code>
        according to the steps in the
        <a href="#expansion-algorithm">Expansion Algorithm</a>. The
        <code>input</code> MUST be copied, expanded and returned if there are
        no errors. If the expansion fails, an appropriate exception MUST be thrown.

        <dl class="parameters">
         <dt>object input</dt>
         <dd>The JSON-LD object to copy and perform the expansion upon.</dd>
         <dt>object optional? context</dt>
         <dd>An external context to use additionally to the context embedded in <code>input</code> when expanding the <code>input</code>.</dd>
        </dl>

        <dl class="exception" title="InvalidContext">
         <dt>INVALID_SYNTAX</dt>
         <dd>A general syntax error was detected in the <code>@context</code>.
         For example, if a <code>@type</code> key maps to anything other than
         <code>@id</code> or an <tref>absolute IRI</tref>, this exception would be raised.</dd>
         <dt>LOAD_ERROR</dt>
         <dd>There was a problem encountered loading a remote context.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>

      </dd>

      <dt>object compact()</dt>
      <dd><a href="#compaction">Compacts</a> the given <code>input</code>
        using the <code>context</code> according to the steps in the
        <a href="#compaction-algorithm">Compaction Algorithm</a>. The
        <code>input</code> MUST be copied, compacted and returned if there are
        no errors. If the compaction fails, an appropirate exception MUST be
        thrown.
        <dl class="parameters">
           <dt>object input</dt>
           <dd>The JSON-LD object to perform compaction on.</dd>
           <dt>object? context</dt>
           <dd>The context to use when compacting the <code>input</code>.</dd>
           <dt>boolean optional optimize</dt>
           <dd>If set to <code>true</code>, the JSON-LD processor is allowed
           optimize the output of the <a href="#compaction-algorithm">Compaction Algorithm</a>
           to produce even compacter representations. The algorithm for compaction
           optimization is beyond the scope of this specification and thus
           not defined. Consequently, different implementations MAY implement
           different optimization algorithms.</dd>
        </dl>

        <dl class="exception" title="InvalidContext">
          <dt>INVALID_SYNTAX</dt>
          <dd>A general syntax error was detected in the <code>@context</code>.
            For example, if a <code>@type</code> key maps to anything other than
            <code>@id</code> or an <tref>absolute IRI</tref>, this exception would be raised.</dd>
          <dt>LOAD_ERROR</dt>
          <dd>There was a problem encountered loading a remote context.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LOSSY_COMPACTION</dt>
          <dd>The compaction would lead to a loss of information, such as a
            <code>@language</code> value.</dd>
          <dt>CONFLICTING_DATATYPES</dt>
          <dd>The target datatype specified in the coercion rule and the
            datatype for the typed literal do not match.</dd>
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>

      </dd>

      <dt>object frame()</dt>
      <dd><a href="#framing">Frames</a> the given <code>input</code>
        using the <code>frame</code> according to the steps in the
        <a href="#framing-algorithm">Framing Algorithm</a>. The
        <code>input</code> is used to build the framed output and is returned if
        there are no errors. If there are no matches for the frame,
        <tref>null</tref> MUST be returned. Exceptions MUST be thrown if there are
        errors.
        <dl class="parameters">
           <dt>object input</dt>
           <dd>The JSON-LD object to perform framing on.</dd>
           <dt>object frame</dt>
           <dd>The frame to use when re-arranging the data.</dd>
           <dt>object options</dt>
           <dd>A set of options that will affect the framing algorithm.</dd>
        </dl>

        <dl class="exception" title="InvalidFrame">
          <dt>INVALID_SYNTAX</dt>
          <dd>A frame must be either an object or an array of objects, if the frame
            is neither of these types, this exception is thrown.</dd>
          <dt>MULTIPLE_EMBEDS</dt>
          <dd>A subject IRI was specified in more than one place in the input
            frame. More than one embed of a given subject IRI is not allowed, and if
            requested, MUST result in this exception.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>

      </dd>

      <dt>DOMString normalize()</dt>
      <dd><a href="#normalization">Normalizes</a> the given <code>input</code>
        according to the steps in the
        <a href="#normalization-algorithm">Normalization Algorithm</a>. The
        <code>input</code> MUST be copied, normalized and returned if there are
        no errors. If the compaction fails, <tref>null</tref> MUST be returned.
        The output is the serialized representation returned from the
        <a href="#normalization-algorithm">Normalization Algorithm</a>.
        <span class="issue">It's still an open question if the result is a DOMString
          representing the serialized graph in JSON-LD, or an <tref>array</tref> representation
          which is in normalized form.</span>
        <dl class="parameters">
          <dt>object input</dt>
          <dd>The JSON-LD object to perform normalization upon.</dd>
          <dt>object optional? context</dt>
          <dd>An external context to use additionally to the context embedded in
            <code>input</code> when expanding the <code>input</code>.</dd>
        </dl>

        <dl class="exception" title="InvalidContext">
          <dt>INVALID_SYNTAX</dt>
          <dd>A general syntax error was detected in the <code>@context</code>.
            For example, if a <code>@type</code> key maps to anything other than
            <code>@id</code> or an <tref>absolute IRI</tref>, this exception would be raised.</dd>
          <dt>LOAD_ERROR</dt>
          <dd>There was a problem encountered loading a remote context.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>

      </dd>

      <dt>void triples()</dt>
      <dd>Processes the <code>input</code> according to the
        <a href="#rdf-conversion-algorithm">RDF Conversion Algorithm</a>, calling
        the provided <code>tripleCallback</code> for each triple generated.
        <dl class="parameters">
          <dt>object input</dt>
          <dd>The JSON-LD object to process when outputting triples.</dd>
          <dt>JsonLdTripleCallback tripleCallback</dt>
          <dd>A callback that is called whenever a processing error occurs on
          the given <code>input</code>.
          <div class="issue">This callback should be aligned with the
            RDF API.</div></dd>
          <dt>object optional? context</dt>
          <dd>An external context to use additionally to the context embedded in
            <code>input</code> when expanding the <code>input</code>.</dd>
        </dl>

        <dl class="exception" title="InvalidContext">
          <dt>INVALID_SYNTAX</dt>
          <dd>A general syntax error was detected in the <code>@context</code>.
            For example, if a <code>@type</code> key maps to anything other than
            <code>@id</code> or an <tref>absolute IRI</tref>, this exception would be raised.</dd>
          <dt>LOAD_ERROR</dt>
          <dd>There was a problem encountered loading a remote context.</dd>
        </dl>

        <dl class="exception" title="ProcessingError">
          <dt>LIST_OF_LISTS_DETECTED</dt>
          <dd>A list of lists was detected. This is not supported in this
            version of JSON-LD.</dd>
        </dl>

      </dd>

    </dl>

  </section>

  <section>
    <h3>JsonLdTripleCallback</h3>
    <p>The JsonLdTripleCallback is called whenever the processor generates a
    triple during the <code>triple()</code> call.</p>

    <dl title="[NoInterfaceObject Callback] interface JsonLdTripleCallback"
        class="idl">

      <dt>void triple()</dt>
      <dd>This callback is invoked whenever a triple is generated by the processor.
      <dl class="parameters">
         <dt>DOMString subject</dt>
         <dd>The subject <tref>IRI</tref> that is associated with the triple.</dd>
         <dt>DOMString property</dt>
         <dd>The property <tref>IRI</tref> that is associated with the triple.</dd>
         <dt>DOMString objectType</dt>
         <dd>The type of object that is associated with the triple. Valid values
           are <code>IRI</code> and <code>literal</code>.</dd>
         <dt>DOMString object</dt>
         <dd>The object value associated with the subject and the property.</dd>
         <dt>DOMString? datatype</dt>
         <dd>The datatype associated with the object.</dd>
         <dt>DOMString? language</dt>
         <dd>The language associated with the object in BCP47 format.</dd>
      </dl>
      </dd>
    </dl>
  </section>

</section>

<section>
<h1>Algorithms</h1>

<p>All algorithms described in this section are intended to operate on
language-native data structures. That is, the serialization to a text-based
JSON document isn't required as input or output to any of these algorithms and
language-native data structures MUST be used where applicable.</p>

<section>
  <h2>Syntax Tokens and Keywords</h2>

  <p>JSON-LD specifies a number of syntax tokens and <tdef>keyword</tdef>s that are using
  in all algorithms described in this section:</p>

  <dl>
  <dt><code>@context</code></dt><dd>Used to set the <tref>local context</tref>.</dd>
  <dt><code>@id</code></dt><dd>Sets the active subject.</dd>
  <dt><code>@language</code></dt><dd>Used to specify the language for a literal.</dd>
  <dt><code>@type</code></dt><dd>Used to set the type of the active subject or the datatype of a literal.</dd>
  <dt><code>@value</code></dt><dd>Used to specify the value of a literal.</dd>
  <dt><code>@container</code></dt><dd>Used to set the container of a particular value.</dd>
  <dt><code>@list</code></dt><dd>Used to express an ordered set of data.</dd>
  <dt><code>@set</code></dt><dd>Used to express an unordered set of data.</dd>
  <dt><code>:</code></dt><dd>The separator for JSON keys and values that use <tref title="compact_iri">compact IRIs</tref>.</dd>
  </dl>

  <p>All JSON-LD tokens and keywords are case-sensitive.</p>
</section>

<section>
  <h2>Algorithm Terms</h2>
  <dl>
    <dt><tdef>initial context</tdef></dt>
    <dd>
      a context that is specified to the algorithm before processing begins. The contents of the
      initial context is defined in <a href="#appendix-b">Appendix B</a>.
    </dd>
    <dt><tdef>active subject</tdef></dt>
    <dd>
      the currently active subject that the processor should use when
      processing.
    </dd>
    <dt><tdef>active property</tdef></dt>
    <dd>
      the currently active property that the processor should use when
      processing.
    </dd>
    <dt><tdef>active object</tdef></dt>
    <dd>
      the currently active object that the processor should use when
      processing.
    </dd>
    <dt><tdef>active context</tdef></dt>
    <dd>
      a context that is used to resolve <tref>term</tref>s while the processing
      algorithm is running. The <tref>active context</tref> is the context
      contained within the <tref>processor state</tref>.
    </dd>
    <dt><tdef>blank node</tdef></dt>
    <dd>
      a blank node is a <tref>resource</tref> which is neither an <tref>IRI</tref> nor a <tref>literal</tref>.
      Blank nodes may be named or unnamed and often take on the role of a variable that may represent
      either an <tref>IRI</tref> or a <tref>literal</tref>.
    </dd>
    <dt><tdef>compact IRI</tdef></dt>
    <dd>
      a compact IRI is has the form of <tref>prefix</tref> and <em>suffix</em> and is used as a way
      of expressing an IRI without needing to define separate <tref>term</tref> definitions for
      each IRI contained within a common vocabulary identified by <tref>prefix</tref>.
    </dd>
    <dt><tdef>local context</tdef></dt>
    <dd>
      a context that is specified within a <tref>JSON object</tref>,
      specified via the <code>@context</code> <tref>keyword</tref>.
    </dd>
    <dt><tdef>processor state</tdef></dt>
    <dd>
      the <tref>processor state</tref>, which includes the <tref>active
      context</tref>, <tref>active subject</tref>, and
      <tref>active property</tref>. The <tref>processor state</tref> is managed
      as a stack with elements from the previous <tref>processor state</tref>
      copied into a new <tref>processor state</tref> when entering a new
      <tref>JSON object</tref>.
    </dd>
    <dt><tdef>JSON-LD input</tdef></dt>
    <dd>
      The JSON-LD data structure that is provided as input to the algorithm.
    </dd>
    <dt><tdef>JSON-LD output</tdef></dt>
    <dd>
      The JSON-LD data structure that is produced as output by the algorithm.
    </dd>
    <dt><tdef>term</tdef></dt><dd>
      A <tref>term</tref> is a short word defined with a <a href="#context">context</a> that MAY be expanded
    to an <tref>IRI</tref>
    </dd>
    <dt><tdef>prefix</tdef></dt><dd>
      A <tref>prefix</tref> is a <tref>term</tref> that expands to a vocabulary base IRI. It
      is typically used along with a <em>suffix</em> to form a <tref>compact IRI</tref> to create an IRI
      within a vocabulary.
    </dd>
    <dt><tdef>plain literal</tdef></dt><dd>
      A <tref>plain literal</tref> is a <tref>literal</tref> without a datatype, possibly including
      a language.
    </dd>
    <dt><tdef>typed literal</tdef></dt><dd>
      A <tref>typed literal</tref> is a <tref>literal</tref> with an associated <tref>IRI</tref>
      which indicates the literal's datatype.
    </dd>
  </dl>
</section>

<section>
  <h2 id="context">Context</h2>
  <p>Processing of JSON-LD data structure is managed recursively.
    During processing, each rule is applied using information provided by the <tref>active context</tref>.
    Processing begins by pushing a new <tref>processor state</tref> onto the <tref>processor state</tref> stack and
    initializing the <tref>active context</tref> with the <tref>initial context</tref>.
    If a <tref>local context</tref> is encountered,
    information from the <tref>local context</tref> is merged into the <tref>active context</tref>.</p>
  <p>The <tref>active context</tref> is used for expanding keys and values of a <tref>JSON object</tref> (or elements
    of a list (see <span a="#list-processing">List Processing</span>)) using a <tdef>term mapping</tdef>.
    It is also used to maintain
    <tdef>coercion mapping</tdef>s from terms to datatypes, <tdef>language mapping</tdef>s from terms to language codes,
    and <tdef>list mapping</tdef>s and <tdef>set mapping</tdef>s for terms.</p>
  <p>A <tref>local context</tref> is identified within a <tref>JSON object</tref> having a key of
    <code>@context</code> with <tref>string</tref>, <tref>array</tref> or a <tref>JSON object</tref> value.
    When processing a <tref>local context</tref>, special processing rules apply:</p>
  <ol class="algorithm">
    <li>Create a new, empty <tref>local context</tref>.</li>
    <li>Let <em>value</em> be the value of <code>@context</code>
      <ol id="process-context" class="algorithm">
        <li>If <em>value</em> equals <tref>null</tref>, reset the <tref>active context</tref> to the <tref>initial context</tref></li>
        <li>If <em>value</em> is an <tref>array</tref>, process
          each element as <em>value</em>, in order using <a href="#process-context">Step 2</a>.</li>
        <li>If <em>value</em> is a simple <tref>string</tref>, it MUST have a lexical form of <tref>absolute IRI</tref>.
          <ol class="algorithm">
            <li>Dereference <em>value</em>.</li>
            <li>If the resulting document is a JSON document, extract the top-level <code>@context</code>
              element using the JSON Pointer "/@context" as described in [[!JSON-POINTER]]. Set <em>value</em>
              to the extracted content, or an empty <tref>JSON Object</tref> if no value exists.</li>
            <li>Merge the of <tref>local context</tref> into the <tref>active context</tref>.</li>
          </ol>
        </li>
        <li>If <em>value</em> is a <tref>JSON object</tref>, perform the following steps:
          <ol class="algorithm">
            <li>If <em>value</em> has a <code>@language</code> key, it MUST have a value of a
              simple <tref>string</tref> or <tref>null</tref>. Add the language to the <tref>local context</tref>.</li>
            <li id="object-context">Otherwise, for each key in <em>value</em> having the lexical form of an <cite><a
              href="http://www.w3.org/TR/2009/REC-xml-names-20091208/#NT-NCName">NCName</a></cite> (see [[XML-NAMES]]),
              <tref>compact IRI</tref>, absolute <tref>IRI</tref>,
              or being an empty string, perform the following steps:
              <ol class="algorithm">
                <li>If the key's value is a simple <tref>string</tref>, the value MUST have the form of
                  <tref>term</tref>, <tref>compact IRI</tref>, <tref>absolute IRI</tref>. Determine the IRI mapping value by
                  performing <a href="#iri-expansion">IRI Expansion</a> on the associated value. If the result of the IRI
                  mapping is an <tref>absolute IRI</tref>, merge the key-value pair into the <tref>local context</tref>
                  <tref>term mapping</tref>.</li>
                <li>Otherwise, the key's value MUST be a <tref>JSON object</tref>.
                  <ol class="algorithm">
                    <li>If the key has the form of <tref>term</tref>, the value MUST have a <code>@id</code>
                      key with a string value, the value MUST have the
                      form of <tref>term</tref>, <tref>compact IRI</tref>, <tref>absolute IRI</tref>.
                      Determine the IRI mapping value
                      by performing <a href="#iri-expansion">IRI Expansion</a> on the associated value.
                      If the result of the IRI mapping is an <tref>absolute IRI</tref>, merge the
                      key-value pair into the <tref>local context</tref> <tref>term mapping</tref>.</li>
                    <li>If the key has the form of <tref>compact IRI</tref> or <tref>absolute IRI</tref>,
                      the value MAY have a <code>@id</code> key with a string value, this value MUST have the
                      form of <tref>term</tref>, <tref>compact IRI</tref>, absolute <tref>IRI</tref>.
                      Determine the IRI mapping value
                      by performing <a href="#iri-expansion">IRI Expansion</a> on the associated value.
                      If the result of the IRI mapping is an <tref>absolute IRI</tref>, merge the
                      key-value pair into the <tref>local context</tref> <tref>term mapping</tref>.</li>
                    <li>If the value has a <code>@type</code> key, the value MUST have the form of <tref>term</tref>,
                      <tref>compact IRI</tref>, <tref>absolute IRI</tref> or the <tref>keyword</tref> <code>@id</code>. Determine the IRI by
                      performing <a href="#iri-expansion">IRI Expansion</a> on the associated value. If the result of the
                      IRI mapping is an <tref>absolute IRI</tref> or <code>@id</code>, merge into the <tref>local context</tref>
                      <tref>coercion mapping</tref>.</li>
                    <li>If the value has a <code>@container</code> key, the value MUST be
                      <code>@list</code> or <code>@set</code>. Merge the <tref>list mapping</tref> or
                      <tref>set mapping</tref> into the <tref>local context</tref>.</li>
                    <li>If the value has a <code>@language</code> key but no <code>@type</code> key, the value of the
                      <code>@language</code> key MUST be a <tref>string</tref> or <tref>null</tref>.
                      Merge the <tref>language mapping</tref> into the <tref>local context</tref>.</li>
                  </ol>
                </li>
                <li>Merge the <tref>local context</tref> into the <tref>active context</tref>.</li>
                <li>Repeat <a href="#object-context">Step 3.3.2</a> until no entries are added to the <tref>local
                  context</tref>.</li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </li>
  </ol>

  <p class="note">It can be difficult to distinguish between a <tref>compact IRI</tref> and an <tref>absolute IRI</tref>,
    as a <tref>compact IRI</tref> may seem to be a valid IRI <em>scheme</em>. When performing repeated IRI expansion,
    a term used as a prefix may not have a valid mapping due to dependencies in resolving term definitions. By
    continuing <a href="#object-context">Step 2.3.2</a> until no changes are made, mappings to IRIs created
    using an undefined term prefix will eventually resolve to <tref>absolute IRI</tref>s.</p>

  <p class="issue"><a href="https://github.com/json-ld/json-ld.org/issues/43">Issue 43</a>
    concerns performing IRI expansion in the key position of a context definition.</p>
</section>

<section>
  <h2>IRI Expansion</h2>
  <p>Keys and some values are evaluated to produce an <tref>IRI</tref>. This section defines an algorithm for
    transforming a value representing an IRI into an actual IRI.</p>
  <p><tref>IRI</tref>s may be represented as an <tref>absolute IRI</tref>, a <tref>term</tref> or a <tref>compact IRI</tref>.</p>
  <p>An <tdef>absolute IRI</tdef> is defined in [[!RFC3987]] containing a <em>scheme</em> along with
    <em>path</em> and optional <em>query</em> and fragment segments. A <tdef>relative IRI</tdef> is an IRI
    that is relative some other <tref>absolute IRI</tref>; in the case of JSON-LD this is the base location
    of the document.</p>

  <p>The algorithm for generating an IRI is:
    <ol class="algorithm">
      <li>If the <tref>active context</tref> contains a <tref>term</tref> mapping for the value using
        a case-sensitive comparison, use the mapped value as an IRI.</li>
      <li>Otherwise, split the value into a <em>prefix</em> and <em>suffix</em> from the first occurrence of ':'.</li>
      <li>If the prefix is a '_' (underscore), the value represents a named <tref>blank node</tref>.</li>
      <li>If the <tref>active context</tref> contains a <tref>term</tref> mapping for <em>prefix</em> using
        a case-sensitive comparison, generate an <tref>IRI</tref>
        by prepending the mapped prefix to the (possibly empty) suffix using textual concatenation. Note that an empty
        suffix and no suffix (meaning the value contains no ':' string at all) are treated equivalently.</li>
      <li>Otherwise, use the value directly as an IRI.</li>
    </ol>
  </p>
  <p class="note">
    Previous versions of this specification used <code>@base</code> and <code>@vocab</code> to define IRI prefixes
    used to resolve <tref title="relative IRI">relative IRIs</tref>. It was determined that this added too much complexity, but the issue
    can be re-examined in the future based on community input.
  </p>
</section>

<section>
  <h2>IRI Compaction</h2>
  <p>Some keys and values are expressed using <tref>IRI</tref>s. This section defines an
    algorithm for transforming an IRI to a <tref>term</tref> or <tref>compact IRI</tref> using the
    <tref>term</tref>s specified in the <tref>local context</tref>.</p>

  <p>The algorithm for generating a <tref>compact IRI</tref> is:
    <ol class="algorithm">
      <li>Search every key-value pair in the <tref>active context</tref> for
        a <tref>term</tref> that is a complete match
        against the IRI. If a complete match is found, the resulting compacted
        IRI is the <tref>term</tref> associated with the IRI in the
        <tref>active context</tref>.</li>
      <li>If a complete match is not found, search for a partial match from
        the beginning of the IRI. For all matches that are found, the resulting
        <tref>compact IRI</tref> is the <tref>term</tref> associated with the partially matched
        IRI in the <tref>active context</tref> concatenated with a colon (:) character
        and the unmatched part of the string. If there is more than one <tref>compact IRI</tref>
        produced, the final value is the shortest and lexicographically least value of
        the entire set of <tref>compact IRI</tref>s.</li>
    </ol>
  </p>
</section>

<section>
  <h2>Value Expansion</h2>
  <p>Some values in JSON-LD can be expressed in a compact form. These values
    are required to be expanded at times when processing JSON-LD documents.</p>

  <p>The algorithm for expanding a <em>value</em> takes an <tref>active property</tref>
    and <tref>active context</tref>. It is implemented as follows:</p>
  <ol class="algorithm">
    <li>If <em>value</em> is a <tref>number</tref> and the <tref>active property</tref> is the target of typed literal
      coercion to <code>xsd:integer</code> or <code>xsd:double</code>, expand the value into an object with
      two key-value pairs. The first key-value pair will be <code>@value</code> and the string representation of
      <em>value</em> as defined in the section <a href="#data-round-tripping">Data Round Tripping</a>. The second
      key-value pair will be <code>@type</code> and the associated coercion datatype expanded according to the
      <a href="#iri-expansion">IRI Expansion</a> rules.</li>
    <li>Otherwise, if <tref>active property</tref> is the target of an <code>@id</code> coercion, expand the value
      into an object with a key-value pair where the key is <code>@id</code> and the value is the expanded
      IRI according to the <a href="#iri-expansion">IRI Expansion</a> rules.</li>
    <li>Otherwise, if <tref>active property</tref> is the target of typed literal coercion,
      expand <em>value</em> into an object with key-value pairs. The first key-value pair will be <code>@value</code>
      and the unexpanded <em>value</em>. The second key-value pair will be <code>@type</code> and the associated coercion
      datatype expanded according to the <a href="#iri-expansion">IRI Expansion</a> rules.</li>
    <li>Otherwise, if <em>value</em> is a <tref>string</tref> and the <tref>active property</tref> is not the target of
      typed literal coercion but target of language tagging, expand <em>value</em> into an object with two
      key-value pairs. The first key-value pair will be <code>@value</code> and the unexpanded <em>value</em>.
      The second key-value pair will be <code>@language</code> and value of the language tagging from the <tref>active context</tref>.</li>
    <li>Otherwise, <em>value</em> is already expanded.</li>
  </ol>
</section>

<section>
  <h2>Value Compaction</h2>
  <p>Some values, such as IRIs and typed literals, may be expressed in an
    expanded form in JSON-LD. These values are required to be compacted at
    times when processing JSON-LD documents.
  </p>

  <p>The algorithm for compacting an expanded value <em>value</em> takes an <tref>active property</tref>
    and <tref>active context</tref>. It is implemented as follows:</p>
  <ol class="algorithm">
    <li>If the value may be expressed as <tref>true</tref>, <tref>false</tref> or <tref>number</tref>,
      the value is the native representation of the <code>@value</code> value.</li>
    <li>Otherwise, if the <tref>active context</tref> contains a coercion target for the
      key that matches the expression of the value, compact the value using the
      following steps:
      <ol class="algorithm">
        <li>If the coercion target is an <code>@id</code>, the compacted
          value is the value associated with the <code>@id</code> key,
          processed according to the
          <a href="#iri-compaction">IRI Compaction</a> steps.</li>
        <li>If the coercion target is a typed literal, the compacted
          value is the value associated with the <code>@value</code> key.</li>
      </ol>
    </li>
    <li>Otherwise, if <em>value</em> contains an <code>@id</code> key, the compacted value is <em>value</em> with
      the value of <code>@id</code> processed according to the
      <a href="#iri-compaction">IRI Compaction</a> steps.</li>
    <li>Otherwise, if the <tref>active context</tref> contains a <code>@language</code>, which
      matches the <code>@language</code> of the value, or the value has only a <code>@value</code> key, the compacted
      value is the value associated with the <code>@value</code> key.</li>
    <li>Otherwise, if the value contains a <code>@type</code> key, the compacted value
      is <em>value</em> with the <code>@type</code> value processed according to the
      <a href="#iri-compaction">IRI Compaction</a> steps.</li>
    <li>Otherwise, the value is not modified.</li>
  </ol>
</section>

<section>
<h2>Expansion</h2>

<p>Expansion is the process of taking a JSON-LD document and applying a
  context such that all IRI, datatypes, and literal values are expanded so
  that the context is no longer necessary. JSON-LD document expansion
  is typically used as a part of <a href="#framing">Framing</a> or
  <a href="#normalization">Normalization</a>.</p>

<p>For example, assume the following JSON-LD input document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
   "@context":
   {
      "name": "http://xmlns.com/foaf/0.1/name",
      "homepage": {
        "@id": "http://xmlns.com/foaf/0.1/homepage",
        "@type", "@id"
      }
   },
   "name": "Manu Sporny",
   "homepage": "http://manu.sporny.org/"
}
-->
</pre>

<p>Running the JSON-LD Expansion algorithm against the JSON-LD input document
  provided above would result in the following output:</p>

<pre class="example" data-transform="updateExample">
<!--
{
   "http://xmlns.com/foaf/0.1/name": "Manu Sporny",
   "http://xmlns.com/foaf/0.1/homepage": {
      "@id": "http://manu.sporny.org/"
   }
}
-->
</pre>

<section>
<h3>Expansion Algorithm</h3>

<p>The algorithm takes three input variables: an <tref>active context</tref>, an <tref>active property</tref>,
  and a <em>value</em> to be expanded. To begin, the <tref>active context</tref> is set to the <tref>initial
  context</tref>, <tref>active property</tref> is set to <tref>null</tref>, and <em>value</em> is set to the <tref>JSON-LD
  input</tref>.</p>

<ol class="algorithm">
  <li>If <em>value</em> is an <tref>array</tref>, process each item in <em>value</em> recursively
    using this algorithm, passing copies of the <tref>active context</tref> and <tref>active property</tref>.</li>
  <li>Otherwise, if <em>value</em> is an object
    <ol class="algorithm">
      <li>Update the <tref>active context</tref> according to the steps outlined in
      the <a href="#context">context</a> section and remove it from the expanded result.</li>
      <li>For each key and value in <em>value</em>:
        <ol class="algorithm">
          <li>If value is <tref>null</tref>, skip this key/value pair and remove key from <em>value</em></li>
          <li>Otherwise, if value is a <tref>JSON object</tref> having either a <code>@value</code>,
            <code>@list</code>, or <code>@set</code> key with a <tref>null</tref> value, skip this key/value pair
          <li>Otherwise, if <em>value</em> is a <tref>JSON object</tref> having a <code>@set</code> key with a
            non-<tref>null</tref> value, replace <em>value</em> with the value of <code>@set</code>.
          <li>Otherwise, if the key is <code>@id</code> or <code>@type</code> and the value is a <tref>string</tref>,
            expand the value according to <a href="#iri-expansion">IRI Expansion</a>.</li>
            remove key from <em>value</em></li>
          <li>Otherwise, if the key is <code>@value</code>, the value is not subject to further expansion.</li>
          <li>Otherwise, if the key is not a <tref>keyword</tref>, expand the key according to
            <a href="#iri-expansion">IRI Expansion</a> rules and set as <tref>active property</tref>.</li>
          <li>If the value is an <tref>array</tref>, and <tref>active property</tref> is subject to <code>@list</code>
            expansion, replace the value with a new key-value key where the key is <code>@list</code> and value
            set to the current value.</li>
          <li>If the value is an <tref>array</tref>, process each item in the <tref>array</tref>
            recursively using this algorithm, passing copies of the <tref>active context</tref> and <tref>active
            property</tref> removing items which expand to <tref>null</tref>.</li>
          <li>If the value is an object, process the object recursively
            using this algorithm, passing copies of the <tref>active context</tref> and <tref>active
            property</tref>. If <tref>null</tref> is returned, skip this key/value pair and remove
            key from <em>value</em>.</li>
          <li>Otherwise, expand the value according to the <a href="#value-expansion">Value Expansion</a> rules,
            passing <tref>active property</tref>.</li>
        </ol>
      </li>
      <li>Remove the context from the object.</li>
    </ol>
  </li>
  <li>Otherwise, expand <em>value</em> according to the <a href="#value-expansion">Value Expansion</a> rules,
    passing <tref>active property</tref>.</li>
</ol>
</section>

</section>

<section>
<h2>Compaction</h2>

<p>Compaction is the process of taking a JSON-LD document and applying a
  context such that the most compact form of the document is generated. JSON
  is typically expressed in a very compact, key-value format. That is, full
  IRIs are rarely used as keys. At times, a JSON-LD document may be received
  that is not in its most compact form. JSON-LD, via the API, provides a way
  to compact a JSON-LD document.</p>

<p>For example, assume the following JSON-LD input document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "http://xmlns.com/foaf/0.1/name": "Manu Sporny",
  "http://xmlns.com/foaf/0.1/homepage": {
    "@id": "http://manu.sporny.org/"
  }
}
-->
</pre>

<p>Additionally, assume the following developer-supplied JSON-LD context:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
  }
}
-->
</pre>

<p>Running the JSON-LD Compaction algorithm given the context supplied above
  against the JSON-LD input document provided above would result in the following
  output:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    }
  },
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/"
}
-->
</pre>

<p>The compaction algorithm also enables the developer to map any expanded
  format into an application-specific compacted format. While the context
  provided above mapped <code>http://xmlns.com/foaf/0.1/name</code> to
  <strong>name</strong>, it could have also mapped it to any arbitrary string
  provided by the developer.</p>

<section>
<h3>Compaction Algorithm</h3>

<p>The algorithm takes two input variables: an <tref>active property</tref>,
  and a <em>value</em> to be expanded. To begin, the <tref>active property</tref> is set to <tref>null</tref>, and <em>value</em> is
  set to the result of performing the <a href="#expansion-algorithm">Expansion Algorithm</a> on
    the <tref>JSON-LD input</tref>. This removes any existing context to allow the given context to be cleanly
    applied. The <tref>active context</tref> to the given context.</p>


<ol class="algorithm">
  <li>If <em>value</em> is an <tref>array</tref>, process each item in <em>value</em> recursively
    using this algorithm, passing a copy of the <tref>active property</tref>.</li>
  <li>Otherwise, if <em>value</em> is an object, for each key and value in <em>value</em>
    <ol class="algorithm">
      <li>If the key is <code>@id</code> or <code>@type</code>
        <ol class="algorithm">
          <li>If the value of the key is a <tref>string</tref>,
            the compacted value is the result of performing <a href="#iri-compaction">IRI Compaction</a>
            on the value.</li>
          <li>Otherwise, the compacted value is the result of performing this algorithm on the value
            with the current <tref>active property</tref>.</li>
        </ol>
      </li>
      <li>Otherwise:
        <ol class="algorithm">
          <li>If the key is not a <tref>keyword</tref>, set as <tref>active property</tref> and
            compact according to <a href="#iri-compaction">IRI Compaction</a>.</li>
          <li>If the value is an object
            <ol class="algorithm">
              <li>If the value contains only an <code>@id</code> key or the value contains a
                <code>@value</code> key, the compacted value is the result of performing
                <a href="#value-compaction">Value Compaction</a> on the value.</li>
              <li>Otherwise, if the value contains only a <code>@list</code> key, and the
                <tref>active property</tref> is subject to list coercion, the compacted value is the result of
                performing this algorithm on that value.</li>
              <li>Otherwise, if the value contains only a <code>@set</code> key, the compacted value is the
                value of <code>@set</code>.</li>
              <li>Otherwise, the compacted value is the result of performing this algorithm on the value.</li>
            </ol>
          </li>
          <li>Otherwise, if the value is an <tref>array</tref>, the compacted value is the result of
            performing this algorithm on the value.</li>
          <li>Otherwise, the value is already compacted.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Otherwise, the compacted value is the <em>value</em>.</li>
</ol>
</section>

</section>

<section>
<h2>Framing</h2>

<p>JSON-LD Framing allows developers to query by example and
  force a specific tree layout to a JSON-LD document.</p>

<p>A JSON-LD document is a representation of a directed graph. A single
  directed graph can have many different serializations, each expressing
  exactly the same information. Developers typically work with trees, represented as
  <tref>JSON object</tref>s. While mapping a graph to
  a tree can be done, the layout of the end result must be specified in advance.
  A <tdef>Frame</tdef> can be used by a developer on a JSON-LD document to
  specify a deterministic layout for a graph.</p>

<p>Framing is the process of taking a JSON-LD document, which expresses a
  graph of information, and applying a specific graph layout
  (called a <tref>Frame</tref>).</p>

<p>The JSON-LD document below expresses a library, a book and a chapter:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "Book":         "http://example.org/vocab#Book",
    "Chapter":      "http://example.org/vocab#Chapter",
    "contains":     {
      "@id": "http://example.org/vocab#contains",
      "@type": "@id"
    },
    "creator":      "http://purl.org/dc/terms/creator",
    "description":  "http://purl.org/dc/terms/description",
    "Library":      "http://example.org/vocab#Library",
    "title":        "http://purl.org/dc/terms/title"
  },
  "@id":
  [{
    "@id": "http://example.com/library",
    "@type": "Library",
    "contains": "http://example.org/library/the-republic"
  },
  {
    "@id": "http://example.org/library/the-republic",
    "@type": "Book",
    "creator": "Plato",
    "title": "The Republic",
    "contains": "http://example.org/library/the-republic#introduction"
  },
  {
    "@id": "http://example.org/library/the-republic#introduction",
    "@type": "Chapter",
    "description": "An introductory chapter on The Republic.",
    "title": "The Introduction"
  }]
}-->
</pre>

<p>Developers typically like to operate on items in a hierarchical, tree-based
  fashion. Ideally, a developer would want the data above sorted into top-level
  libraries, then the books that are contained in each library, and then the
  chapters contained in each book. To achieve that layout, the developer can
  define the following <tref>frame</tref>:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "Book":         "http://example.org/vocab#Book",
    "Chapter":      "http://example.org/vocab#Chapter",
    "contains":     "http://example.org/vocab#contains",
    "creator":      "http://purl.org/dc/terms/creator"
    "description":  "http://purl.org/dc/terms/description"
    "Library":      "http://example.org/vocab#Library",
    "title":        "http://purl.org/dc/terms/title"
  },
  "@type": "Library",
  "contains": {
    "@type": "Book",
    "contains": {
      "@type": "Chapter"
    }
  }
}
-->
</pre>

<p>When the framing algorithm is run against the previously defined
  JSON-LD document, paired with the <tref>frame</tref> above, the following
  JSON-LD document is the end result:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "Book":         "http://example.org/vocab#Book",
    "Chapter":      "http://example.org/vocab#Chapter",
    "contains":     "http://example.org/vocab#contains",
    "creator":      "http://purl.org/dc/terms/creator"
    "description":  "http://purl.org/dc/terms/description"
    "Library":      "http://example.org/vocab#Library",
    "title":        "http://purl.org/dc/terms/title"
  },
  "@id": "http://example.org/library",
  "@type": "Library",
  "contains": {
    ****"@id": "http://example.org/library/the-republic",****
    "@type": "Book",
    ****"creator": "Plato",****
    ****"title": "The Republic",****
    "contains": {
      ****"@id": "http://example.org/library/the-republic#introduction",****
      "@type": "Chapter",
      ****"description": "An introductory chapter on The Republic.",****
      ****"title": "The Introduction"****
    },
  },
}
-->
</pre>

<section>
<h3>Framing Algorithm Terms</h3>
<p class="issue">This algorithm is a work in progress, do not implement it.
  There was also a recent update to the algorithm in order to auto-embed
  frame-unspecified data (if the explicit inclusion flag is not set) in order to
  preserve graph information. This change is particularly important for comparing
  subgraphs (or verifying digital signatures on subgraphs). This change is not yet
  reflected in the algorithm below.</p>

 <dl>
   <dt><tdef>input frame</tdef></dt>
   <dd>the initial <tref>frame</tref> provided to the framing algorithm.</dd>
   <dt><tdef>framing context</tdef></dt>
   <dd>a context containing the <tref>object embed flag</tref>, the
     <tref>explicit inclusion flag</tref> and the
     <tref>omit default flag</tref>.</dd>
   <dt><tdef>object embed flag</tdef></dt>
   <dd>a flag specifying that objects should be directly embedded in the output,
     instead of being referred to by their IRI.</dd>
   <dt><tdef>explicit inclusion flag</tdef></dt>
   <dd>a flag specifying that for properties to be included in the output, they
     must be explicitly declared in the <tref>framing context</tref>.</dd>
   <dt><tdef>omit missing properties flag</tdef></dt>
   <dd>a flag specifying that properties that are missing from the
     <tref>JSON-LD input</tref> should be omitted from the output.</dd>
   <dt><tdef>omit default flag</tdef></dt>
   <dd class="issue">Referenced from <tref>framing context</tref>, but not defined</dd>
   <dt><tdef>match limit</tdef></dt>
   <dd>A value specifying the maximum number of matches to accept when building
     arrays of values during the framing algorithm. A value of -1 specifies
     that there is no match limit.</dd>
   <dt><tdef>map of embedded subjects</tdef></dt>
   <dd>A map that tracks if a subject has been embedded in the output of the
     <a href="#framing-algorithm">Framing Algorithm</a>.</dd>
 </dl>
</section>

<section>
<h3>Framing Algorithm</h3>

<p>The framing algorithm takes <tref>JSON-LD input</tref> that has been
  normalized according to the
  <a href="#normalization-algorithm">Normalization Algorithm</a>
  (<strong>normalized input</strong>), an
  <tref>input frame</tref> that has been expanded according to the
  <a href="#expansion-algorithm">Expansion Algorithm</a>
  (<strong>expanded frame</strong>), and a number of options and produces
  <tref>JSON-LD output</tref>. The following series of steps is the recursive
  portion of the framing algorithm:</p>

<ol class="algorithm">
  <li>Initialize the <tref>framing context</tref> by setting the
    <tref>object embed flag</tref>, clearing the
    <tref>explicit inclusion flag</tref>, and clearing the
    <tref>omit missing properties flag</tref>. Override these values
    based on input options provided to the algorithm by the application.</li>
  <li>Generate a <tdef>list of frames</tdef> by processing the
    <strong>expanded frame</strong>:
    <ol class="algorithm">
      <li>If the <strong>expanded frame</strong> is not an <tref>array</tref>, set
        <tref>match limit</tref> to 1, place the
        <strong>expanded frame</strong> into the <tref>list of frames</tref>,
        and set the <tref>JSON-LD output</tref> to <tref>null</tref>.</li>
      <li>If the <strong>expanded frame</strong> is an empty <tref>array</tref>, place an
        empty object into the <tref>list of frames</tref>,
        set the <tref>JSON-LD output</tref> to an <tref>array</tref>, and set
        <tref>match limit</tref> to -1.</li>
      <li>If the <strong>expanded frame</strong> is a non-empty <tref>array</tref>, add
        each item in the <strong>expanded frame</strong> into the
        <tref>list of frames</tref>, set the <tref>JSON-LD output</tref> to an
        <tref>array</tref>, and set <tref>match limit</tref> to -1.</li>
    </ol>
  </li>
  <li>Create a <tdef>match array</tdef> for each <strong>expanded frame</strong>
    in the <tref>list of frames</tref> halting when either the
    <tref>match limit</tref> is zero or the end of the
    <tref>list of frames</tref> is reached. If an
    <strong>expanded frame</strong> is
    not an object, the processor MUST throw a <code>Invalid Frame Format</code>
    exception. Add each matching item from the <strong>normalized input</strong>
    to the <tref>matches array</tref> and decrement the
    <tref>match limit</tref> by 1 if:
    <ol class="algorithm">
       <li>The <strong>expanded frame</strong> has an <code>rdf:type</code>
         that exists in the item's list of <code>rdf:type</code>s. Note:
         the <code>rdf:type</code> can be an <tref>array</tref>, but only one value needs
         to be in common between the item and the
         <strong>expanded frame</strong> for a match.</li>
       <li>The <strong>expanded frame</strong> does not have an
         <code>rdf:type</code> property, but every property in the
         <strong>expanded frame</strong> exists in the item.</li>
    </ol>
    <p class="issue"><tdef>matches array</tdef> not defined anywhere.</p>
  </li>
  <li>Process each item in the <tref>match array</tref> with its associated
    <tdef>match frame</tdef>:
    <ol class="algorithm">
      <li>If the <tref>match frame</tref> contains an <code>@embed</code>
        <tref>keyword</tref>, set the <tref>object embed flag</tref> to its value.
        If the <tref>match frame</tref> contains an <code>@explicit</code>
        <tref>keyword</tref>, set the <tref>explicit inclusion flag</tref> to its value.
        Note: if the <tref>keyword</tref> exists, but the value is neither
        <code>true</code> or <code>false</code>, set the associated flag to
        <code>true</code>.</li>
      <li>If the <tref>object embed flag</tref> is cleared and the item has
        the <code>@id</code> property, replace the item with the value
        of the <code>@id</code> property.</li>
      <li>If the <tref>object embed flag</tref> is set and the item has
        the <code>@id</code> property, and its IRI is in the
        <tref>map of embedded subjects</tref>, throw a
        <code>Duplicate Embed</code> exception.</li>
      <li>If the <tref>object embed flag</tref> is set and the item has
        the <code>@id</code> property and its IRI is not in the
        <tref>map of embedded subjects</tref>:
        <ol class="algorithm">
          <li>If the <tref>explicit inclusion flag</tref> is set,
            then delete any key from the item that does not exist in the
            <tref>match frame</tref>, except <code>@id</code>.</li>
          <li>For each key in the <tref>match frame</tref>, except for
            <tref>keyword</tref>s and <code>rdf:type</code>:
          <ol class="algorithm">
            <li>If the key is in the item, then build a new
              <tdef>recursion input list</tdef> using the object or objects
              associated with the key. If any object contains an
              <code>@id</code> value that exists in the
              <strong>normalized input</strong>, replace the object in the
              <tref>recursion input list</tref> with a new object containing
              the <code>@id</code> key where the value is the value of
              the <code>@id</code>, and all of the other key-value pairs for
              that subject. Set the <tdef>recursion match frame</tdef> to the
              value associated with the <tref>match frame</tref>'s key. Replace
              the value associated with the key by recursively calling this
              algorithm using <tref>recursion input list</tref>,
              <tref>recursion match frame</tref> as input.</li>
            <li>If the key is not in the item, add the key to the item and
              set the associated value to an empty array if the
              <tref>match frame</tref> key's value is an array
              or <tref>null</tref> otherwise.</li>
            <li>If value associated with the item's key is <tref>null</tref>,
              process the <tref>omit missing properties flag</tref>:
              <ol class="algorithm">
                <li>If the value associated with the key in the
                  <tref>match frame</tref> is an array, use the first frame
                  from the array as the <tdef>property frame</tdef>, otherwise
                  set the <tref>property frame</tref> to an empty object.</li>
                <li>If the <tref>property frame</tref> contains an
                <code>@omitDefault</code> <tref>keyword</tref>, set the
                <tref>omit missing properties flag</tref> to its value.
                Note: if the <tref>keyword</tref> exists, but the value is neither
                <code>true</code> or <code>false</code>, set the associated
                flag to <code>true</code>.</li>
                <li>If the <tref>omit missing properties flag</tref> is set,
                  delete the key in the item. Otherwise, if the
                  <code>@default</code> <tref>keyword</tref> is set in the
                  <tref>property frame</tref> set the item's value to the value
                  of <code>@default</code>.</li>
              </ol>
            </li>
          </ol></li>
        </ol>
      </li>
      <li>If the <tref>JSON-LD output</tref> is <tref>null</tref> set it to
        the item, otherwise, append the item to the
        <tref>JSON-LD output</tref>.</li>
    </ol>
  </li>
  <li>Return the <tref>JSON-LD output</tref>.</li>
</ol>

<p>The final, non-recursive step of the framing algorithm requires the
  <tref>JSON-LD output</tref> to be compacted according to the
  <a href="#compaction-algorithm">Compaction Algorithm</a> by using the
  context provided in the <tref>input frame</tref>. The resulting value is the
  final output of the compaction algorithm and is what should be returned to the
  application.</p>

</section>

<p class="issue">What are the implications for framing lists?</p>

</section>

<section>
<h2>Normalization</h2>

<p class="issue">This algorithm is a work in progress, do not implement it.</p>

<p>Normalization is the process of taking <tref>JSON-LD input</tref> and
  performing a deterministic transformation on that input that results in
  a normalized and serialized JSON-LD representation.</p>

<p>Normalization is achieved by transforming <tref>JSON-LD input</tref> to RDF,
  as described in <a href="#rdf-conversion">RDF Conversion</a>, invoking the normalization procedure
  as described in [[!RDF-NORMALIZATION]], returning the serialized results.</p>

<div class="issue">
  <p>There an open issue (<a href="https://github.com/json-ld/json-ld.org/issues/53">ISSUE-53</a>)
    on the purpose and results of performing normalization. Previous versions of the
    specification generated JSON-LD as the result of the normalization algorithm, however
    normalization is a process required across different linked data serializations. To be useful,
    a graph requires an identical normalized representation that is independent of the
    data format originally used for markup, or the way in which language features or publisher
    preferences create differences in the markup of identical graphs.</p>
  <p>It may be that the need for either or both of flattening algorithm or to retrieve such a
    cryptographic signature.</p>
</div>

<p>Normalization is useful when comparing two graphs against one another,
  when generating a detailed list of differences between two graphs, and
  when generating a cryptographic digital signature for information contained
  in a graph or when generating a hash of the information contained in a graph.</p>

<p>The example below is an un-normalized JSON-LD document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "homepage": {
      "@id": "http://xmlns.com/foaf/0.1/homepage",
      "@type": "@id"
    },
    "xsd": "http://www.w3.org/2001/XMLSchema#"
  },
  "name": "Manu Sporny",
  "homepage": "http://manu.sporny.org/"
}
-->
</pre>

<p>The example below is the normalized form of the JSON-LD document above:</p>

<p class="note">Whitespace is used below to aid readability. The normalization
  algorithm for JSON-LD removes all unnecessary whitespace in the fully
  normalized form.</p>
<p class="issue">Not clear that whitespace must be normalized, as the JSON-LD
  representation can't be used directly to create a signature, but would be based
  on the serialized result of [[!RDF-NORMALIZATION]].</p>

<pre class="example" data-transform="updateExample">
<!--
[{
  "@id": "_:c14n0",
  "http://xmlns.com/foaf/0.1/homepage": {
    "@id": "http://manu.sporny.org/"
  },
  "http://xmlns.com/foaf/0.1/name": "Manu Sporny"
}]
-->
</pre>

<p>Notice how all of the <tref>term</tref>s have been expanded and sorted in
  alphabetical order. Also, notice how the <tref>subject</tref> has been labeled with a
  named <tref>blank node</tref>. Normalization ensures that any arbitrary graph
  containing exactly the same information would be normalized to exactly the same form
  shown above.</p>
<section>
<h3>Normalization Algorithm</h3>

<p>The normalization algorithm transforms the <tref>JSON-LD input</tref>
  into RDF, normalizes it according to [[!RDF-NORMALIZATION]] and then
  transforms back to JSON-LD. The result is an object representation that
  deterministically represents a RDF graph.</p>

<ol class="algorithm">
  <li>Transform the <tref>JSON-LD input</tref> to RDF according to the steps in
    the <a href="#rdf-conversion-algorithm">RDF Conversion Algorithm</a>.</li>
  <li>Perform [[!RDF-NORMALIZATION]] of that RDF to create a serialized N-Triples
    representation of the RDF graph.</li>
  <li>Construct a JSON <tref>array</tref> <em>array</em> to serve as the output object.</li>
  <li>For each triple in the N-Triples document having <em>subject</em>, <em>predicate</em>,
    and <em>object</em>:
    <ol class="algorithm">
      <li>If <em>predicate</em> is <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#first</code>,
        let <em>object representation</em> be <em>object</em> represented in expanded
        form as described in <a href="#value-expansion">Value Expansion</a>.
        <ol class="algorithm">
          <li>Set <em>value</em> as the last entry in <em>array</em>.</li>
          <li>If the last entry in <em>value</em> is <em>subject</em>, replace it with
            the a <tref>JSON object</tref> having a key/value pair of <code>@list</code> and an
            <tref>array</tref> containing <em>object representation</em>.</li>
          <li>Otherwise, the last key/value entry in <em>value</em> MUST be a <tref>JSON object</tref>
            having a single key of <code>@list</code> with a value that is an <tref>array</tref>.
            Append <em>object representation</em>.</li>
        </ol>
      </li>
      <li>Otherwise, if <em>predicate</em> is
        <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#rest</code>, ignore this triple.</li>
      <li>Otherwise, if the last entry in <em>array</em> is not a <tref>JSON Object</tref> with an
        <code>@id</code> having a value of <em>subject</em>:
        <ol class="algorithm">
          <li>Create a new <tref>JSON Object</tref> with key/value pair of <code>@id</code> and
            a string representation of <em>subject</em> and use as <em>value</em>.</li>
          <li>Otherwise, set <em>value</em> to that value.</li>
        </ol>
      </li>
      <li>If <code>predicate</code> is <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#type</code>:
        <ol class="algorithm">
          <li>If <em>value</em> has an key/value pair of <code>@type</code> and an <tref>array</tref>,
            append the string representation of <tref>object</tref> to that array.</li>
          <li>Otherwise, if <em>value</em> has an key of <code>@type</code>, replace that value
            with a new array containing the existing value and a string representation of
            <em>object</em>.</li>
          <li>Otherwise, create a new entry in value with a key of <code>@type</code> and value being a
            string representation of <em>object</em>.</li>
        </ol>
      </li>
      <li>Otherwise, let <em>key</em> by the string representation of <em>predicate</em> and
        let <em>object representation</em> be <em>object</em> represented in expanded
        form as described in <a href="#value-expansion">Value Expansion</a>.</li>
      <li>If <em>value</em> has an key/value pair of <em>key</em> and an <tref>array</tref>,
        append <em>object representation</em> to that array.</li>
      <li>Otherwise, if <em>value</em> has an key of <em>key</em>, replace that value
        with a new array containing the existing value and <em>object representation</em>.</li>
      <li>Otherwise, create a new entry in value with a key of <em>key</em> and
        <em>object representation</em>.</li>
    </ol>
  </li>
  <li>Return <em>array</em> as the normalized graph representation.</li>
</ol>
</section>

</section>

<section>

<h3>Data Round Tripping</h3>

<p>When coercing numbers to <strong>xsd:integer</strong> or <strong>xsd:double</strong>
  as it, e.g., happens during <a href="#normalization">normalization</a>, implementers MUST
  ensure that the result is a canonical lexical representation in the form of a
  <tref>string</tref>. A <tdef>canonical lexical representation</tdef> is a set of literals
  from among the valid set of literals for a datatype such that there is a one-to-one mapping
  between the canonical lexical representation and a value in the value space as defined in
  [[!XMLSCHEMA-2]]. In other words, every value MUST be converted to a deterministic string
  representation.</p>
<p>
<p>The canonical lexical representation of an <em>integer</em>, i.e., a number without fractions
  or a number coerced to <strong>xsd:integer</strong>, is a finite-length sequence of decimal
  digits (<code>0-9</code>) with an optional leading minus sign; leading zeroes are prohibited.
  To convert the number in JavaScript, implementers can use the following snippet of code:</p>
<pre class="example" data-transform="updateExample">
<!--
(value).toFixed(0).toString()
-->
</pre>
<p>The canonical lexical representation of a <em>double</em>, i.e., a number with fractions
  or a number coerced to <strong>xsd:double</strong>, consists of a mantissa followed by the
  character "E", followed by an exponent. The mantissa MUST be a decimal number. The exponent
  MUST be an integer. Leading zeroes and a preceding plus sign (<code>+</code>) are prohibited
  in the exponent. If the exponent is zero, it must be indicated by <code>E0</code>.
  For the mantissa, the preceding optional plus sign is prohibited and the decimal point is
  required. Leading and trailing zeroes are prohibited subject to the following: number
  representations must be normalized such that there is a single digit which is non-zero to the
  left of the decimal point and at least a single digit to the right of the decimal point unless
  the value being represented is zero. The canonical representation for zero is <code>0.0E0</code>.
  To convert the number in JavaScript, implementers can use the following snippet of code:</p>
<pre class="example" data-transform="updateExample">
<!--
(value).toExponential().replace(/e\+?/,'E')
-->
</pre>
<p><strong>xsd:double</strong>'s value space is defined by the IEEE double-precision 64-bit
floating point type [[!IEEE-754-1985]].</p>

<p class="note">When data such as decimals need to be normalized, JSON-LD authors should
not use values that are going to undergo automatic conversion. This is due to the lossy nature
of <strong>xsd:double</strong> values. Authors should instead use the expanded object form to
set the canonical lexical representation directly.</p>

<p class="note">When JSON-native datatypes, like <tref>number</tref>s, are type coerced, lossless
data round-tripping can not be guaranted. Consider the following code example:</p>

<pre class="example" data-transform="updateExample">
<!--
var myObj1 = {
               "@context": {
                 "number": {
                   "@id": "http://example.com/vocab#number",
                   ****"@type": "xsd:nonNegativeInteger"****
                 }
               },
               "number" : ****42****
             };

// Normalize the JSON-LD document, this converts 42 to a string
var jsonldText = jsonld.normalize(myObj1);

// Convert the normalized object back to a JavaScript object
var myObj2 = jsonld.parse(jsonldText);
-->
</pre>

<p>At this point, <code>myObj1</code> and <code>myObj2</code> will have different
  values for the "number" property. <code>myObj1</code> will have the number
  <code>42</code>, while <code>myObj2</code> have an object consisting of
  <code>@value</code> set to the string <code>"42"</code> and <code>@type</code>
  set to the expanded value of <em>xsd:nonNegativeInteger</em>.</p>

<p class="note">Some JSON serializers, such as PHP's native implementation in some versions,
  backslash-escape the forward slash character. For example, the value
  <code>http://example.com/</code> would be serialized as <code>http:\/\/example.com\/</code>.
  This is problematic as other JSON parsers might not understand those escaping characters.
  There is no need to backslash-escape forward slashes in JSON-LD. To aid interoperability
  between JSON-LD processors, a JSON-LD serializer MUST NOT backslash-escape forward slashes.</p>

</section>

<section>
<h2>RDF Conversion</h2>

<p>A JSON-LD document MAY be converted to any other RDF-compatible document
format using the algorithm specified in this section.</p>

<p>
  The JSON-LD Processing Model describes processing rules for extracting RDF
  from a JSON-LD document. Note that many uses of JSON-LD may not require
  generation of RDF.
</p>

<p>
The processing algorithm described in this section is provided in
order to demonstrate how one might implement a JSON-LD to RDF processor.
Conformant implementations are only required to produce the same type and
number of triples during the output process and are not required to
implement the algorithm exactly as described.
</p>

<section class="informative">
  <h4>Overview</h4>
  <p>
    JSON-LD is intended to have an easy to parse grammar that closely models existing
    practice in using JSON for describing object representations. This allows the use
    of existing libraries for parsing JSON.
  </p>
  <p>
    As with other grammars used for describing <tref>Linked Data</tref>, a key concept is that of
    a <tdef>resource</tdef>. Resources may be of three basic types: <em><tref>IRI</tref></em>s, for describing
    externally named entities, <em>BNodes</em>, resources for which an external name does not
    exist, or is not known, and Literals, which describe terminal entities such as strings,
    dates and other representations having a lexical representation possibly including
    an explicit language or datatype.
  </p>
  <p>
  An Internationalized Resource Identifier
  (<tdef><abbr title="Internationalized Resource Identifier">IRI</abbr></tdef>),
  as described in [[!RFC3987]], is a mechanism for representing unique
  identifiers on the web. In <tref>Linked Data</tref>, an IRI is commonly
  used for expressing a <tref>subject</tref>, a <tref>property</tref> or an
  <tref>object</tref>.
  </p>
  <p>
    Data described with JSON-LD may be considered to be the representation of a graph made
    up of <tref>subject</tref> and <tref>object</tref> <tref>resource</tref>s related via a <tref>property</tref> <tref>resource</tref>.
    However, specific implementations may choose to operate on the document as a normal
    JSON description of objects having attributes.
  </p>
</section>

<section>
  <h4>RDF Conversion Algorithm Terms</h4>
  <dl>
    <dt><tdef>default graph</tdef></dt>
    <dd>
      the destination graph for all triples generated by JSON-LD markup.
    </dd>
  </dl>
</section>

<section>
  <h3>RDF Conversion Algorithm</h3>
  <p>
    The algorithm below is designed for in-memory implementations with random access to <tref>JSON object</tref> elements.
  </p>
  <p>
    A conforming JSON-LD processor implementing RDF conversion MUST implement a
    processing algorithm that results in the same <tref>default graph</tref> that the following
    algorithm generates:
  </p>

  <p>The algorithm takes four input variables: a <em>value</em> to be converted, an
    <tref>active subject</tref> and an <tref>active property</tref>.
    To begin, the <tref>active subject</tref> and <tref>active property</tref> are set to <tref>null</tref>, and <em>value</em> is
    set to the result of performing the <a href="#expansion-algorithm">Expansion Algorithm</a> on
    the <tref>JSON-LD input</tref>. This removes any existing context to allow the given context to be cleanly
    applied.</p>

  <ol class="algorithm">
    <li id="processing-step-associative">
      If <em>value</em> is a <tref>JSON object</tref>, perform the following steps:
      <ol class="algorithm">
        <li>Set <tref>active object</tref> to <tref>null</tref>.</li>
        <li>
          If the <tref>JSON object</tref> has a <code>@value</code> key, set the <tref>active object</tref>
          to a literal value as follows:
          <ol class="algorithm">
            <li>
              as a <tref>typed literal</tref> if the <tref>JSON object</tref> contains a <code>@type</code> key
              after performing <a href="#iri-expansion">IRI Expansion</a> on the specified <code>@type</code>.
            </li>
            <li>
              otherwise, as a <tref>plain literal</tref>. If the <tref>JSON object</tref> contains
              a <code>@language</code> key, use it's value to set the language of the plain literal.
            </li>
          </ol>
        </li>
        <li>
          If the <tref>JSON object</tref> has a <code>@list</code> key the value MUST be an <tref>array</tref>.
          Process the value as a list as described in <a href="#list-conversion">List Conversion</a> using
          the return value as the <tref>active object</tref>
        </li>
        <li>If <tref>active object</tref> is not <tref>null</tref>:
          <ol class="algorithm">
            <li>If nether <tref>active subject</tref> nor <tref>active property</tref> are <tref>null</tref>, generate a triple
              representing the <tref>active subject</tref>, the <tref>active property</tref> and the
              <tref>active object</tref>.</li>
            <li>Return the <tref>active object</tref> to the calling location.</li>
          </ol>
        </li>
        <li id="processing-step-subject">If the <tref>JSON object</tref> has a <code>@id</code> key:
          <ol class="algorithm">
            <li>
              If the value is a <tref>string</tref>, set the <tref>active subject</tref> to the previously
              expanded value (either a <tref>blank node</tref> or an <tref>IRI</tref>).</li>
            <li>Otherwise,
              Generate a create a new <tref>processor state</tref> copies of the <tref>active subject</tref>
              and <tref>active property</tref>.
              <ol class="algorithm">
                <li>
                  Process the value starting at
                  <a href="#processing-step-associative">Step 1</a> using the returned value as
                  <tref>active subject</tref>.
                </li>
                <li>Proceed using the previous <tref>processor state</tref>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>
          If the <tref>JSON object</tref> does not have a <code>@id</code> key, set the <tref>active
          object</tref> to newly generated <tref>blank node</tref>.</li>
        <li>
          For each key in the <tref>JSON object</tref> that has not already been processed, perform
          the following steps:
          <ol class="algorithm">
            <li>
              If the key is <code>@type</code>, set the <tref>active property</tref>
              to <code>rdf:type</code>.
            </li>
            <li>Otherwise, if the key is a <tref>keyword</tref>, skip this step.</li>
            <li>Otherwise, set <tref>active property</tref> to the value of the key.</li>
            <li>
              Create a new <tref>processor state</tref> copies of
              <tref>active subject</tref> and <tref>active property</tref> and process the value
              starting at <a href="#processing-step-associative">Step 1</a> and proceed using the
              previous <tref>processor state</tref>.
            </li>
          </ol>
        </li>
        <li>
          Return the <tref>active subject</tref> to the calling location.
        </li>
      </ol>
    </li>

    <li>If a regular <tref>array</tref> is detected, process each value in the <tref>array</tref>
      by doing the following returning the result of processing the last value in the <tref>array</tref>:
      <div class="issue">Update based on decision of what value, if any, of array to use.</div>
      <ol class="algorithm">
        <li>
          Create a new <tref>processor state</tref> using copies of <tref>active subject</tref> and
          <tref>active property</tref> and process the value
          starting at <a href="#processing-step-associative">Step 1</a> then proceed using the previous
          <tref>processor state</tref>.
        </li>
      </ol>
    </li>

    <li>
      If a <tref>string</tref> is detected, set the <tref>active object</tref>
      to a <tref>plain literal</tref> value created from the string.</li>
    <li>
      If a <tref>number</tref> is detected, set the <tref>active object</tref> to a
      <tref>typed literal</tref> using a string representation of the value with datatype set
      to either <code>xsd:integer</code> or <code>xsd:double</code>, depending on if the value
      contains a fractional and/or an exponential component.</li>
    <li>
      Otherwise, if <strong>true</strong> or <strong>false</strong> is detected,
      set the <tref>active object</tref> to a <tref>typed literal</tref> created from the
      string representation of the value with datatype set to <code>xsd:boolean</code>.
    </li>
    <li>
      If any of these steps created an <tref>active object</tref> and neither <tref>active subject</tref>
      nor <tref>active property</tref> are <tref>null</tref>, generate a triple using <tref>active subject</tref>,
      <tref>active property</tref> and <tref>active object</tref>
    </li>
    <li>Return <tref>active object</tref> to the calling location.</li>
  </ol>
</section>
<section id="list-conversion">
  <h3>List Conversion</h3>

  <p>List Conversion is the process of taking an <tref>array</tref> of values and adding them to a newly
    created <cite><a href="http://www.w3.org/TR/rdf-schema/#ch_collectionvocab">RDF Collection</a></cite> (see
    [[!RDF-SCHEMA]]) by linking each element of the list using <code>rdf:first</code> and <code>rdf:next</code>,
    terminating the list with <code>rdf:nil</code> using the following sequence:</p>
  <p>The algorithm is invoked with an <tref>array</tref> <em>array</em>, the <tref>active property</tref>
    and returns a value to be used as an <tref>active object</tref> in the calling location.</p>
  <div class="note">This algorithm does not support lists containing lists.</div>
  <ol class="algorithm">
    <li>
      If <em>array</em> is empty return <code>rdf:nil</code>.
    </li>
    <li>
      Otherwise, generate a triple using using the <tref>active subject</tref>, <tref>active property</tref>
      and a newly generated <tref>blank node</tref> identified as <em>first <tref>blank node</tref></em>.
    </li>
    <li>
      For each element in <em>array</em> other than the last element:
      <ol class="algorithm">
        <li>Create a processor state using
          <em>first <tref>blank node</tref></em> as the <tref>active subject</tref>, and
          <code>rdf:first</code> as the <tref>active property</tref>.
          <ol class="algorithm">
            <li>Process the value starting at <a href="#processing-step-associative">Step 1</a>.</li>
            <li>Proceed using the previous <tref>processor state</tref>.</li>
          </ol>
        </li>
        <li>Unless this is the last element in <em>array</em>, generate a new <tref>blank node</tref> identified as
          <em>rest <tref>blank node</tref></em>, otherwise use <code>rdf:nil</code>.</li>
        <li>Generate a new triple using <em>first <tref>blank node</tref></em>,
          <code>rdf:rest</code> and <em>rest <tref>blank node</tref></em>.</li>
        <li>Set <em>first <tref>blank node</tref></em> to
          <em>rest <tref>blank node</tref></em>.</li>
        <li>Return <em>first <tref>blank node</tref></em>.</li>
      </ol>
    </li>
  </ol>
</section>
</section>
</section>

<section class="appendix informative">
<h1>IANA Considerations</h1>

<p>This section is included merely for standards community review and will be
submitted to the Internet Engineering Steering Group if this specification
becomes a W3C Recommendation.</p>

<dl>
  <dt>Type name:</dt>
  <dd>application</dd>
  <dt>Subtype name:</dt>
  <dd>ld-frame+json</dd>
  <dt>Required parameters:</dt>
  <dd>None</dd>
  <dt>Optional parameters:</dt>
  <dd>None</dd>
  <dt>Encoding considerations:</dt>
  <dd>The same as the <code>application/json</code> MIME media type.</dd>
  <dt>Security considerations:</dt>
  <dd>Since a JSON-LD frame is intended to specify a deterministic layout
    for a JSON-LD graph, the serialization SHOULD NOT be passed through a
    code execution mechanism such as JavaScript's <code>eval()</code>
    function. It is RECOMMENDED that a conforming parser does not attempt to
    directly evaluate the JSON-LD frame and instead purely parse the
    input into a language-native data structure.</dd>
  <dt>Interoperability considerations:</dt>
  <dd>Not Applicable</dd>
  <dt>Published specification:</dt>
  <dd>The <a href="http://json-ld.org/spec/latest/">JSON-LD</a> specification.</dd>
  <dt>Applications that use this media type:</dt>
  <dd>Any programming environment that requires the exchange of
    directed graphs. Implementations of JSON-LD have been created for
    JavaScript, Python, Ruby, PHP and C++.
  </dd>
  <dt>Additional information:</dt>
  <dd>
    <dl>
      <dt>Magic number(s):</dt>
      <dd>Not Applicable</dd>
      <dt>File extension(s):</dt>
      <dd>.jsonldf</dd>
      <dt>Macintosh file type code(s):</dt>
      <dd>TEXT</dd>
    </dl>
  </dd>
  <dt>Person &amp; email address to contact for further information:</dt>
  <dd>Manu Sporny &lt;msporny@digitalbazaar.com&gt;</dd>
  <dt>Intended usage:</dt>
  <dd>Common</dd>
  <dt>Restrictions on usage:</dt>
  <dd>None</dd>
  <dt>Author(s):</dt>
  <dd>Manu Sporny, Gregg Kellogg, Markus Lanthaler, Dave Longley</dd>
  <dt>Change controller:</dt>
  <dd>W3C</dd>
</dl>

</section>

<section class="appendix" id="appendix-b">
  <h1>Initial Context</h1>
  <p>The <tref>initial context</tref> is defined with the following default entries:</p>
<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type": { "@type": "@id"}
  }
}
-->
</pre>
  <p>Processors MUST act as if the initial context is defined in the outer-most level when processing
    JSON-LD documents.</p>
  <p class="issue">Should we define other default prefixes?</p>
</section>

<section class="appendix">
<h1>Acknowledgements</h1>

<p>The editors would like to thank Mark Birbeck, who provided a great deal of
the initial push behind the JSON-LD work via his work on RDFj,
Dave Lehn and Mike Johnson who reviewed, provided feedback, and
performed several implementations of the specification, and Ian Davis, who
created RDF/JSON. Thanks also to Nathan Rixham, Bradley P. Allen,
Kingsley Idehen, Glenn McDonald, Alexandre Passant, Danny Ayers, Ted
Thibodeau Jr., Olivier Grisel, Niklas Lindström, Markus Lanthaler, and Richard
Cyganiak for their input on the specification.
</p>
</section>

</body>
</html>
