<!DOCTYPE html>
<html>
<head>
<title>JSON-LD 1.0 Processing Algorithms and API</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script type="text/javascript" src="../respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" src="../respec-w3c-extensions.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
  var respecConfig = {
      // extend the bibliography entries
      "localBiblio": localBibliography,

      doRDFa: "1.1",
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "ED",
      // publishDate:          "2013-08-22",
      // if you wish the publication date to be other than today, set this
      //publishDate:          "2012-12-25",
      copyrightStart:       "2010",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "json-ld-api",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      previousPublishDate:  "2013-05-16",
      previousMaturity:     "LC",
      previousURI:          "http://www.w3.org/TR/2013/WD-json-ld-api-20130516/",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "http://json-ld.org/spec/latest/json-ld-api/index.html",

      testSuiteURI:         "http://www.w3.org/2013/json-ld-tests/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",
      crEnd: "2013-09-19",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS: [],

      issueBase: "https://github.com/json-ld/json-ld.org/issues/",
      atRiskBase: "https://www.w3.org/2011/rdf-wg/wiki/JSON-LD_Features_at_Risk#",

      // editors, add as many as you like
      // only "name" is required
      editors:  [
          { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
            company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" },
          { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
            company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
          { name: "Manu Sporny", url: "http://manu.sporny.org/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" }
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.

      authors:  [
          { name: "Dave Longley", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
          { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
            company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
          { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
            company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" },
          { name: "Manu Sporny", url: "http://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" }
      ],

      // name of the WG
      wg:           "RDF Working Group",

      // URI of the public WG page
      wgURI:        "http://www.w3.org/2011/rdf-wg/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      wgPublicList: "public-rdf-comments",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/46168/status",
      maxTocLevel: 2,
      preProcess: [ preProc ],
      // alternateFormats: [ {uri: "diff-20130411.html", label: "diff to previous version"} ]
  };
//]]>
</script>
<style type="text/css">
  .diff {
    font-weight:bold; color:#0a3;
  }
  .error a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
  }
  .atrisk-head {
    font-style: italic;
  }
  ol.algorithm {
    counter-reset: numsection;
    list-style-type: none;
  }
  ol.algorithm li {
    margin: 0.5em 0;
  }
  ol.algorithm li:before {
    font-weight: bold;
    counter-increment: numsection;
    content: counters(numsection, ".") ") ";
  }
</style>
</head>

<body>
<section id="abstract">
  <p>This specification defines an Application Programming Interface (API)
    and a set of algorithms for programmatic transformations of JSON-LD
    documents. Restructuring data according to the defined transformations
    often dramatically simplifies its usage.</p>
</section>

<section id="sotd">
  <p>This document has been under development for over 30 months in the
    JSON for Linking Data Community Group. The document has been
    transferred to the RDF Working Group for review, improvement, and publication
    along the Recommendation track. The specification has undergone significant
    development, review, and changes during the course of the last 30 months.</p>

  <p>There are several independent
    <a href="http://json-ld.org/test-suite/reports/">interoperable implementations</a> of
    this specification. There is a fairly complete test suite [[JSON-LD-TESTS]]
    and a <a href="http://json-ld.org/playground/">live JSON-LD editor</a>
    that is capable of demonstrating the features described in
    this document. While there will be continuous development on implementations,
    the test suite, and the live editor, they are believed to be mature enough
    to be integrated into a non-production system at this point in time. There
    is an expectation that they could be used in a production system within the
    next three months.</p>

  <p>There are a number of ways that one may participate in the development of
    this specification:</p>

  <ul>
    <li>If you want to make sure that your feedback is formally addressed by
      the RDF Working Group, you should send it to public-rdf-comments:
      <a href="http://lists.w3.org/Archives/Public/public-rdf-comments/">public-rdf-comments@w3.org</a></li>

    <li>Ad-hoc technical discussion primarily occurs on the public community mailing list:
      <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

    <li><a href="http://json-ld.org/minutes/">Public JSON-LD Community Group teleconferences</a>
      are held on Tuesdays at 1500UTC every week. Participation is open to the
      public.</li>

    <li>RDF Working Group teleconferences are held on Wednesdays at 1500UTC
      every week. Participation is limited to RDF Working Group members.</li>

    <li>Specification bugs and issues should be reported in the
      <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>
      if you do not want to send an email to the public-rdf-comments mailing
      list.</li>

    <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a>
      for the specification can be found on Github.</li>

    <li>The <a href="http://webchat.freenode.net/?channels=json-ld">#json-ld</a>
      IRC channel is available for real-time discussion on irc.freenode.net.</li>
  </ul>

  <p>The following features are at risk and may be removed:</p>

  <ul>
    <li><a href="#at-risk-10">Support for <code>@base: null</code></a></li>
    <li><a href="#at-risk-3">Allow blank nodes to be used as properties</a></li>
    <li><a href="#at-risk-8">Properly referencing the DOM Promises spec</a></li>
    <li><a href="#at-risk-4">Lists of lists and partial list conversion from RDF</a></li>
  </ul>

  <p>Changes since the
    <a href="http://www.w3.org/TR/2013/WD-json-ld-api-20130411/">11&nbsp;April&nbsp;2013 Last Call Working Draft</a>:</p>

  <ul>
    <li>Use of DOM Futures instead of callbacks in the Application Programming Interface</li>
    <li>Processing of terms that are redefined to themselves without raising an
      <code class="error"><a href="#idl-def-JsonLdErrorCode.cyclic-IRI-mapping">cyclic IRI mapping</a></code> error</li>
    <li>Raise an <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-IRI-mapping">invalid IRI mapping</a></code>
      error if relative URLs are used in term definitions</li>
    <li>Support relative IRIs in <code>@base</code></li>
    <li>Remove default value of <code class="idlMemberName"><a href="#idl-def-JsonLdOptions">JsonLdOption's</a></code>
      <code class="idlMemberName"><a href="#widl-JsonLdOptions-base">base</a></code> member</li>
    <li>Support lists of lists when serializing RDF as JSON-LD</li>
    <li>Support for relative URLs in <code>@base</code> and documents that
      do not have a base value</li>
  </ul>

  <p>Changes since the
    <a href="http://www.w3.org/TR/2013/WD-json-ld-api-20130516/">16&nbsp;May&nbsp;2013 Last Call Working Draft</a>:</p>

  <ul>
    <li>Ensure determinism of the Deserialize JSON-LD to RDF algorithm by specifying the processing order</li>
    <li>Change the default value of the <em>use native types</em> flag in the Serialize RDF as JSON-LD
      algorithm to <code>false</code></li>
    <li>Clarify that the <i>identifier map</i> and the <i>counter</i> used by the
      Generate Blank Node Identifier algorithm are reset before running the Flattening
      and the Deserialize JSON-LD to RDF algorithms</li>
    <li>Raise an error if a blank node is used as data type</li>
    <li>Clarify that blank node identifier are supported as value of <code>@vocab</code></li>
    <li>When generating RDF, exclude <tref title="rdf triple">triples</tref> containing a
      <tref>blank node</tref> <tref title="rdf predicate">predicate</tref>, unless the
      <i>produce generalized RDF</i> flag is set; discard <tref title="rdf triple">triples</tref>
      containing relative IRIs and graphs with a relative IRI as graph name</li>
    <li>Update reference to DOM Promises (have been called DOM Futures)</li>
    <li>Fix bug in <a href="#serialize-rdf-as-json-ld-algorithm">Serialize RDF to JSON-LD algorithm</a> to
      handle lists correctly</li>
    <li>Support processing of documents with a <code>+json</code> media type as defined in
      [[RFC6839]]</li>
    <li>Use the <a>LoadDocumentCallback</a> (previously <code>LoadContextCallback</code>)
      to retrieve remote contexts and remote documents</li>
    <li>Allow contexts to be passed into the API directly. Previously only context documents, i.e.,
      objects having a <code>@context</code> member were allowed.</li>
    <li>Clarify the usage of the
      <code class="idlMemberName"><a href="#widl-JsonLdOptions-documentLoader">documentLoader</a></code> option.</li>
  </ul>

  <p>Before this specification exits Candidate Recommendation, two or more
    independent implementations must pass each test, although no single
    implementation must pass each test. The working group will decide when
    the test suite is of sufficient quality to test interoperability and will
    produce an implementation report (hosted together with the test suite).</p>
</section>


<section class="informative">
  <h1>Introduction</h1>

  <p>This document is a detailed specification for an Application Programming
    Interface for the JSON-LD syntax. The document is primarily intended for
    the following audiences:</p>

  <ul>
    <li>Developers who want an overview of the JSON-LD API.</li>
    <li>Web authors and developers who want a very detailed view of how
      a <tref>JSON-LD Processor</tref> or a <tref>JSON-LD API Implementation</tref>
      operates.</li>
    <li>Software developers who want to implement the algorithms to transform
      JSON-LD documents.</li>
  </ul>

  <p>To understand the basics in this specification you must first be familiar with
    JSON, which is detailed in [[!RFC4627]]. You must also understand the
    JSON-LD syntax defined in [[!JSON-LD]], which is the base syntax used by all
    of the algorithms in this document. To understand the API and how it is
    intended to operate in a programming environment, it is useful to have working
    knowledge of the JavaScript programming language [[ECMA-262]] and
    WebIDL [[!WEBIDL]]. To understand how JSON-LD maps to RDF, it is helpful to be
    familiar with the basic RDF concepts [[RDF11-CONCEPTS]].</p>
</section> <!-- end of Introduction -->


<section class="informative">
  <h1>Features</h1>

  <p>The JSON-LD Syntax specification [[!JSON-LD]] defines a syntax to
    express Linked Data in JSON. Because there is more than one way to
    express Linked Data using this syntax, it is often useful to be able to
    transform JSON-LD documents so that they may be more easily consumed by
    specific applications.</p>

  <p>JSON-LD uses <tref title="context">contexts</tref> to allow Linked Data
    to be expressed in a way that is specifically tailored to a particular
    person or application. By providing a <tref>context</tref>,
    JSON data can be expressed in a way that is a natural fit for a particular
    person or application whilst also indicating how the data should be
    understood at a global scale. In order for people or applications to
    share data that was created using a <tref>context</tref> that is different
    from their own, a JSON-LD processor must be able to transform a document
    from one <tref>context</tref> to another. Instead of requiring JSON-LD
    processors to write specific code for every imaginable
    <tref>context</tref> switching scenario, it is much easier to specify a
    single algorithm that can remove any <tref>context</tref>. Similarly,
    another algorithm can be specified to subsequently apply any
    <tref>context</tref>. These two algorithms represent the most basic
    transformations of JSON-LD documents. They are referred to as
    <tref>expansion</tref> and <tref>compaction</tref>, respectively.</p>

  <p>There are four major types of transformation that are discussed in this
    document: expansion, compaction, flattening, and RDF serialization/deserialization.</p>

  <section class="informative">
    <h2>Expansion</h2>

    <p>The algorithm that removes <tref>context</tref> is
      called <tdef>expansion</tdef>. Before performing any other
      transformations on a JSON-LD document, it is easiest to
      remove any <tref>context</tref> from it and to make data structures
      more regular.</p>

    <p>To get an idea of how context and data structuring affects the same data,
      here is an example of JSON-LD that uses only <tref title="term">terms</tref>
      and is fairly compact:</p>

    <pre class="example" data-transform="updateExample"
         title="Sample JSON-LD document">
    <!--
    {
      "@context": {
        "name": "http://xmlns.com/foaf/0.1/name",
        "homepage": {
          "@id": "http://xmlns.com/foaf/0.1/homepage",
          "@type": "@id"
        }
      },
      "@id": "http://me.markus-lanthaler.com/",
      "name": "Markus Lanthaler",
      "homepage": "http://www.markus-lanthaler.com/"
    }
    -->
    </pre>

    <p>The next input example uses one <tref>IRI</tref> to express a property
    and an <tref title="array">array</tref> to encapsulate another, but
    leaves the rest of the information untouched.</p>

    <pre class="example" data-transform="updateExample"
         title="Sample JSON-LD document using an IRI instead of a term to express a property">
    <!--
    {
      "@context": {
        ****"website": "http://xmlns.com/foaf/0.1/homepage"****
      },
      "@id": "http://me.markus-lanthaler.com/",
      "****http://xmlns.com/foaf/0.1/name****": "Markus Lanthaler",
      ****"website"****: ****{ "@id":**** "http://www.markus-lanthaler.com/" ****}****
    }
    -->
    </pre>

    <p>Note that both inputs are valid JSON-LD and both represent the same
      information. The difference is in their <tref>context</tref> information
      and in the data structures used. A JSON-LD processor can remove
      <tref>context</tref> and ensure that the data is more regular by employing
      <tref>expansion</tref>.</p>

    <p><tref>Expansion</tref> has two important goals: removing any contextual
      information from the document, and ensuring all values are represented
      in a regular form. These goals are accomplished by expanding all properties
      to <tref title="absolute IRI">absolute IRIs</tref> and by expressing all
      values in <tref title="array">arrays</tref> in
      <tref>expanded form</tref>. <tref>Expanded form</tref> is the most verbose
      and regular way of expressing of values in JSON-LD; all contextual
      information from the document is instead stored locally with each value.
      Running the <a href="#expansion-algorithm">Expansion algorithm</a>
      (<code class="idlMemberName"><a href="#widl-JsonLdProcessor-expand-Promise-any-input-JsonLdOptions-options">expand</a></code>
      operation) against the above examples results in the following output:</p>

    <pre class="example" data-transform="updateExample"
         title="Expanded sample document">
    <!--
    [
      {
        "@id": "http://me.markus-lanthaler.com/",
        "http://xmlns.com/foaf/0.1/name": [
          { "@value": "Markus Lanthaler" }
        ],
        "http://xmlns.com/foaf/0.1/homepage": [
          { "@id": "http://www.markus-lanthaler.com/" }
        ]
      }
    ]
    -->
    </pre>

    <p>Note that in the output above all <tref>context</tref> definitions have
      been removed, all <tref title="term">terms</tref> and
      <tref title="compact IRI">compact IRIs</tref> have been expanded to absolute
      <tref title="IRI">IRIs</tref>, and all
      <tref title="JSON-LD value">JSON-LD values</tref> are expressed in
      <tref title="array">arrays</tref> in <tref>expanded form</tref>. While the
      output is more verbose and difficult for a human to read, it establishes a
      baseline that makes JSON-LD processing easier because of its very regular
      structure.</p>
  </section> <!-- end of Expansion -->

  <section class="informative">
    <h2>Compaction</h2>

    <p>While <tref>expansion</tref> removes <tref>context</tref> from a given
      input, <tref title="compaction">compaction's</tref> primary function is to
      perform the opposite operation: to express a given input according to
      a particular <tref>context</tref>. <tdef>Compaction</tdef> applies a
      <tref>context</tref> that specifically tailors the way information is
      expressed for a particular person or application. This simplifies applications
      that consume JSON or JSON-LD by expressing the data in application-specific
      terms, and it makes the data easier to read by humans.</p>

    <p><tref>Compaction</tref> uses a developer-supplied <tref>context</tref> to
      shorten <tref title="IRI">IRIs</tref> to <tref title="term">terms</tref> or
      <tref title="compact IRI">compact IRIs</tref> and
      <tref title="JSON-LD value">JSON-LD values</tref> expressed in
      <tref>expanded form</tref> to simple values such as <tref title="string">strings</tref>
      or <tref title="number">numbers</tref>.</p>

    <p>For example, assume the following expanded JSON-LD input document:</p>

    <pre class="example" data-transform="updateExample"
         title="Expanded sample document">
    <!--
    [
      {
        "@id": "http://me.markus-lanthaler.com/",
        "http://xmlns.com/foaf/0.1/name": [
          { "@value": "Markus Lanthaler" }
        ],
        "http://xmlns.com/foaf/0.1/homepage": [
          { "@id": "http://www.markus-lanthaler.com/" }
        ]
      }
    ]
    -->
    </pre>

    <p>Additionally, assume the following developer-supplied JSON-LD
      <tref>context</tref>:</p>

    <pre class="example" data-transform="updateExample"
         title="JSON-LD context">
    <!--
    {
      "@context": {
        "name": "http://xmlns.com/foaf/0.1/name",
        "homepage": {
          "@id": "http://xmlns.com/foaf/0.1/homepage",
          "@type": "@id"
        }
      }
    }
    -->
    </pre>

    <p>Running the <a href="#compaction-algorithm">Compaction Algorithm</a>
      (<code class="idlMemberName"><a href="#widl-JsonLdProcessor-compact-Promise-any-input-JsonLdContext-context-JsonLdOptions-options">compact</a></code>
      operation) given the context supplied above against the JSON-LD input
      document provided above would result in the following output:</p>

    <pre class="example" data-transform="updateExample"
         title="Compacted sample document">
    <!--
    {
      "@context": {
        "name": "http://xmlns.com/foaf/0.1/name",
        "homepage": {
          "@id": "http://xmlns.com/foaf/0.1/homepage",
          "@type": "@id"
        }
      },
      "@id": "http://me.markus-lanthaler.com/",
      "name": "Markus Lanthaler",
      "homepage": "http://www.markus-lanthaler.com/"
    }
    -->
    </pre>

    <p>Note that all <tref title="IRI">IRIs</tref> have been compacted to
      <tref title="term">terms</tref> as specified in the <tref>context</tref>,
      which has been injected into the output. While compacted output is
      useful to humans, it is also used to generate structures that are easy to
      program against. Compaction enables developers to map any expanded document
      into an application-specific compacted document. While the context provided
      above mapped <code>http://xmlns.com/foaf/0.1/name</code> to <code>name</code>, it
      could also have been mapped to any other term provided by the developer.</p>
  </section> <!-- end of Compaction -->

  <section class="informative">
    <h2>Flattening</h2>

    <p>While expansion ensures that a document is in a uniform structure,
      flattening goes a step further to ensure that the shape of the data
      is deterministic. In expanded documents, the properties of a single
      <tref>node</tref> may be spread across a number of different
      <tref title="JSON object">JSON objects</tref>. By flattening a
      document, all properties of a <tref>node</tref> are collected in a single
      <tref>JSON object</tref> and all <tref title="blank node">blank nodes</tref>
      are labeled with a <tref>blank node identifier</tref>. This may drastically
      simplify the code required to process JSON-LD data in certain applications.</p>

    <p>For example, assume the following JSON-LD input document:</p>

    <pre class="example" data-transform="updateExample"
         title="Sample JSON-LD document">
    <!--
    {
      "@context": {
        "name": "http://xmlns.com/foaf/0.1/name",
        "knows": "http://xmlns.com/foaf/0.1/knows"
      },
      "@id": "http://me.markus-lanthaler.com/",
      "name": "Markus Lanthaler",
      "knows": [
        {
          "name": "Dave Longley"
        }
      ]
    }
    -->
    </pre>

    <p>Running the <a href="#flattening-algorithm">Flattening algorithm</a>
      (<code class="idlMemberName"><a href="#widl-JsonLdProcessor-flatten-Promise-any-input-JsonLdContext-context-JsonLdOptions-options">flatten</a></code>
      operation) with a context set to <tref>null</tref> to prevent compaction
      returns the following document:</p>

    <pre class="example" data-transform="updateExample"
         title="Flattened sample document in expanded form">
    <!--
    [
      {
        "@id": "_:t0",
        "http://xmlns.com/foaf/0.1/name": [
          { "@value": "Dave Longley" }
        ]
      },
      {
        "@id": "http://me.markus-lanthaler.com/",
        "http://xmlns.com/foaf/0.1/name": [
          { "@value": "Markus Lanthaler" }
        ],
        "http://xmlns.com/foaf/0.1/knows": [
          { "@id": "_:t0" }
        ]
      }
    ]
    -->
    </pre>

    <p>Note how in the output above all properties of a <tref>node</tref> are collected in a
      single <tref>JSON object</tref> and how the <tref>blank node</tref> representing
      &quot;Dave Longley&quot; has been assigned the <tref>blank node identifier</tref>
      <code>_:t0</code>.</p>

    <p>To make it easier for humans to read or for certain applications to
      process it, a flattened document can be compacted by passing a context. Using
      the same context as the input document, the flattened and compacted document
      looks as follows:</p>

    <pre class="example" data-transform="updateExample"
         title="Flattened and compacted sample document">
    <!--
    {
      "@context": {
        "name": "http://xmlns.com/foaf/0.1/name",
        "knows": "http://xmlns.com/foaf/0.1/knows"
      },
      "@graph": [
        {
          "@id": "_:t0",
          "name": "Dave Longley"
        },
        {
          "@id": "http://me.markus-lanthaler.com/",
          "name": "Markus Lanthaler",
          "knows": { "@id": "_:t0" }
        }
      ]
    }
    -->
    </pre>

    <p>Please note that the result of flattening and compacting a document
      is always a <tref>JSON object</tref> which contains an <code>@graph</code>
      member that represents the <tref>default graph</tref>.</p>
  </section> <!-- end of Flattening -->

  <section class="informative">
    <h2>RDF Serialization/Deserialization</h2>

    <p>JSON-LD can be used to serialize RDF data as described in
      [[RDF11-CONCEPTS]]. This ensures that data can be round-tripped to and from
      any RDF syntax without any loss in fidelity.</p>

    <p>For example, assume the following RDF input serialized in Turtle [[TURTLE]]:</p>

    <pre class="example" data-transform="updateExample"
         title="Sample Turtle document">
    <!--
    <http://me.markus-lanthaler.com/> <http://xmlns.com/foaf/0.1/name> "Markus Lanthaler" .
    <http://me.markus-lanthaler.com/> <http://xmlns.com/foaf/0.1/homepage> <http://www.markus-lanthaler.com/> .
    -->
    </pre>

    <p>Using the <a href="#serialize-rdf-as-json-ld-algorithm">Serialize RDF as JSON-LD algorithm</a>
      a developer could transform this document into expanded JSON-LD:</p>

    <pre class="example" data-transform="updateExample"
         title="Sample Turtle document converted to JSON-LD">
    <!--
    [
      {
        "@id": "http://me.markus-lanthaler.com/",
        "http://xmlns.com/foaf/0.1/name": [
          { "@value": "Markus Lanthaler" }
        ],
        "http://xmlns.com/foaf/0.1/homepage": [
          { "@id": "http://www.markus-lanthaler.com/" }
        ]
      }
    ]
    -->
    </pre>

    <p>Note that the output above could easily be compacted using the technique outlined
      in the previous section. It is also possible to deserialize the JSON-LD document back
      to RDF using the <a href="#deserialize-json-ld-to-rdf-algorithm">Deserialize JSON-LD to RDF algorithm</a>.</p>
  </section> <!-- end of RDF Serialization/Deserialization -->
</section> <!-- end of Features section -->


<section>
  <h1>Conformance</h1>

  <p>All examples and notes as well as sections marked as non-normative in this
    specification are non-normative. Everything else in this specification is
    normative.</p>

  <p>The keywords MUST, MUST NOT, REQUIRED, SHOULD, SHOULD NOT, RECOMMENDED,
    MAY, and OPTIONAL in this specification are to be interpreted as described
    in [[!RFC2119]].</p>

  <p>There are three classes of products that can claim conformance to this
    specification: <tref title="JSON-LD Processor">JSON-LD Processors</tref>,
    <tref title="JSON-LD API Implementation">JSON-LD API Implementations</tref>,
    and <tref title="RDF Serializer/Deserializer">RDF Serializers/Deserializers</tref>.</p>

  <p>A conforming <tdef>JSON-LD Processor</tdef> is a system which can perform the
    <a href="#expansion-algorithm">Expansion</a>, <a href="#compaction-algorithm">Compaction</a>,
    and <a href="#flattening-algorithm">Flattening</a> operations defined in this specification.</p>

  <p>A conforming <tdef>JSON-LD API Implementation</tdef> is a conforming <tref>JSON-LD Processor</tref>
    that exposes the <a href="#the-application-programming-interface">Application Programming Interface (API)</a>
    defined in this specification. It MUST implement the <code>json-ld-1.0</code>
    processing mode (for further details, see the
    <code class="idlMemberName"><a href="#widl-JsonLdOptions-processingMode">processingMode</a></code>
    option of <a>JsonLdOptions</a>).</p>

  <p><tref title="JSON-LD Processor">JSON-LD Processors</tref> and
    <tref title="JSON-LD API Implementation">API Implementations</tref> MUST NOT
    attempt to correct malformed <tref title="IRI">IRIs</tref> or language tags;
    however, they MAY issue validation warnings. IRIs are not modified other
    than conversion between <tref title="relative IRI">relative</tref> and
    <tref title="absolute IRI">absolute IRIs</tref>.</p>

  <p>A conforming <tdef>RDF Serializer/Deserializer</tdef> is a system that can
    <a href="#deserialize-json-ld-to-rdf-algorithm">deserialize JSON-LD to RDF</a> and
    <a href="#serialize-rdf-as-json-ld-algorithm">serialize RDF as JSON-LD</a> as
    defined in this specification.</p>

  <p>The algorithms in this specification are generally written with more concern for clarity
    than efficiency. Thus, <tref title="JSON-LD Processor">JSON-LD Processors</tref>
    and <tref title="JSON-LD API Implementation">API Implementations</tref> may
    implement the algorithms given in this specification in any way desired,
    so long as the end result is indistinguishable from the result that would
    be obtained by the specification's algorithms.</p>

  <p class="note">Implementers can partially check their level of conformance to
    this specification by successfully passing the test cases of the JSON-LD test
    suite [[JSON-LD-TESTS]]. Note, however, that passing all the tests in the test
    suite does not imply complete conformance to this specification. It only implies
    that the implementation conforms to aspects tested by the test suite.</p>
</section> <!-- end of Conformance section -->


<section>
  <h1>General Terminology</h1>

  <p>This document uses the following terms as defined in JSON [[!RFC4627]]. Refer
    to the <em>JSON Grammar</em> section in [[!RFC4627]] for formal definitions.</p>

  <dl>
    <dt><tdef>JSON object</tdef></dt>
    <dd>An object structure is represented as a pair of curly brackets surrounding
      zero or more key-value pairs. A key is a <tref>string</tref>.
      A single colon comes after each key, separating the key from the value.
      A single comma separates a value from a following key. In contrast to JSON,
      in JSON-LD the keys in an object must be unique.</dd>
    <dt><tdef>array</tdef></dt>
    <dd>An array structure is represented as square brackets surrounding zero
      or more values. Values are separated by commas.
      In JSON, an array is an <em>ordered</em> sequence of zero or more values.
      While JSON-LD uses the same array representation as JSON,
      the collection is <em>unordered</em> by default. While order is
      preserved in regular JSON arrays, it is not in regular JSON-LD arrays
      unless specifically defined (see
      <cite><a href="../json-ld/#sets-and-lists">Sets and Lists</a></cite> in
      the JSON-LD specification [[JSON-LD]]).</dd>
    <dt><tdef>string</tdef></dt>
    <dd>A string is a sequence of zero or more Unicode characters,
      wrapped in double quotes, using backslash escapes (if necessary). A
      character is represented as a single character string.</dd>
    <dt><tdef>number</tdef></dt>
    <dd>A number is similar to that used in most programming languages, except
      that the octal and hexadecimal formats are not used and that leading
      zeros are not allowed.</dd>
    <dt><tdef>true</tdef> and <tdef>false</tdef></dt>
    <dd>Values that are used to express one of two possible boolean states.</dd>
    <dt><tdef>null</tdef></dt>
    <dd>The <tref>null</tref> value. A key-value pair in the
      <code>@context</code> where the value, or the <code>@id</code> of the
      value, is <tref>null</tref> explicitly decouples a term's association
      with an IRI. A key-value pair in the body of a JSON-LD document whose
      value is <tref>null</tref> has the same meaning as if the key-value pair
      was not defined. If <code>@value</code>, <code>@list</code>, or
      <code>@set</code> is set to <tref>null</tref> in expanded form, then
      the entire <tref>JSON object</tref> is ignored.</dd>
  </dl>

  <p>Furthermore, the following terminology is used throughout this document:</p>

  <dl>
    <dt><tdef>keyword</tdef></dt>
    <dd>A JSON key that is specific to JSON-LD, specified in the section
      <cite><a href="../json-ld/#syntax-tokens-and-keywords">Syntax Tokens and Keywords</a></cite>
      of the JSON-LD specification [[!JSON-LD]].</dd>
    <dt><tdef>context</tdef></dt>
    <dd>A set of rules for interpreting a JSON-LD document as specified in the section
      <cite><a href="../json-ld/#the-context">The Context</a></cite> of the JSON-LD
      specification [[!JSON-LD]].</dd>
    <dt><tdef>JSON-LD document</tdef></dt>
    <dd>A <tref>JSON-LD document</tref> is a serialization of a collection of
      <tref title="graph">graphs</tref> and comprises exactly one
      <tref>default graph</tref> and zero or more <tref title="named graph">named graphs</tref>.</dd>
    <dt><tdef>named graph</tdef></dt>
    <dd>A named graph is a pair consisting of an <tref>IRI</tref> or <tref>blank node</tref>
      (the <tdef>graph name</tdef>) and a <tref>graph</tref>.</dd>
    <dt><tdef>default graph</tdef></dt>
    <dd>The default graph is the only graph in a JSON-LD document which has no <tref>graph name</tref>.</dd>
    <dt><tdef>Graph</tdef></dt>
    <dd>A labeled directed graph, i.e., a set of <tref title="node">nodes</tref>
      connected by <tref title="edge">edges</tref>,
      as specified in the <cite><a href="../json-ld/#data-model">Data Model</a></cite>
      section of the JSON-LD specification [[!JSON-LD]].</dd>
    <dt><tdef>edge</tdef></dt>
    <dd>Every <tref>edge</tref> has a direction associated with it and is labeled with
      an <tref>IRI</tref> or a <tref>blank node identifier</tref>. Within the JSON-LD syntax
      these edge labels are called <tdef title="property">properties</tdef>. Whenever possible, an
      <tref>edge</tref> should be labeled with an <tref>IRI</tref>.</dd>
    <dt><tdef>node</tdef></dt>
    <dd>Every <tref>node</tref> is an <tref>IRI</tref>, a <tref>blank node</tref>,
      a <tref>JSON-LD value</tref>, or a <tref>list</tref>.</dd>
    <dt><tdef><abbr title="Internationalized Resource Identifier">IRI</abbr></tdef></dt>
    <dd>An <tref>IRI</tref> (Internationalized Resource Identifier) is a string that conforms to the syntax
      defined in [[RFC3987]].</dd>
    <dt><tdef>absolute IRI</tdef></dt>
    <dd>An absolute IRI is defined in [[!RFC3987]] containing a <em>scheme</em> along with a <em>path</em> and
      optional <em>query</em> and fragment segments.</dd>
    <dt><tdef>relative IRI</tdef></dt>
    <dd>A relative IRI is an IRI that is relative to some other <tref>absolute IRI</tref>.</dd>
    <dt><tdef>blank node</tdef></dt>
    <dd>A <tref>node</tref> in a <tref>graph</tref> that is neither an
      <tref>IRI</tref>, nor a <tref>JSON-LD value</tref>, nor a <tref>list</tref>.</dd>
    <dt><tdef>blank node identifier</tdef></dt>
    <dd>A blank node identifier is a string that can be used as an identifier for a
      <tref>blank node</tref> within the scope of a JSON-LD document. Blank node identifiers
      begin with <code>_:</code>.</dd>
    <dt><tdef>JSON-LD value</tdef></dt>
    <dd>A <tref>JSON-LD value</tref> is a <tref>string</tref>, a <tref>number</tref>,
      <tref>true</tref> or <tref>false</tref>, a <tref>typed value</tref>, or a
      <tref>language-tagged string</tref>.</dd>
    <dt><tdef>typed value</tdef></dt>
    <dd>A <tref>typed value</tref> consists of a value, which is a string, and a type,
      which is an <tref>IRI</tref>.</dd>
    <dt><tdef>language-tagged string</tdef></dt>
    <dd>A <tref>language-tagged string</tref> consists of a string and a non-empty language
      tag as defined by [[BCP47]]. The language tag must be well-formed according to
      <a href="http://tools.ietf.org/html/bcp47#section-2.2.9">section 2.2.9 Classes of Conformance</a>
      of [[BCP47]], and is normalized to lowercase.</dd>
    <dt><tdef>list</tdef></dt>
    <dd>A <tref>list</tref> is an ordered sequence of <tref title="IRI">IRIs</tref>,
      <tref title="blank node">blank nodes</tref>, and
      <tref title="JSON-LD value">JSON-LD values</tref>.</dd>
  </dl>
</section> <!-- end of General Terminology section -->


<section>
  <h1>Algorithm Terms</h1>

  <dl>
    <dt><tdef>active graph</tdef></dt>
    <dd>The name of the currently active graph that the processor should use when
      processing.</dd>
    <dt><tdef>active subject</tdef></dt>
    <dd>The currently active subject that the processor should use when
      processing.</dd>
    <dt><tdef>active property</tdef></dt>
    <dd>The currently active <tref>property</tref> or <tref>keyword</tref> that
      the processor should use when processing.</dd>
    <dt><tdef>active context</tdef></dt>
    <dd>A context that is used to resolve <tref title="term">terms</tref> while
      the processing algorithm is running.</dd>
    <dt><tdef>local context</tdef></dt>
    <dd>A context that is specified within a <tref>JSON object</tref>,
      specified via the <code>@context</code> <tref>keyword</tref>.</dd>
    <dt><tdef>JSON-LD input</tdef></dt>
    <dd>The JSON-LD data structure that is provided as input to the algorithm.</dd>
    <dt><tdef>term</tdef></dt>
    <dd>A <tref>term</tref> is a short word defined in a context that may be expanded to
      an <tref>IRI</tref></dd>
    <dt><tdef>compact IRI</tdef></dt>
    <dd>A compact IRI has the form of <tdef>prefix</tdef>:<em>suffix</em> and is used as a way
      of expressing an IRI without needing to define separate <tref>term</tref> definitions for
      each IRI contained within a common vocabulary identified by <tref>prefix</tref>.</dd>
    <dt><tdef>node object</tdef></dt>
    <dd>A <tref>node object</tref> represents zero or more properties of a
      <tref>node</tref> in the <tref>graph</tref> serialized by the
      JSON-LD document. A <tref>JSON object</tref> is a <tref>node object</tref>
      if it exists outside of the JSON-LD <tref>context</tref> and:
      <ul>
        <li>it does not contain the <code>@value</code>, <code>@list</code>,
          or <code>@set</code> keywords, or</li>
        <li>it is not the top-most <tref>JSON object</tref> in the JSON-LD document consisting
          of no other members than <code>@graph</code> and <code>@context</code>.</li>
      </ul>
    </dd>
    <dt><tdef>value object</tdef></dt>
    <dd>A <tref>value object</tref> is a <tref>JSON object</tref> that has an <code>@value</code>
      member.</dd>
    <dt><tdef>list object</tdef></dt>
    <dd>A <tref>list object</tref> is a <tref>JSON object</tref> that has an <code>@list</code>
      member.</dd>
    <dt><tdef>set object</tdef></dt>
    <dd>A <tref>set object</tref> is a <tref>JSON object</tref> that has an <code>@set</code>
      member.</dd>
    <dt><tdef>scalar</tdef></dt>
    <dd>A scalar is either a JSON <tref>string</tref>, <tref>number</tref>, <tref>true</tref>,
      or <tref>false</tref>.</dd>
    <dt><tdef>RDF subject</tdef></dt>
    <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-subject">subject</tref>
      as specified by [[RDF11-CONCEPTS]].</dd>
    <dt><tdef>RDF predicate</tdef></dt>
    <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-predicate">predicate</tref>
      as specified by [[RDF11-CONCEPTS]].</dd>
    <dt><tdef>RDF object</tdef></dt>
    <dd>An <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-object">object</tref>
      as specified by [[RDF11-CONCEPTS]].</dd>
    <dt><tdef>RDF triple</tdef></dt>
    <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">triple</tref>
      as specified by [[RDF11-CONCEPTS]].</dd>
    <dt><tdef>RDF dataset</tdef></dt>
    <dd>A <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-dataset">dataset</tref>
      as specified by [[RDF11-CONCEPTS]] representing a collection of
      <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graphs</tref>.</dd>
  </dl>
</section> <!-- end of Algorithm Terms section -->


<section>
  <h1>Context Processing Algorithms</h1>

  <section>
    <h2>Context Processing Algorithm</h2>

    <p>When processing a JSON-LD data structure, each processing rule is applied
      using information provided by the <tref>active context</tref>. This
      section describes how to produce an <tref>active context</tref>.</p>

    <p>The <tref>active context</tref> contains the active
      <tdef title="term definition">term definitions</tdef> which specify how
      properties and values have to be interpreted as well as the current <tdef>base IRI</tdef>,
      the <tdef>vocabulary mapping</tdef> and the <tdef>default language</tdef>. Each
      <tref>term definition</tref> consists of an <tdef>IRI mapping</tdef>, a boolean
      flag <tdef>reverse property</tdef>, an optional <tdef>type mapping</tdef>
      or <tdef>language mapping</tdef>, and an optional  <tdef>container mapping</tdef>.
      A <tref>term definition</tref> can not only be used to map a <tref>term</tref>
      to an IRI, but also to map a <tref>term</tref> to a <tref>keyword</tref>,
      in which case it is referred to as a <tdef>keyword alias</tdef>.</p>

    <p>When processing, the <tref>active context</tref> is initialized
      without any <tref title="term definition">term definitions</tref>,
      <tref>vocabulary mapping</tref>, or <tref>default language</tref>.
      If a <tref>local context</tref> is encountered during processing, a new
      <tref>active context</tref> is created by cloning the existing
      <tref>active context</tref>. Then the information from the
      <tref>local context</tref> is merged into the new <tref>active context</tref>.
      Given that <tref title="local context">local contexts</tref> may contain
      references to remote contexts, this includes their retrieval.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>First we prepare a new <tref>active context</tref> <i>result</i> by cloning
        the current <tref>active context</tref>. Then we normalize the form of the passed
        <tref>local context</tref> to an <tref>array</tref>.
        <tref title="local context">Local contexts</tref> may be in the form of a
        <tref>JSON object</tref>, a <tref>string</tref>, or an <tref>array</tref> containing
        a combination of the two. Finally we process each <tref>context</tref> contained
        in the <tref>local context</tref> <tref>array</tref> as follows.</p>

      <p>If <tref>context</tref> is a <tref>string</tref>, it represents a reference to
        a remote context. We dereference the remote context and replace <tref>context</tref>
        with the value of the <code>@context</code> key of the top-level object in the
        retrieved JSON-LD document. If there's no such key, an invalid remote context has
        been detected. Otherwise, we process <tref>context</tref> by recursively using
        this algorithm ensuring that there is no cyclical reference.</p>

      <p>If <tref>context</tref> is a <tref>JSON object</tref>, we first update the
        <tref>base IRI</tref>, the <tref>vocabulary mapping</tref>, and the
        <tref>default language</tref> by processing three specific keywords:
        <code>@base</code>, <code>@vocab</code>, and <code>@language</code>.
        These are handled before any other keys in the <tref>local context</tref> because
        they affect how the other keys are processed. Please note that <code>@base</code> is
        ignored when processing remote contexts.</p>

      <p>Then, for every other key in <tref>local context</tref>, we update
        the <tref>term definition</tref> in <i>result</i>. Since
        <tref title="term definition">term definitions</tref> in a <tref>local context</tref>
        may themselves contain <tref title="term">terms</tref> or
        <tref title="compact IRI">compact IRIs</tref>, we may need to recurse.
        When doing so, we must ensure that there is no cyclical dependency,
        which is an error. After we have processed any
        <tref title="term definition">term definition</tref> dependencies,
        we update the current <tref title="term definition">term definition</tref>,
        which may be a <tref>keyword alias</tref>.</p>

      <p>Finally, we return <i>result</i> as the new <tref>active context</tref>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>This algorithm specifies how a new <tref>active context</tref> is updated
        with a <tref>local context</tref>. The algorithm takes three input variables:
        an <tref>active context</tref>, a <tref>local context</tref>, and an  <tref>array</tref>
        <i>remote contexts</i> which is used to detect cyclical context inclusions.
        If <i>remote contexts</i> is not passed, it is initialized to an empty
        <tref>array</tref>.</p>

      <div class="issue atrisk" id="at-risk-10" data-number="10" title="Support for @base: null ">
        <p class="atrisk-head">Note: This feature is
          <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a> and may
          be removed from this specification based on feedback. Please send feedback to
          <a href="mailto:public-rdf-comments@w3.org">public-rdf-comments@w3.org</a>.
          For the current status see
          <a href="http://www.w3.org/2011/rdf-wg/wiki/JSON-LD_Features_at_Risk">features "at risk" in JSON-LD 1.0</a></p>
       <p>Unlike many other serialization formats, JSON-LD allows to specify that
        there is no base IRI from within the document (by setting <code>@base</code> to
        <tref>null</tref>). The result is that the algorithm for establishing a base IRI
        as specified in <a href="http://tools.ietf.org/html/rfc3986#section-5.1">RFC3986 section 5.1</a>
        is overridden so relative IRIs remain relative IRIs even in the case that an IRI
        would be available in one of the outer layers (e.g., the IRI used to retrieve
        the document or an application supplied base IRI). Based on implementer feedback,
        the Working Group may decide to remove this feature from JSON-LD 1.0.</p>
      </div>

      <ol class="algorithm">
        <li>Initialize <i>result</i> to the result of cloning
          <tref>active context</tref>.</li>
        <li>If <tref>local context</tref> is not an <tref>array</tref>,
          set it to an <tref>array</tref> containing only
          <tref>local context</tref>.</li>
        <li>
          For each item <i>context</i> in <tref>local context</tref>:
          <ol class="algorithm">
            <li>If <i>context</i> is <tref>null</tref>, set <i>result</i> to a
              newly-initialized <tref>active context</tref> and continue with the
              next <i>context</i>. The <tref>base IRI</tref> of the
              <tref>active context</tref> is set to the IRI of the currently being processed
              document (which might be different from the currently being processed context),
              if available; otherwise to <tref>null</tref>. If set, the
              <code class="idlMemberName"><a href="#widl-JsonLdOptions-base">base</a></code>
              option of a <tref>JSON-LD API Implementation</tref> overrides the <tref>base IRI</tref>.</li>
            <li>If <i>context</i> is a <tref>string</tref>,
              <ol class="algorithm">
                <li>Set <i>context</i> to the result of resolving <i>value</i> against
                  the base IRI which is established as specified in
                  <cite><a href="http://tools.ietf.org/html/rfc3986#section-5.1">section 5.1 Establishing a Base URI</a></cite>
                  of [[!RFC3986]]. Only the basic algorithm in
                  <cite><a href="http://tools.ietf.org/html/rfc3986#section-5.2">section 5.2</a></cite>
                  of [[!RFC3986]] is used; neither
                  <cite><a href="http://tools.ietf.org/html/rfc3986#section-6.2.2">Syntax-Based Normalization</a></cite> nor
                  <cite><a href="http://tools.ietf.org/html/rfc3986#section-6.2.3">Scheme-Based Normalization</a></cite>
                  are performed. Characters additionally allowed in IRI
                  references are treated in the same way that unreserved
                  characters are treated in URI references, per
                  <cite><a href="http://tools.ietf.org/html/rfc3987#section-6.5">section 6.5</a></cite>
                  of [[!RFC3987]].</li>
                <li>If <i>context</i> is in the <i>remote contexts</i> array, a
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.recursive-context-inclusion">recursive context inclusion</a></code>
                  error has been detected and processing is aborted;
                  otherwise, add <i>context</i> to <i>remote contexts</i>.</li>
                <li>Dereference <i>context</i>. If <i>context</i> cannot be dereferenced, a
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.loading-remote-context-failed">loading remote context failed</a></code>
                  error has been detected and processing is aborted. If the dereferenced document has no
                  top-level <tref>JSON object</tref> with an <code>@context</code> member, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-remote-context">invalid remote context</a></code>
                  has been detected and processing is aborted; otherwise,
                  set <i>context</i> to the value of that member.</li>
                <li>Set <i>result</i> to the result of recursively calling this algorithm,
                  passing <i>result</i> for <tref>active context</tref>,
                  <i>context</i> for <tref>local context</tref>, and <i>remote contexts</i>.</li>
                <li>Continue with the next <i>context</i>.</li>
              </ol>
            </li>
            <li>If <i>context</i> is not a <tref>JSON object</tref>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-local-context">invalid local context</a></code>
              error has been detected and processing is aborted.</li>
            <li>If <i>context</i> has an <code>@base</code> key and <i>remote contexts</i> is empty, i.e., the currently
              being processed context is not a remote context:
              <ol class="algorithm">
                <li>Initialize <i>value</i> to the value associated with the
                  <code>@base</code> key.</li>
                <li>If <i>value</i> is <tref>null</tref>, remove the
                  <tref>base IRI</tref> of <i>result</i>.</li>
                <li>Otherwise, if <i>value</i> is an <tref>absolute IRI</tref>,
                  the <tref>base IRI</tref> of <i>result</i> is set to <i>value</i>.</li>
                <li>Otherwise, if <i>value</i> is a <tref>relative IRI</tref> and
                  the <tref>base IRI</tref> of <i>result</i> is not <tref>null</tref>,
                  set the <tref>base IRI</tref> of <i>result</i> to the result of
                  resolving <i>value</i> against the current <tref>base IRI</tref>
                  of <i>result</i>.</li>
                <li>Otherwise, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-base-IRI">invalid base IRI</a></code>
                  error has been detected and processing is aborted.</li>
              </ol>
            </li>
            <li>If <i>context</i> has an <code>@vocab</code> key:
              <ol class="algorithm">
                <li>Initialize <i>value</i> to the value associated with the
                  <code>@vocab</code> key.</li>
                <li>If <i>value</i> is <tref>null</tref>, remove
                  any <tref>vocabulary mapping</tref> from <i>result</i>.</li>
                <li>Otherwise, if <i>value</i> is an <tref>absolute IRI</tref>
                  or <tref>blank node identifier</tref>, the <tref>vocabulary mapping</tref>
                  of <i>result</i> is set to <i>value</i>. If it is not an
                  <tref>absolute IRI</tref> or <tref>blank node identifier</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-vocab-mapping">invalid vocab mapping</a></code>
                  error has been detected and processing is aborted.</li>
              </ol>
            </li>
            <li>If <i>context</i> has an <code>@language</code> key:
              <ol class="algorithm">
                <li>Initialize <i>value</i> to the value associated with the
                  <code>@language</code> key.</li>
                <li>If <i>value</i> is <tref>null</tref>, remove
                  any <tref>default language</tref> from <i>result</i>.</li>
                <li>Otherwise, if <i>value</i> is <tref>string</tref>, the
                  <tref>default language</tref> of <i>result</i> is set to
                  lowercased <i>value</i>. If it is not a <tref>string</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-default-language">invalid default language</a></code>
                  error has been detected and processing is aborted.</li>
              </ol>
            </li>
            <li>Create a <tref>JSON object</tref> <i>defined</i> to use to keep
              track of whether or not a <tref>term</tref> has already been defined
              or currently being defined during recursion.</li>
            <li>For each <i>key</i>-<i>value</i> pair in <i>context</i> where
              <i>key</i> is not <code>@base</code>, <code>@vocab</code>, or
              <code>@language</code>, invoke the
              <a href="#create-term-definition">Create Term Definition algorithm</a>,
              passing <i>result</i> for <tref>active context</tref>,
              <i>context</i> for <tref>local context</tref>, <i>key</i>,
              and <i>defined</i>.</li>
          </ol>
        </li>
        <li>Return <i>result</i>.</li>
      </ol>
    </section>
  </section> <!-- end of Context Processing -->

  <section>
    <h2>Create Term Definition</h2>

    <p>This algorithm is called from the
      <a href="#context-processing-algorithm">Context Processing algorithm</a>
      to create a <tref>term definition</tref> in the <tref>active context</tref>
      for a <tref>term</tref> being processed in a <tref>local context</tref>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p><tref title="term definition">Term definitions</tref> are created by
        parsing the information in the given <tref>local context</tref> for the
        given <tref>term</tref>. If the given <tref>term</tref> is a
        <tref>compact IRI</tref>, it may omit an <tref>IRI mapping</tref> by
        depending on its <tref>prefix</tref> having its own
        <tref>term definition</tref>. If the <tref>prefix</tref> is
        a key in the <tref>local context</tref>, then its <tref>term definition</tref>
        must first be created, through recursion, before continuing. Because a
        <tref>term definition</tref> can depend on other
        <tref title="term definition">term definitions</tref>, a mechanism must
        be used to detect cyclical dependencies. The solution employed here
        uses a map, <i>defined</i>, that keeps track of whether or not a
        <tref>term</tref> has been defined or is currently in the process of
        being defined. This map is checked before any recursion is attempted.</p>

      <p>After all dependencies for a <tref>term</tref> have been defined, the rest of
        the information in the <tref>local context</tref> for the given
        <tref>term</tref> is taken into account, creating the appropriate
        <tref>IRI mapping</tref>, <tref>container mapping</tref>, and
        <tref>type mapping</tref> or <tref>language mapping</tref> for the
        <tref>term</tref>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm has four required inputs which are:
        an <tref>active context</tref>, a <tref>local context</tref>,
        a <i>term</i>, and a map <i>defined</i>.</p>

      <ol class="algorithm">
        <li>If <i>defined</i> contains the key <i>term</i> and the associated
          value is <tref>true</tref> (indicating that the
          <tref>term definition</tref> has already been created), return. Otherwise,
          if the value is <tref>false</tref>, a
          <code class="error"><a href="#idl-def-JsonLdErrorCode.cyclic-IRI-mapping">cyclic IRI mapping</a></code>
          error has been detected and processing is aborted.</li>
        <li>Set the value associated with <i>defined</i>'s <i>term</i> key to
          <tref>false</tref>. This indicates that the <tref>term definition</tref>
          is now being created but is not yet complete.</li>
        <li>Since <tref title="keyword">keywords</tref> cannot be overridden,
          <i>term</i> must not be a <tref>keyword</tref>. Otherwise, a
          <code class="error"><a href="#idl-def-JsonLdErrorCode.keyword-redefinition">keyword redefinition</a></code>
          error has been detected and processing is aborted.</li>
        <li>Remove any existing <tref>term definition</tref> for <i>term</i> in
          <tref>active context</tref>.</li>
        <li>Initialize <i>value</i> to a copy of the value associated with the key
          <i>term</i> in <tref>local context</tref>.</li>
        <li>If <i>value</i> is <tref>null</tref> or <i>value</i>
          is a <tref>JSON object</tref> containing the key-value pair
          <code>@id</code>-<tref>null</tref>, set the
          <tref>term definition</tref> in <tref>active context</tref> to
          <tref>null</tref>, set the value associated with <i>defined</i>'s
          key <i>term</i> to <tref>true</tref>, and return.</li>
        <li>Otherwise, if <i>value</i> is a <tref>string</tref>, convert it
          to a <tref>JSON object</tref> consisting of a single member whose
          key is <code>@id</code> and whose value is <i>value</i>.</li>
        <li>Otherwise, <i>value</i> must be a <tref>JSON object</tref>, if not, an
          <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-term-definition">invalid term definition</a></code>
          error has been detected and processing is aborted.</li>
        <li>Create a new <tref>term definition</tref>, <i>definition</i>.</li>
        <li>If <i>value</i> contains the key <code>@type</code>:
          <ol class="algorithm">
            <li>Initialize <i>type</i> to the value associated with the
              <code>@type</code> key, which must be a <tref>string</tref>. Otherwise, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-type-mapping">invalid type mapping</a></code>
              error has been detected and processing is aborted.</li>
            <li>Set <i>type</i> to the result of using the
              <a href="#iri-expansion">IRI Expansion algorithm</a>, passing
              <tref>active context</tref>, <i>type</i> for <i>value</i>,
              <tref>true</tref> for <i>vocab</i>,
              <tref>false</tref> for <i>document relative</i>,
              <tref>local context</tref>, and <i>defined</i>. If the expanded <i>type</i> is
              neither <code>@id</code>, nor <code>@vocab</code>, nor an <tref>absolute IRI</tref>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-type-mapping">invalid type mapping</a></code>
              error has been detected and processing is aborted.</li>
            <li>Set the <tref>type mapping</tref> for <i>definition</i> to <i>type</i>.</li>
          </ol>
        </li>
        <li>If <i>value</i> contains the key <code>@reverse</code>:
          <ol class="algorithm">
            <li>If <i>value</i> contains an <code>@id</code>, member, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-reverse-property">invalid reverse property</a></code>
              error has been detected and processing is aborted.</li>
            <li>If the value associated with the <code>@reverse</code> key
              is not a <tref>string</tref>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-IRI-mapping">invalid IRI mapping</a></code>
              error has been detected and processing is aborted.</li>
            <li>Otherwise, set the <tref>IRI mapping</tref> of <i>definition</i> to the
              result of using the <a href="#iri-expansion">IRI Expansion algorithm</a>,
              passing <tref>active context</tref>, the value associated with
              the <code>@reverse</code> key for <i>value</i>, <tref>true</tref>
              for <i>vocab</i>, <tref>false</tref> for <i>document relative</i>,
              <tref>local context</tref>, and <i>defined</i>. If the result
              is neither an <tref>absolute IRI</tref> nor a <tref>blank node identifier</tref>,
              i.e., it contains no colon (<code>:</code>), an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-IRI-mapping">invalid IRI mapping</a></code>
              error has been detected and processing is aborted.</li>
            <li>If <i>value</i> contains an <code>@container</code> member,
              set the <tref>container mapping</tref> of <i>definition</i>
              to its value; if its value is neither <code>@set</code>, nor
              <code>@index</code>, nor <tref>null</tref>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-reverse-property">invalid reverse property</a></code>
              error has been detected (reverse properties only support set- and
              index-containers) and processing is aborted.</li>
            <li>Set the <tref>reverse property</tref> flag of <i>definition</i>
              to <tref>true</tref>.</li>
            <li>Set the <tref>term definition</tref> of <i>term</i> in
              <tref>active context</tref> to <i>definition</i> and the
              value associated with <i>defined</i>'s key <i>term</i> to
              <tref>true</tref> and return.</li>
          </ol>
        </li>
        <li>Set the <tref>reverse property</tref> flag of <i>definition</i>
          to <tref>false</tref>.</li>
        <li>If <i>value</i> contains the key <code>@id</code> and its value
          does not equal <i>term</i>:
          <ol class="algorithm">
            <li>If the value associated with the <code>@id</code> key is not a <tref>string</tref>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-IRI-mapping">invalid IRI mapping</a></code>
              error has been detected and processing is aborted.</li>
            <li>Otherwise, set the <tref>IRI mapping</tref> of <i>definition</i> to the
              result of using the <a href="#iri-expansion">IRI Expansion algorithm</a>, passing
              <tref>active context</tref>, the value associated with the <code>@id</code> key for
              <i>value</i>, <tref>true</tref> for <i>vocab</i>,
              <tref>false</tref> for <i>document relative</i>,
              <tref>local context</tref>, and <i>defined</i>. If the resulting
              <tref>IRI mapping</tref> is neither a <tref>keyword</tref>, nor an
              <tref>absolute IRI</tref>, nor a <tref>blank node identifier</tref>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-IRI-mapping">invalid IRI mapping</a></code>
              error has been detected and processing is aborted; if it equals <code>@context</code>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-keyword-alias">invalid keyword alias</a></code>
              error has been detected and processing is aborted.</li>
          </ol>
        </li>
        <li>
          Otherwise if the <i>term</i> contains a colon (<code>:</code>):
          <ol class="algorithm">
            <li>If <i>term</i> is a <tref>compact IRI</tref> with a
              <tref>prefix</tref> that is a key in <tref>local context</tref>
              a dependency has been found. Use this algorithm recursively passing
              <tref>active context</tref>, <tref>local context</tref>, the
              <tref>prefix</tref> as <i>term</i>, and <i>defined</i>.</li>
            <li>If <i>term</i>'s <tref>prefix</tref> has a
              <tref>term definition</tref> in <tref>active context</tref>, set
              the <tref>IRI mapping</tref> of <i>definition</i> to the result of
              concatenating the value associated with the <tref>prefix</tref>'s
              <tref>IRI mapping</tref> and the <i>term</i>'s <i>suffix</i>.</li>
            <li>Otherwise, <i>term</i> is an <tref>absolute IRI</tref> or
              <tref>blank node identifier</tref>. Set the <tref>IRI mapping</tref>
              of <i>definition</i> to <i>term</i>.</li>
          </ol>
        </li>
        <li>Otherwise, if <tref>active context</tref> has a
          <tref>vocabulary mapping</tref>, the <tref>IRI mapping</tref>
          of <i>definition</i> is set to the result of concatenating the value
          associated with the <tref>vocabulary mapping</tref> and <i>term</i>.
          If it does not have a <tref>vocabulary mapping</tref>, an
          <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-IRI-mapping">invalid IRI mapping</a></code>
          error been detected and processing is aborted.</li>
        <li>If <i>value</i> contains the key <code>@container</code>:
          <ol class="algorithm">
            <li>Initialize <i>container</i> to the value associated with the
              <code>@container</code> key, which must be either
              <code>@list</code>, <code>@set</code>, <code>@index</code>,
              or <code>@language</code>. Otherwise, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-container-mapping">invalid container mapping</a></code> error
              has been detected and processing is aborted.</li>
            <li>Set the <tref>container mapping</tref> of <i>definition</i> to
              <i>container</i>.</li>
          </ol>
        </li>
        <li>If <i>value</i> contains the key <code>@language</code> and
          does not contain the key <code>@type</code>:
          <ol class="algorithm">
            <li>Initialize <i>language</i> to the value associated with the
              <code>@language</code> key, which must be either <tref>null</tref>
              or a <tref>string</tref>. Otherwise, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-language-mapping">invalid language mapping</a></code>
              error has been detected and processing is aborted.</li>
            <li>If <i>language</i> is a <tref>string</tref> set it to
              lowercased <i>language</i>. Set the <tref>language mapping</tref>
              of <i>definition</i> to <i>language</i>.</li>
          </ol>
        </li>
        <li>Set the <tref>term definition</tref> of <i>term</i> in
          <tref>active context</tref> to <i>definition</i> and set the value
          associated with <i>defined</i>'s key <i>term</i> to
          <tref>true</tref>.</li>
      </ol>
    </section>
  </section> <!-- end of Term Creation -->

  <section>
    <h2>IRI Expansion</h2>

    <p>In JSON-LD documents, some keys and values may represent
      <tref title="IRI">IRIs</tref>. This section defines an algorithm for
      transforming a <tref>string</tref> that represents an <tref>IRI</tref> into
      an <tref>absolute IRI</tref> or <tref>blank node identifier</tref>.
      It also covers transforming <tref title="keyword alias">keyword aliases</tref>
      into <tref title="keyword">keywords</tref>.</p>

    <p><tref>IRI</tref> expansion may occur during context processing or during
      any of the other JSON-LD algorithms. If IRI expansion occurs during context
      processing, then the <tref>local context</tref> and its related <i>defined</i>
      map from the <a href="#context-processing-algorithm">Context Processing algorithm</a>
      are passed to this algorithm. This allows for <tref>term definition</tref>
      dependencies to be processed via the
      <a href="#create-term-definition">Create Term Definition algorithm</a>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>In order to expand <i>value</i> to an <tref>absolute IRI</tref>, we must
        first determine if it is <tref>null</tref>, a <tref>term</tref>, a
        <tref>keyword alias</tref>, or some form of <tref>IRI</tref>. Based on what
        we find, we handle the specific kind of expansion; for example, we expand
        a <tref>keyword alias</tref> to a <tref>keyword</tref> and a <tref>term</tref>
        to an <tref>absolute IRI</tref> according to its <tref>IRI mapping</tref>
        in the <tref>active context</tref>. While inspecting <i>value</i> we
        may also find that we need to create <tref>term definition</tref>
        dependencies because we're running this algorithm during context processing.
        We can tell whether or not we're running during context processing by
        checking <tref>local context</tref> against <tref>null</tref>.
        We know we need to create a <tref>term definition</tref> in the
        <tref>active context</tref> when <i>value</i> is
        a key in the <tref>local context</tref> and the <i>defined</i> map
        does not have a key for <i>value</i> with an associated value of
        <tref>true</tref>. The <i>defined</i> map is used during
        <a href="#context-processing-algorithm">Context Processing</a> to keep track of
        which <tref title="term">terms</tref> have already been defined or are
        in the process of being defined. We create a
        <tref>term definition</tref> by using the
        <a href="#create-term-definition">Create Term Definition algorithm</a>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes two required and four optional input variables. The
        required inputs are an <tref>active context</tref> and a <i>value</i>
        to be expanded. The optional inputs are two flags,
        <i>document relative</i> and <i>vocab</i>, that specifying
        whether <i>value</i> can be interpreted as a <tref>relative IRI</tref>
        against the document's base <tref>IRI</tref> or the
        <tref title="active context">active context's</tref>
        <tref>vocabulary mapping</tref>, respectively, and
        a <tref>local context</tref> and a map <i>defined</i> to be used when
        this algorithm is used during <a href="#context-processing-algorithm">Context Processing</a>.
        If not passed, the two flags are set to <code>false</code> and
        <tref>local context</tref> and <i>defined</i> are initialized to <tref>null</tref>.</p>

      <ol class="algorithm">
        <li>If <i>value</i> is a <tref>keyword</tref> or <tref>null</tref>,
          return <i>value</i> as is.</li>
        <li>If <tref>local context</tref> is not <tref>null</tref>, it contains
          a key that equals <i>value</i>, and the value associated with the key
          that equals <i>value</i> in <i>defined</i> is not <tref>true</tref>,
          invoke the <a href="#create-term-definition">Create Term Definition algorithm</a>,
          passing <tref>active context</tref>, <tref>local context</tref>,
          <i>value</i> as <i>term</i>, and <i>defined</i>. This will ensure that
          a <tref>term definition</tref> is created for <i>value</i> in
          <tref>active context</tref> during <a href="#context-processing-algorithm">Context Processing</a>.
        </li>
        <li>If <i>vocab</i> is <tref>true</tref> and the
          <tref>active context</tref> has a <tref>term definition</tref> for
          <i>value</i>, return the associated <tref>IRI mapping</tref>.</li>
        <li>If <i>value</i> contains a colon (<code>:</code>), it is either
          an <tref>absolute IRI</tref>, a <tref>compact IRI</tref>, or a
          <tref>blank node identifier</tref>:
          <ol class="algorithm">
            <li>Split <i>value</i> into a <tref>prefix</tref> and <i>suffix</i>
              at the first occurrence of a colon (<code>:</code>).</li>
            <li>If <tref>prefix</tref> is underscore (<code>_</code>)
              or <i>suffix</i> begins with double-forward-slash
              (<code>//</code>), return <i>value</i> as it is already an
              <tref>absolute IRI</tref> or a <tref>blank node identifier</tref>.</li>
            <li>If <tref>local context</tref> is not <tref>null</tref>, it
              contains a key that equals <tref>prefix</tref>, and the value
              associated with the key that equals <i>prefix</i> in <i>defined</i>
              is not <tref>true</tref>, invoke the
              <a href="#create-term-definition">Create Term Definition algorithm</a>,
              passing <tref>active context</tref>,
              <tref>local context</tref>, <i>prefix</i> as <i>term</i>,
              and <i>defined</i>. This will ensure that a
              <tref>term definition</tref> is created for <tref>prefix</tref>
              in <tref>active context</tref> during
              <a href="#context-processing-algorithm">Context Processing</a>.</li>
            <li>If <tref>active context</tref> contains a <tref>term definition</tref>
              for <tref>prefix</tref>, return the result of concatenating
              the <tref>IRI mapping</tref> associated with <tref>prefix</tref> and
              <i>suffix</i>.</li>
            <li>Return <i>value</i> as it is already an <tref>absolute IRI</tref>.</li>
          </ol>
        </li>
        <li>If <i>vocab</i> is <tref>true</tref>, and
          <tref>active context</tref> has a <tref>vocabulary mapping</tref>,
          return the result of concatenating the <tref>vocabulary mapping</tref>
          with <i>value</i>.</li>
        <li>Otherwise, if <i>document relative</i> is <tref>true</tref>,
          set <i>value</i> to the result of resolving <i>value</i> against
          the <tref>base IRI</tref>. Only the basic algorithm in
          <cite><a href="http://tools.ietf.org/html/rfc3986#section-5.2">section 5.2</a></cite>
          of [[!RFC3986]] is used; neither
          <cite><a href="http://tools.ietf.org/html/rfc3986#section-6.2.2">Syntax-Based Normalization</a></cite> nor
          <cite><a href="http://tools.ietf.org/html/rfc3986#section-6.2.3">Scheme-Based Normalization</a></cite>
          are performed. Characters additionally allowed in IRI references are treated
          in the same way that unreserved characters are treated in URI references, per
          <cite><a href="http://tools.ietf.org/html/rfc3987#section-6.5">section 6.5</a></cite>
          of [[!RFC3987]].</li>
        <li>Return <i>value</i> as is.</li>
      </ol>
    </section>
  </section> <!-- end of IRI Expansion -->
</section> <!-- end of Context Processing section -->


<section>
  <h1>Expansion Algorithms</h1>

  <section>
    <h2>Expansion Algorithm</h2>

    <p>This algorithm expands a JSON-LD document, such that all <tref>context</tref>
      definitions are removed, all <tref title="term">terms</tref> and
      <tref title="compact IRI">compact IRIs</tref> are expanded to
      <tref title="absolute IRI">absolute IRIs</tref>,
      <tref title="blank node identifier">blank node identifiers</tref>, or
      <tref title="keyword">keywords</tref> and all
      <tref title="JSON-LD value">JSON-LD values</tref> are expressed in
      <tref title="array">arrays</tref> in <tref>expanded form</tref>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>Starting with its root <i>element</i>, we can process the
        JSON-LD document recursively, until we have a fully
        <tref title="expansion">expanded</tref> <i>result</i>. When
        <tref title="expansion">expanding</tref> an <i>element</i>, we can treat
        each one differently according to its type, in order to break down the
        problem:</p>

      <ol>
        <li>If the <i>element</i> is <tref>null</tref>, there is nothing
          to expand.</li>
        <li>Otherwise, if <i>element</i> is a <tref>scalar</tref>, we expand it
          according to the <a href="#value-expansion">Value Expansion algorithm</a>.</li>
        <li>Otherwise, if the <i>element</i> is an <tref>array</tref>, then we expand
          each of its items recursively and return them in a new
          <tref>array</tref>.</li>
        <li>Otherwise, <i>element</i> is a <tref>JSON object</tref>. We expand
          each of its keys, adding them to our <i>result</i>, and then we expand
          each value for each key recursively. Some of the keys will be
          <tref title="term">terms</tref> or
          <tref title="compact IRI">compact IRIs</tref> and others will be
          <tref title="keyword">keywords</tref> or simply ignored because
          they do not have definitions in the <tref>context</tref>. Any
          <tref title="IRI">IRIs</tref> will be expanded using the
          <a href="#iri-expansion">IRI Expansion algorithm</a>.
        </li>
      </ol>

      <p>Finally, after ensuring <i>result</i> is in an <tref>array</tref>,
        we return <i>result</i>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes three input variables: an <tref>active context</tref>,
        an <tref>active property</tref>, and an <i>element</i> to be expanded.
        To begin, the <tref>active property</tref> is set to <tref>null</tref>,
        and <i>element</i> is set to the <tref>JSON-LD input</tref>.</p>

      <ol class="algorithm">
        <li>If <i>element</i> is <tref>null</tref>, return <tref>null</tref>.</li>
        <li>If <i>element</i> is a <tref>scalar</tref>,
          <ol class="algorithm">
            <li>If <tref>active property</tref> is <tref>null</tref> or <code>@graph</code>,
              drop the free-floating <tref>scalar</tref> by returning <tref>null</tref>.</li>
            <li>Return the result of the
              <a href="#value-expansion">Value Expansion algorithm</a>, passing the
              <tref>active context</tref>, <tref>active property</tref>, and
              <i>element</i> as <i>value</i>.</li>
          </ol>
        </li>
        <li>If <i>element</i> is an <tref>array</tref>,
          <ol class="algorithm">
            <li>Initialize an empty array, <i>result</i>.</li>
            <li>For each <i>item</i> in <i>element</i>:
              <ol class="algorithm">
                <li>Initialize <i>expanded item</i> to the result of using this
                  algorithm recursively, passing <tref>active context</tref>,
                  <tref>active property</tref>, and <i>item</i> as <i>element</i>.</li>
                <li>If the <tref>active property</tref> is <code>@list</code> or its
                  <tref>container mapping</tref> is set to <code>@list</code>, the
                  <i>expanded item</i> must not be an <tref>array</tref> or a
                  <tref>list object</tref>, otherwise a
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.list-of-lists">list of lists</a></code>
                  error has been detected and processing is aborted.</li>
                <li>If <i>expanded item</i> is an <tref>array</tref>, append each
                  of its items to <i>result</i>. Otherwise, if
                  <i>expanded item</i> is not null, append it to <i>result</i>.</li>
              </ol>
            </li>
            <li>Return <i>result</i>.</li>
          </ol>
        </li>
        <li>Otherwise <i>element</i> is a <tref>JSON object</tref>.</li>
        <li>If <i>element</i> contains the key <code>@context</code>, set
          <tref>active context</tref> to the result of the
          <a href="#context-processing-algorithm">Context Processing algorithm</a>,
          passing <tref>active context</tref> and the value of the
          <code>@context</code> key as <tref>local context</tref>.</li>
        <li>Initialize an empty <tref>JSON object</tref>, <i>result</i>.</li>
        <li>For each <i>key</i> and <i>value</i> in <i>element</i>,
          ordered lexicographically by <i>key</i>:
          <ol class="algorithm">
            <li>If <i>key</i> is <code>@context</code>, continue to
              the next <i>key</i>.</li>
            <li>Set <i>expanded property</i> to the result of
              using the <a href="#iri-expansion">IRI Expansion algorithm</a>,
              passing <tref>active context</tref>, <i>key</i> for
              <i>value</i>, and <tref>true</tref> for <i>vocab</i>.</li>
            <li>If <i>expanded property</i> is <tref>null</tref> or it neither
              contains a colon (<code>:</code>) nor it is a <tref>keyword</tref>,
              drop <i>key</i> by continuing to the next <i>key</i>.</li>
            <li>If <i>expanded property</i> is a <tref>keyword</tref>:
              <ol class="algorithm">
                <li>If <tref>active property</tref> equals <code>@reverse</code>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-reverse-property-map">invalid reverse property map</a></code>
                  error has been detected and processing is aborted.</li>
                <li>If <i>result</i> has already an <i>expanded property</i> member, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.colliding-keywords">colliding keywords</a></code>
                  error has been detected and processing is aborted.</li>
                <li>If <i>expanded property</i> is <code>@id</code> and
                  <i>value</i> is not a <tref>string</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid--id-value">invalid @id value</a></code>
                  error has been detected and processing is aborted. Otherwise,
                  set <i>expanded value</i> to the result of using the
                  <a href="#iri-expansion">IRI Expansion algorithm</a>,
                  passing <tref>active context</tref>, <i>value</i>, and <tref>true</tref>
                  for <i>document relative</i>.</li>
                <li>If <i>expanded property</i> is <code>@type</code> and <i>value</i>
                  is neither a <tref>string</tref> nor an <tref>array</tref> of
                  <tref title="string">strings</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-type-value">invalid type value</a></code>
                  error has been detected and processing is aborted. Otherwise,
                  set <i>expanded value</i> to the result of using the
                  <a href="#iri-expansion">IRI Expansion algorithm</a>, passing
                  <tref>active context</tref>, <tref>true</tref> for <i>vocab</i>,
                  and <tref>true</tref> for <i>document relative</i> to expand the <i>value</i>
                  or each of its items.</li>
                <li>If <i>expanded property</i> is <code>@graph</code>, set
                  <i>expanded value</i> to the result of using this algorithm
                  recursively passing <tref>active context</tref>, <code>@graph</code>
                  for <tref>active property</tref>, and <i>value</i> for <i>element</i>.</li>
                <li>If <i>expanded property</i> is <code>@value</code> and
                  <i>value</i> is not a <tref>scalar</tref> or <tref>null</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-value-object-value">invalid value object value</a></code>
                  error has been detected and processing is aborted. Otherwise,
                  set <i>expanded value</i> to <i>value</i>. If <i>expanded value</i>
                  is <tref>null</tref>, set the <code>@value</code>
                  member of <i>result</i> to <tref>null</tref> and continue with the
                  next <i>key</i> from <i>element</i>. Null values need to be preserved
                  in this case as the meaning of an <code>@type</code> member depends
                  on the existence of an <code>@value</code> member.</li>
                <li>If <i>expanded property</i> is <code>@language</code> and
                  <i>value</i> is not a <tref>string</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-language-tagged-string">invalid language-tagged string</a></code>
                  error has been detected and processing is aborted. Otherwise,
                  set <i>expanded value</i> to lowercased <i>value</i>.</li>
                <li>If <i>expanded property</i> is <code>@index</code> and
                  <i>value</i> is not a <tref>string</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid--index-value">invalid @index value</a></code>
                  error has been detected and processing is aborted. Otherwise,
                  set <i>expanded value</i> to <i>value</i>.</li>
                <li>If <i>expanded property</i> is <code>@list</code>:
                  <ol class="algorithm">
                    <li>If <tref>active property</tref> is <tref>null</tref> or
                      <code>@graph</code>, continue with the next <i>key</i>
                      from <i>element</i> to remove the free-floating list.</li>
                    <li>Otherwise, initialize <i>expanded value</i> to the result of using
                      this algorithm recursively passing <tref>active context</tref>,
                      <tref>active property</tref>, and <i>value</i> for <i>element</i>.</li>
                    <li>If <i>expanded value</i> is a <tref>list object</tref>, a
                      <code class="error"><a href="#idl-def-JsonLdErrorCode.list-of-lists">list of lists</a></code>
                      error has been detected and processing is aborted.</li>
                  </ol>
                </li>
                <li>If <i>expanded property</i> is <code>@set</code>, set
                  <i>expanded value</i> to the result of using this algorithm
                  recursively, passing <tref>active context</tref>,
                  <tref>active property</tref>, and <i>value</i> for
                  <i>element</i>.</li>
                <li>If <i>expanded property</i> is <code>@reverse</code> and
                  <i>value</i> is not a <tref>JSON object</tref>, an
                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid--reverse-value">invalid @reverse value</a></code>
                  error has been detected and processing is aborted. Otherwise
                  <ol class="algorithm">
                    <li>Initialize <i>expanded value</i> to the result of using this
                      algorithm recursively, passing <tref>active context</tref>,
                      <code>@reverse</code> as <tref>active property</tref>, and
                      <i>value</i> as <i>element</i>.</li>
                    <li>If <i>expanded value</i> contains an <code>@reverse</code> member,
                      i.e., properties that are reversed twice, execute for each of its
                      <i>property</i> and <i>item</i> the following steps:
                      <ol class="algorithm">
                        <li>If <i>result</i> does not have a <i>property</i> member, create
                          one and set its value to an empty <tref>array</tref>.</li>
                        <li>Append <i>item</i> to the value of the <i>property</i> member
                          of <i>result</i>.</li>
                      </ol>
                    </li>
                    <li>If <i>expanded value</i> contains members other than <code>@reverse</code>:
                      <ol class="algorithm">
                        <li>If <i>result</i> does not have an <code>@reverse</code> member, create
                          one and set its value to an empty <tref>JSON object</tref>.</li>
                        <li>Reference the value of the <code>@reverse</code> member in <i>result</i>
                          using the variable <i>reverse map</i>.</li>
                        <li>For each <i>property</i> and <i>items</i> in <i>expanded value</i>
                          other than <code>@reverse</code>:
                          <ol class="algorithm">
                            <li>For each <i>item</i> in <i>items</i>:
                              <ol class="algorithm">
                                <li>If <i>item</i> is a <tref>value object</tref> or <tref>list object</tref>, an
                                  <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid--reverse-value">invalid reverse property value</a></code>
                                  has been detected and processing is aborted.</li>
                                <li>If <i>reverse map</i> has no <i>property</i> member, create one
                                  and initialize its value to an empty <tref>array</tref>.</li>
                                <li>Append <i>item</i> to the value of the <i>property</i>
                                  member in <i>reverse map</i>.</li>
                              </ol>
                            </li>
                          </ol>
                        </li>
                      </ol>
                    </li>
                    <li>Continue with the next <i>key</i> from <i>element</i>.</li>
                  </ol>
                </li>
                <li>Unless <i>expanded value</i> is <tref>null</tref>, set
                  the <i>expanded property</i> member of <i>result</i> to
                  <i>expanded value</i>.</li>
                <li>Continue with the next <i>key</i> from <i>element</i>.</li>
              </ol>
            </li>
            <li>Otherwise, if <i>key</i>'s <tref>container mapping</tref> in
              <tref>active context</tref> is <code>@language</code> and
              <i>value</i> is a <tref>JSON object</tref> then <i>value</i>
              is expanded from a <tref href="../json-ld/#dfn-language-map">language map</tref>
              as follows:
              <ol class="algorithm">
                <li>Initialize <i>expanded value</i> to an empty
                  <tref>array</tref>.</li>
                <li>For each key-value pair <i>language</i>-<i>language value</i>
                  in <i>value</i>, ordered lexicographically by <i>language</i>:
                  <ol class="algorithm">
                    <li>If <i>language value</i> is not an <tref>array</tref>
                      set it to an <tref>array</tref> containing only
                      <i>language value</i>.</li>
                    <li>For each <i>item</i> in <i>language value</i>:
                      <ol class="algorithm">
                        <li><i>item</i> must be a <tref>string</tref>,
                          otherwise an
                          <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-language-map-value">invalid language map value</a></code>
                          error has been detected and processing is aborted.</li>
                        <li>Append a <tref>JSON object</tref> to
                          <i>expanded value</i> that consists of two
                          key-value pairs: (<code>@value</code>-<i>item</i>)
                          and (<code>@language</code>-lowercased
                          <i>language</i>).</li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>Otherwise, if <i>key</i>'s <tref>container mapping</tref> in
              <tref>active context</tref> is <code>@index</code> and
              <i>value</i> is a <tref>JSON object</tref> then <i>value</i>
              is expanded from an index map as follows:
              <ol class="algorithm">
                <li>Initialize <i>expanded value</i> to an empty
                  <tref>array</tref>.</li>
                <li>For each key-value pair <i>index</i>-<i>index value</i>
                  in <i>value</i>, ordered lexicographically by <i>index</i>:
                  <ol class="algorithm">
                    <li>If <i>index value</i> is not an <tref>array</tref>
                      set it to an <tref>array</tref> containing only
                      <i>index value</i>.</li>
                    <li>Initialize <i>index value</i> to the result of
                      using this algorithm recursively, passing
                      <tref>active context</tref>,
                      <i>key</i> as <tref>active property</tref>,
                      and <i>index value</i> as <i>element</i>.</li>
                    <li>For each <i>item</i> in <i>index value</i>:
                      <ol class="algorithm">
                        <li>If <i>item</i> does not have the key
                          <code>@index</code>, add the key-value pair
                          (<code>@index</code>-<i>index</i>) to
                          <i>item</i>.</li>
                        <li>Append <i>item</i> to <i>expanded value</i>.</li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>Otherwise, initialize <i>expanded value</i> to the result of
              using this algorithm recursively, passing <tref>active context</tref>,
              <i>key</i> for <tref>active property</tref>, and <i>value</i>
              for <i>element</i>.</li>
            <li>If <i>expanded value</i> is <tref>null</tref>, ignore <i>key</i>
              by continuing to the next <i>key</i> from <i>element</i>.</li>
            <li>If the <tref>container mapping</tref> associated to <i>key</i> in
              <tref>active context</tref> is <code>@list</code> and
              <i>expanded value</i> is not already a <tref>list object</tref>,
              convert <i>expanded value</i> to a <tref>list object</tref>
              by first setting it to an <tref>array</tref> containing only
              <i>expanded value</i> if it is not already an <tref>array</tref>,
              and then by setting it to a <tref>JSON object</tref> containing
              the key-value pair <code>@list</code>-<i>expanded value</i>.</li>
            <li>Otherwise, if the <tref>term definition</tref> associated to
              <i>key</i> indicates that it is a <tref>reverse property</tref>
              <ol class="algorithm">
                <li>If <i>result</i> has no <code>@reverse</code> member, create
                  one and initialize its value to an empty <tref>JSON object</tref>.</li>
                <li>Reference the value of the <code>@reverse</code> member in <i>result</i>
                  using the variable <i>reverse map</i>.</li>
                <li>If <i>expanded value</i> is not an <tref>array</tref>, set
                  it to an <tref>array</tref> containing <i>expanded value</i>.</li>
                <li>For each <i>item</i> in <i>expanded value</i>
                  <ol class="algorithm">
                    <li>If <i>item</i> is a <tref>value object</tref> or <tref>list object</tref>, an
                      <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid--reverse-value">invalid reverse property value</a></code>
                      has been detected and processing is aborted.</li>
                    <li>If <i>reverse map</i> has no <i>expanded property</i> member,
                      create one and initialize its value to an empty <tref>array</tref>.</li>
                    <li>Append <i>item</i> to the value of the <i>expanded property</i>
                      member of <i>reverse map</i>.</li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>Otherwise, if <i>key</i> is not a <tref>reverse property</tref>:
              <ol class="algorithm">
                <li>If <i>result</i> does not have an <i>expanded property</i>
                  member, create one and initialize its value to an empty
                  <tref>array</tref>.</li>
                <li>Append <i>expanded value</i> to value of the <i>expanded property</i>
                  member of <i>result</i>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>If <i>result</i> contains the key <code>@value</code>:
          <ol class="algorithm">
            <li>The <i>result</i> must not contain any keys other than
              <code>@value</code>, <code>@language</code>, <code>@type</code>,
              and <code>@index</code>. It must not contain both the
              <code>@language</code> key and the <code>@type</code> key.
              Otherwise, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-value-object">invalid value object</a></code>
              error has been detected and processing is aborted.</li>
            <li>If the value of <i>result</i>'s <code>@value</code> key is
              <tref>null</tref>, then set <i>result</i> to <tref>null</tref>.</li>
            <li>Otherwise, if the value of <i>result</i>'s <code>@value</code> member
              is not a <tref>string</tref> and <i>result</i> contains the key
              <code>@language</code>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-language-tagged-value">invalid language-tagged value</a></code>
              error has been detected (only <tref title="string">strings</tref>
              can be language-tagged) and processing is aborted.</li>
            <li>Otherwise, if the <i>result</i> has a <code>@type</code> member
              and its value is not an <tref>IRI</tref>, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-typed-value">invalid typed value</a></code>
              error has been detected and processing is aborted.</li>
          </ol>
        </li>
        <li>Otherwise, if <i>result</i> contains the key <code>@type</code>
          and its associated value is not an <tref>array</tref>, set it to
          an <tref>array</tref> containing only the associated value.</li>
        <li>Otherwise, if <i>result</i> contains the key <code>@set</code>
          or <code>@list</code>:
          <ol class="algorithm">
            <li>The <i>result</i> must contain at most one other key and that
              key must be <code>@index</code>. Otherwise, an
              <code class="error"><a href="#idl-def-JsonLdErrorCode.invalid-set-or-list-object">invalid set or list object</a></code>
              error has been detected and processing is aborted.</li>
            <li>If <i>result</i> contains the key <code>@set</code>, then
              set <i>result</i> to the key's associated value.</li>
          </ol>
        </li>
        <li>If <i>result</i> contains only the key
          <code>@language</code>, set <i>result</i> to <tref>null</tref>.</li>
        <li>If <tref>active property</tref> is <tref>null</tref> or <code>@graph</code>,
          drop free-floating values as follows:
          <ol class="algorithm">
            <li>If <i>result</i> is an empty <tref>JSON object</tref> or contains
              the keys <code>@value</code> or <code>@list</code>, set <i>result</i> to
              <tref>null</tref>.</li>
            <li>Otherwise, if <i>result</i> is a <tref>JSON object</tref> whose only
              key is <code>@id</code>, set <i>result</i> to <tref>null</tref>.</li>
          </ol>
        </li>
        <li>Return <i>result</i>.</li>
      </ol>

      <p>If, after the above algorithm is run, the result is a
        <tref>JSON object</tref> that contains only an <code>@graph</code> key, set the
        result to the value of <code>@graph</code>'s value. Otherwise, if the result
        is <tref>null</tref>, set it to an empty <tref>array</tref>. Finally, if
        the result is not an <tref>array</tref>, then set the result to an
        <tref>array</tref> containing only the result.</p>
    </section>
  </section> <!-- end of Expansion Algorithm -->


  <section>
    <h2>Value Expansion</h2>

    <p>Some values in JSON-LD can be expressed in a
      <tref title="compacted form">compact form</tref>. These values are required
      to be <tref title="expansion">expanded</tref> at times when processing
      JSON-LD documents. A value is said to be in <tdef>expanded form</tdef>
      after the application of this algorithm.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>If <tref>active property</tref> has a <tref>type mapping</tref> in the
        <tref>active context</tref> set to <code>@id</code> or <code>@vocab</code>,
        a <tref>JSON object</tref> with a single member <code>@id</code> whose
        value is the result of using the
        <a href="#iri-expansion">IRI Expansion algorithm</a> on <i>value</i>
        is returned.</p>

      <p>Otherwise, the result will be a <tref>JSON object</tref> containing
        an <code>@value</code> member whose value is the passed <i>value</i>.
        Additionally, an <code>@type</code> member will be included if there is a
        <tref>type mapping</tref> associated with the <tref>active property</tref>
        or an <code>@language</code> member if <i>value</i> is a
        <tref>string</tref> and there is <tref>language mapping</tref> associated
        with the <tref>active property</tref>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes three required inputs: an <tref>active context</tref>,
        an <tref>active property</tref>, and a <i>value</i> to expand.</p>

      <ol class="algorithm">
        <li>If the <tref>active property</tref> has a <tref>type mapping</tref>
          in <tref>active context</tref> that is <code>@id</code>, return a new
          <tref>JSON object</tref> containing a single key-value pair where the
          key is <code>@id</code> and the value is the result of using the
          <a href="#iri-expansion">IRI Expansion algorithm</a>, passing
          <tref>active context</tref>, <i>value</i>, and <tref>true</tref> for
          <i>document relative</i>.</li>
        <li>If <tref>active property</tref> has a <tref>type mapping</tref> in
          <tref>active context</tref> that is <code>@vocab</code>, return
          a new <tref>JSON object</tref> containing a single key-value pair
          where the key is <code>@id</code> and the value is the result of
          using the <a href="#iri-expansion">IRI Expansion algorithm</a>, passing
          <tref>active context</tref>, <i>value</i>, <tref>true</tref> for
          <i>vocab</i>, and <tref>true</tref> for
          <i>document relative</i>.</li>
        <li>Otherwise, initialize <i>result</i> to a <tref>JSON object</tref>
          with an <code>@value</code> member whose value is set to
          <i>value</i>.</li>
        <li>If <tref>active property</tref> has a <tref>type mapping</tref> in
          <tref>active context</tref>, add an <code>@type</code> member to
          <i>result</i> and set its value to the value associated with the
          <tref>type mapping</tref>.</li>
        <li>Otherwise, if <i>value</i> is a <tref>string</tref>:
          <ol class="algorithm">
            <li>If a <tref>language mapping</tref> is associated with
              <tref>active property</tref> in <tref>active context</tref>,
              add an <code>@language</code> to <i>result</i> and set its
              value to the language code associated with the
              <tref>language mapping</tref>; unless the
              <tref>language mapping</tref> is set to <tref>null</tref> in
              which case no member is added.</li>
            <li>Otherwise, if the <tref>active context</tref> has a
              <tref>default language</tref>, add an <code>@language</code>
              to <i>result</i> and set its value to the
              <tref>default language</tref>.</li>
          </ol>
        </li>
        <li>Return <i>result</i>.</li>
      </ol>
    </section>
  </section> <!-- end of Value Expansion -->

</section> <!-- end of Expansion section -->


<section>
  <h1>Compaction Algorithms</h1>

  <section>
    <h2>Compaction Algorithm</h2>

    <p>This algorithm compacts a JSON-LD document, such that the given
      <tref>context</tref> is applied. This must result in shortening
      any applicable <tref title="IRI">IRIs</tref> to
      <tref title="term">terms</tref> or
      <tref title="compact IRI">compact IRIs</tref>, any applicable
      <tref title="keyword">keywords</tref> to
      <tref title="keyword alias">keyword aliases</tref>, and
      any applicable <tref title="JSON-LD value">JSON-LD values</tref>
      expressed in <tref>expanded form</tref> to simple values such as
      <tref title="string">strings</tref> or
      <tref title="number">numbers</tref>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>Starting with its root <i>element</i>, we can process the
        JSON-LD document recursively, until we have a fully
        <tref title="compaction">compacted</tref> <i>result</i>. When
        <tref title="compaction">compacting</tref> an <i>element</i>, we can treat
        each one differently according to its type, in order to break down the
        problem:</p>

      <ol>
        <li>If the <i>element</i> is a <tref>scalar</tref>, it is
          already in <tref>compacted form</tref>, so we simply return it.</li>
        <li>If the <i>element</i> is an <tref>array</tref>, we compact
          each of its items recursively and return them in a new
          <tref>array</tref>.</li>
        <li>Otherwise <i>element</i> is a <tref>JSON object</tref>. The value
          of each key in element is compacted recursively. Some of the keys will be
          compacted, using the <a href="#iri-compaction">IRI Compaction algorithm</a>,
          to <tref title="term">terms</tref> or <tref title="compact IRI">compact IRIs</tref>
          and others will be compacted from <tref title="keyword">keywords</tref> to
          <tref title="keyword alias">keyword aliases</tref> or simply left
          unchanged because they do not have definitions in the <tref>context</tref>.
          Values will be converted to <tref>compacted form</tref> via the
          <a href="#value-compaction">Value Compaction algorithm</a>. Some data
          will be reshaped based on <tref title="container mapping">container mappings</tref>
          specified in the context such as <code>@index</code> or <code>@language</code>
          maps.</li>
      </ol>

      <p>The final output is a <tref>JSON object</tref> with a <code>@context</code>
        key, if a non-empty <tref>context</tref> was given, where the <tref>JSON object</tref>
        is either <i>result</i> or a wrapper for it where <i>result</i> appears
        as the value of an (aliased) <code>@graph</code> key because <i>result</i>
        contained two or more items in an <tref>array</tref>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes five required input variables: an <tref>active context</tref>,
        an <tref>inverse context</tref>, an <tref>active property</tref>, an
        <i>element</i> to be compacted, and a flag
        <code class="idlMemberName"><a href="#widl-JsonLdOptions-compactArrays">compactArrays</a></code>.
        To begin, the <tref>active context</tref> is set to the result of
        performing <a href="#context-processing-algorithm">Context Processing</a>
        on the passed <tref>context</tref>, the <tref>inverse context</tref> is
        set to the result of performing the
        <a href="#inverse-context-creation">Inverse Context Creation algorithm</a>
        on <tref>active context</tref>, the <tref>active property</tref> is
        set to <tref>null</tref>, <i>element</i> is set to the result of
        performing the <a href="#expansion-algorithm">Expansion algorithm</a>
        on the <tref>JSON-LD input</tref>, and, if not passed,
        <code class="idlMemberName"><a href="#widl-JsonLdOptions-compactArrays">compactArrays</a></code>
        is set to <tref>true</tref>.</p>

      <ol class="algorithm">
        <li>If <i>element</i> is a <tref>scalar</tref>, it is already in its most
          compact form, so simply return <i>element</i>.</li>
        <li>If <i>element</i> is an <tref>array</tref>:
          <ol class="algorithm">
            <li>Initialize <i>result</i> to an empty <tref>array</tref>.</li>
            <li>For each <i>item</i> in <i>element</i>:
              <ol class="algorithm">
                <li>Initialize <i>compacted item</i> to the result of using this
                  algorithm recursively, passing <tref>active context</tref>,
                  <tref>inverse context</tref>, <tref>active property</tref>, and
                  <em>item</em> for <i>element</i>.</li>
                <li>If <i>compacted item</i> is not <tref>null</tref>, then append
                  it to <i>result</i>.</li>
              </ol>
            </li>
            <li>If <i>result</i> contains only one item (it has a length of
              <code>1</code>), <tref>active property</tref> has no
              <tref>container mapping</tref> in <tref>active context</tref>, and
              <code class="idlMemberName"><a href="#widl-JsonLdOptions-compactArrays">compactArrays</a></code>
              is <tref>true</tref>, set <i>result</i> to its only item.</li>
            <li>Return <i>result</i>.</li>
          </ol>
        </li>
        <li>Otherwise <i>element</i> is a <tref>JSON object</tref>.</li>
        <li>If <i>element</i> has an <code>@value</code> or <code>@id</code>
          member and the result of using the
          <a href="#value-compaction">Value Compaction algorithm</a>,
          passing <tref>active context</tref>, <tref>inverse context</tref>,
          <tref>active property</tref>,and <i>element</i> as <i>value</i> is
          a <tref>scalar</tref>, return that result.</li>
        <li>Initialize <i>inside reverse</i> to <tref>true</tref> if
          <tref>active property</tref> equals <code>@reverse</code>,
          otherwise to <tref>false</tref>.</li>
        <li>Initialize <i>result</i> to an empty <tref>JSON object</tref>.</li>
        <li>For each key <i>expanded property</i> and value <i>expanded value</i>
          in <i>element</i>,  ordered lexicographically by <i>expanded property</i>:
          <ol class="algorithm">
            <li>If <i>expanded property</i> is <code>@id</code> or
              <code>@type</code>:
                <ol class="algorithm">
                  <li>If <i>expanded value</i> is a <tref>string</tref>,
                    then initialize <i>compacted value</i> to the result
                    of using the <a href="#iri-compaction">IRI Compaction algorithm</a>,
                    passing <tref>active context</tref>, <tref>inverse context</tref>,
                    <i>expanded value</i> for <i>iri</i>,
                    and <tref>true</tref> for <i>vocab</i> if
                    <i>expanded property</i> is <code>@type</code>,
                    <tref>false</tref> otherwise.</li>
                  <li>Otherwise, <i>expanded value</i> must be a
                    <code>@type</code> <tref>array</tref>:
                    <ol class="algorithm">
                      <li>Initialize <i>compacted value</i> to an empty
                        <tref>array</tref>.</li>
                      <li>For each item <i>expanded type</i> in
                        <i>expanded value</i>, append the result of
                        of using the <a href="#iri-compaction">IRI Compaction algorithm</a>,
                        passing <tref>active context</tref>, <tref>inverse context</tref>,
                        <i>expanded type</i> for <i>iri</i>, and
                        <tref>true</tref> for <i>vocab</i>,
                        to <i>compacted value</i>.</li>
                      <li>If <i>compacted value</i> contains only one
                        item (it has a length of <code>1</code>), then
                        set <i>compacted value</i> to its only item.</li>
                    </ol>
                  </li>
                  <li>Initialize <i>alias</i> to the result of using the
                    <a href="#iri-compaction">IRI Compaction algorithm</a>,
                    passing <tref>active context</tref>, <tref>inverse context</tref>,
                    <i>expanded property</i> for <i>iri</i>,
                    and <tref>true</tref> for <i>vocab</i>.</li>
                  <li>Add a member <i>alias</i> to <i>result</i> whose value is
                    set to <i>compacted value</i> and continue to the next
                    <i>expanded property</i>.</li>
                </ol>
              </li>
            <li>If <i>expanded property</i> is <code>@reverse</code>:
              <ol class="algorithm">
                <li>Initialize <i>compacted value</i> to the result of using this
                  algorithm recursively, passing <tref>active context</tref>,
                  <tref>inverse context</tref>, <code>@reverse</code> for
                  <tref>active property</tref>, and <i>expanded value</i>
                  for <i>element</i>.</li>
                <li>For each <i>property</i> and <i>value</i> in <i>compacted value</i>:
                  <ol class="algorithm">
                    <li>If the <tref>term definition</tref> for <i>property</i> in the
                      <tref>active context</tref> indicates that <i>property</i> is
                      a <tref>reverse property</tref>
                      <ol class="algorithm">
                        <li>If the <tref>term definition</tref> for <i>property</i> in
                          the <tref>active context</tref> has a
                          <tref>container mapping</tref> of <code>@set</code> or
                          <code class="idlMemberName"><a href="#widl-JsonLdOptions-compactArrays">compactArrays</a></code>
                          is <tref>false</tref>, and <i>value</i> is not an
                          <tref>array</tref>, set <i>value</i> to a new
                          <tref>array</tref> containing only <i>value</i>.</li>
                        <li>If <i>property</i> is not a member of
                          <i>result</i>, add one and set its value to <i>value</i>.</li>
                        <li>Otherwise, if the value of the <i>property</i> member of
                          <i>result</i> is not an <tref>array</tref>, set it to a new
                          <tref>array</tref> containing only the value. Then
                          append <i>value</i> to its value if <i>value</i>
                          is not an <tref>array</tref>, otherwise append each
                          of its items.</li>
                        <li>Remove the <i>property</i> member from
                          <i>compacted value</i>.</li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li>If <i>compacted value</i> has some remaining members, i.e.,
                  it is not an empty <tref>JSON object</tref>:
                  <ol class="algorithm">
                    <li>Initialize <i>alias</i> to the result of using the
                      <a href="#iri-compaction">IRI Compaction algorithm</a>,
                      passing <tref>active context</tref>, <tref>inverse context</tref>,
                      <code>@reverse</code> for <i>iri</i>,
                      and <tref>true</tref> for <i>vocab</i>.</li>
                    <li>Set the value of the <i>alias</i> member of <i>result</i> to
                      <i>compacted value</i>.</li>
                  </ol>
                </li>
                <li>Continue with the next <i>expanded property</i> from <i>element</i>.</li>
              </ol>
            </li>
            <li>If <i>expanded property</i> is <code>@index</code> and
              <tref>active property</tref> has a <tref>container mapping</tref>
              in <tref>active context</tref> that is <code>@index</code>,
              then the compacted result will be inside of an <code>@index</code>
              container, drop the <code>@index</code> property by continuing
              to the next <i>expanded property</i>.</li>
            <li>Otherwise, if <i>expanded property</i> is <code>@index</code>,
              <code>@value</code>, or <code>@language</code>:
              <ol class="algorithm">
                <li>Initialize <i>alias</i> to the result of using
                  the <a href="#iri-compaction">IRI Compaction algorithm</a>,
                  passing <tref>active context</tref>, <tref>inverse context</tref>,
                  <i>expanded property</i> for <i>iri</i>,
                  and <tref>true</tref> for <i>vocab</i>.</li>
                <li>Add a member <i>alias</i> to <i>result</i> whose value is
                  set to <i>expanded value</i> and continue with the next
                  <i>expanded property</i>.</li>
              </ol>
            </li>
            <li>If <i>expanded value</i> is an empty <tref>array</tref>:
              <ol class="algorithm">
                <li>Initialize <i>item active property</i> to the result of
                  using the <a href="#iri-compaction">IRI Compaction algorithm</a>,
                  passing <tref>active context</tref>, <tref>inverse context</tref>,
                  <i>expanded property</i> for <i>iri</i>,
                  <i>expanded value</i> for <i>value</i>,
                  <tref>true</tref> for <i>vocab</i>, and
                  <i>inside reverse</i>.</li>
                <li>If <i>result</i> does not have the key that equals
                  <i>item active property</i>, set this key's value in
                  <i>result</i> to an empty <tref>array</tref>. Otherwise, if
                  the key's value is not an <tref>array</tref>, then set it
                  to one containing only the value.</li>
              </ol>
            </li>
            <li>
              At this point, <i>expanded value</i> must be an
              <tref>array</tref> due to the
              <a href="#expansion-algorithm">Expansion algorithm</a>.
              For each item <i>expanded item</i> in <i>expanded value</i>:
              <ol class="algorithm">
                <li>Initialize <i>item active property</i> to the result of using
                  the <a href="#iri-compaction">IRI Compaction algorithm</a>,
                  passing <tref>active context</tref>, <tref>inverse context</tref>,
                  <i>expanded property</i> for <i>iri</i>,
                  <i>expanded item</i> for <i>value</i>,
                  <tref>true</tref> for <i>vocab</i>, and
                  <i>inside reverse</i>.</li>
                <li>Initialize <i>container</i> to <tref>null</tref>. If there
                  is a <tref>container mapping</tref> for
                  <i>item active property</i> in <tref>active context</tref>,
                  set <i>container</i> to its value.</li>
                <li>Initialize <i>compacted item</i> to the result of using
                  this algorithm recursively, passing
                  <tref>active context</tref>, <tref>inverse context</tref>,
                  <i>item active property</i> for <tref>active property</tref>,
                  <i>expanded item</i> for <i>element</i> if it does
                  not contain the key <code>@list</code>, otherwise pass
                  the key's associated value for <i>element</i>.</li>
                <li>
                  If <i>expanded item</i> is a <tref>list object</tref>:
                  <ol class="algorithm">
                    <li>If <i>compacted item</i> is not an <tref>array</tref>,
                      then set it to an <tref>array</tref> containing only
                      <i>compacted item</i>.</li>
                    <li>If <i>container</i> is not <code>@list</code>:
                      <ol class="algorithm">
                        <li>Convert <i>compacted item</i> to a
                          <tref>list object</tref> by setting it to a
                          <tref>JSON object</tref> containing key-value pair
                          where the key is the result of the
                          <a href="#iri-compaction">IRI Compaction algorithm</a>,
                          passing <tref>active context</tref>, <tref>inverse context</tref>,
                          <code>@list</code> for <i>iri</i>, and <i>compacted item</i>
                          for <i>value</i>.</li>
                        <li>If <i>expanded item</i> contains the key
                          <code>@index</code>, then add a key-value pair
                          to <i>compacted item</i> where the key is the
                          result of the <a href="#iri-compaction">IRI Compaction algorithm</a>,
                          passing <tref>active context</tref>, <tref>inverse context</tref>,
                          <code>@index</code> as <i>iri</i>, and the value associated with the
                          <code>@index</code> key in <i>expanded item</i> as <i>value</i>.</li>
                      </ol>
                    </li>
                    <li>Otherwise, <i>item active property</i> must not be a key
                      in <i>result</i> because there cannot be two
                      <tref title="list object">list objects</tref> associated
                      with an <tref>active property</tref> that has a
                      <tref>container mapping</tref>; a
                      <code class="error"><a href="#idl-def-JsonLdErrorCode.compaction-to-list-of-lists">compaction to list of lists</a></code>
                      error has been detected and processing is aborted.</li>
                  </ol>
                </li>
                <li>
                  If <i>container</i> is <code>@language</code> or
                  <code>@index</code>:
                  <ol class="algorithm">
                    <li>If <i>item active property</i> is not a key in
                      <i>result</i>, initialize it to an empty <tref>JSON object</tref>.
                      Initialize <i>map object</i> to the value of <i>item active property</i>
                      in <i>result</i>.</li>
                    <li>If <i>container</i> is <code>@language</code> and
                      <i>compacted item</i> contains the key
                      <code>@value</code>, then set <i>compacted item</i>
                      to the value associated with its <code>@value</code> key.</li>
                    <li>Initialize <i>map key</i> to the value associated with
                      with the key that equals <i>container</i> in
                      <i>expanded item</i>.</li>
                    <li>If <i>map key</i> is not a key in <i>map object</i>,
                      then set this key's value in <i>map object</i>
                      to <i>compacted item</i>. Otherwise, if the value
                      is not an <tref>array</tref>, then set it to one
                      containing only the value and then append
                      <i>compacted item</i> to it.</li>
                  </ol>
                </li>
                <li>
                  Otherwise,
                  <ol class="algorithm">
                    <li>If
                      <code class="idlMemberName"><a href="#widl-JsonLdOptions-compactArrays">compactArrays</a></code>
                      is <tref>false</tref>, <i>container</i> is <code>@set</code> or
                      <code>@list</code>, or <i>expanded property</i> is
                      <code>@list</code> or <code>@graph</code> and
                      <i>compacted item</i> is not an <tref>array</tref>,
                      set it to a new <tref>array</tref>
                      containing only <i>compacted item</i>.</li>
                    <li>If <i>item active property</i> is not a key in
                      <i>result</i> then add the key-value pair,
                      (<i>item active property</i>-<i>compacted item</i>),
                      to <i>result</i>.</li>
                    <li>Otherwise, if the value associated with the key that
                      equals <i>item active property</i> in <i>result</i>
                      is not an <tref>array</tref>, set it to a new
                      <tref>array</tref> containing only the value. Then
                      append <i>compacted item</i> to the value if
                      <i>compacted item</i> is not an <tref>array</tref>,
                      otherwise, concatenate it.</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Return <i>result</i>.</li>
      </ol>

      <p>If, after the algorithm outlined above is run, the result <i>result</i>
        is an <tref>array</tref>, replace it with a new
        <tref>JSON object</tref> with a single member whose key is the result
        of using the <a href="#iri-compaction">IRI Compaction algorithm</a>,
        passing <tref>active context</tref>, <tref>inverse context</tref>, and
        <code>@graph</code> as <i>iri</i> and whose value is the <tref>array</tref>
        <i>result</i>. Finally, if a non-empty <i>context</i> has been passed,
        add an <code>@context</code> member to <i>result</i> and set its value
        to the passed <i>context</i>.</p>
    </section>
  </section> <!-- end of Compaction -->

  <section>
    <h2>Inverse Context Creation</h2>

    <p>When there is more than one <tref>term</tref> that could be chosen
      to compact an <tref>IRI</tref>, it has to be ensured that the <tref>term</tref>
      selection is both deterministic and represents the most context-appropriate
      choice whilst taking into consideration algorithmic complexity.</p>

    <p>In order to make <tref>term</tref> selections, the concept of an
      <tref>inverse context</tref> is introduced. An <tdef>inverse context</tdef>
      is essentially a reverse lookup table that maps
      <tref title="container mapping">container mappings</tref>,
      <tref title="type mapping">type mappings</tref>, and
      <tref title="language mapping">language mappings</tref> to a simple
      <tref>term</tref> for a given <tref>active context</tref>. A
      <tref>inverse context</tref> only needs to be generated for an
      <tref>active context</tref> if it is being used for <tref>compaction</tref>.</p>

    <p>To make use of an <tref>inverse context</tref>, a list of preferred
      <tref title="container mapping">container mappings</tref> and the
      <tref>type mapping</tref> or <tref>language mapping</tref> are gathered
      for a particular value associated with an <tref>IRI</tref>. These parameters
      are then fed to the <a href="#term-selection">Term Selection algorithm</a>,
      which will find the <tref>term</tref> that most appropriately
      matches the value's mappings.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>To create an <tref>inverse context</tref> for a given
        <tref>active context</tref>, each <tref>term</tref> in the
        <tref>active context</tref> is visited, ordered by length, shortest
        first (ties are broken by choosing the lexicographically least
        <tref>term</tref>). For each <tref>term</tref>, an entry is added to
        the <tref>inverse context</tref> for each possible combination of
        <tref>container mapping</tref> and <tref>type mapping</tref>
        or <tref>language mapping</tref> that would legally match the
        <tref>term</tref>. Illegal matches include differences between a
        value's <tref>type mapping</tref> or <tref>language mapping</tref> and
        that of the <tref>term</tref>. If a <tref>term</tref> has no
        <tref>container mapping</tref>, <tref>type mapping</tref>, or
        <tref>language mapping</tref> (or some combination of these), then it
        will have an entry in the <tref>inverse context</tref> using the special
        key <code>@none</code>. This allows the
        <a href="#term-selection">Term Selection algorithm</a> to fall back
        to choosing more generic <tref title="term">terms</tref> when a more
        specifically-matching <tref>term</tref> is not available for a particular
        <tref>IRI</tref> and value combination.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes one required input: the <tref>active context</tref> that
        the <tref>inverse context</tref> is being created for.</p>

      <ol class="algorithm">
        <li>Initialize <i>result</i> to an empty <tref>JSON object</tref>.</li>
        <li>Initialize <i>default language</i> to <code>@none</code>. If the
          <tref>active context</tref> has a <tref>default language</tref>,
          set <i>default language</i> to it.</li>
        <li>For each key <tref>term</tref> and value <tref>term definition</tref> in
          the <tref>active context</tref>, ordered by shortest <tref>term</tref>
          first (breaking ties by choosing the lexicographically least
          <tref>term</tref>):
          <ol class="algorithm">
            <li>If the <tref>term definition</tref> is <tref>null</tref>,
              <tref>term</tref> cannot be selected during <tref>compaction</tref>,
              so continue to the next <tref>term</tref>.</li>
            <li>Initialize <i>container</i> to <code>@none</code>. If there
              is a <tref>container mapping</tref> in
              <tref>term definition</tref>, set <i>container</i> to
              its associated value.</li>
            <li>Initialize <i>iri</i> to the value of the <tref>IRI mapping</tref>
              for the <tref>term definition</tref>.</li>
            <li>If <i>iri</i> is not a key in <i>result</i>, add
              a key-value pair where the key is <i>iri</i> and the value
              is an empty <tref>JSON object</tref> to <i>result</i>.</li>
            <li>Reference the value associated with the <i>iri</i> member in
              <i>result</i> using the variable <i>container map</i>.</li>
            <li>If <i>container map</i> has no <i>container</i> member,
              create one and set its value to a new
              <tref>JSON object</tref> with two members. The first member is
              <code>@language</code> and its value is a new empty
              <tref>JSON object</tref>, the second member is <code>@type</code>
              and its value is a new empty <tref>JSON object</tref>.</li>
            <li>Reference the value associated with the <i>container</i> member
              in <i>container map</i> using the variable <i>type/language map</i>.</li>
            <li>If the <tref>term definition</tref> indicates that the <tref>term</tref>
              represents a <tref>reverse property</tref>:
              <ol class="algorithm">
                <li>Reference the value associated with the <code>@type</code>
                  member in <i>type/language map</i> using the variable
                  <i>type map</i>.</li>
                <li>If <i>type map</i> does not have a <code>@reverse</code>
                  member, create one and set its value to the <tref>term</tref>
                  being processed.</li>
              </ol>
            </li>
            <li>Otherwise, if <tref>term definition</tref> has a
              <tref>type mapping</tref>:
              <ol class="algorithm">
                <li>Reference the value associated with the <code>@type</code>
                  member in <i>type/language map</i> using the variable
                  <i>type map</i>.</li>
                <li>If <i>type map</i> does not have a member corresponding
                  to the <tref>type mapping</tref> in <tref>term definition</tref>,
                  create one and set its value to the <tref>term</tref>
                  being processed.</li>
              </ol>
            </li>
            <li>Otherwise, if <tref>term definition</tref> has a
              <tref>language mapping</tref> (might be <tref>null</tref>):
              <ol class="algorithm">
                <li>Reference the value associated with the <code>@language</code>
                  member in <i>type/language map</i> using the variable
                  <i>language map</i>.</li>
                <li>If the <tref>language mapping</tref> equals <tref>null</tref>,
                  set <i>language</i> to <code>@null</code>; otherwise set it
                  to the language code in <tref>language mapping</tref>.</li>
                <li>If <i>language map</i> does not have a <i>language</i> member,
                  create one and set its value to the <tref>term</tref>
                  being processed.</li>
              </ol>
            </li>
            <li>Otherwise:
              <ol class="algorithm">
                <li>Reference the value associated with the <code>@language</code>
                  member in <i>type/language map</i> using the variable
                  <i>language map</i>.</li>
                <li>If <i>language map</i> does not have a <i>default language</i>
                  member, create one and set its value to the <tref>term</tref>
                  being processed.</li>
                <li>If <i>language map</i> does not have a <code>@none</code>
                  member, create one and set its value to the <tref>term</tref>
                  being processed.</li>
                <li>Reference the value associated with the <code>@type</code>
                  member in <i>type/language map</i> using the variable
                  <i>type map</i>.</li>
                <li>If <i>type map</i> does not have a <code>@none</code>
                  member, create one and set its value to the <tref>term</tref>
                  being processed.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Return <i>result</i>.</li>
      </ol>
    </section>
  </section> <!-- end of Inverse Context Creation -->

  <section>
    <h2>IRI Compaction</h2>

    <p>This algorithm compacts an <tref>IRI</tref> to a <tref>term</tref> or
      <tref>compact IRI</tref>, or a <tref>keyword</tref> to a
      <tref>keyword alias</tref>. A value that is associated with the
      <tref>IRI</tref> may be passed in order to assist in selecting the most
      context-appropriate <tref>term</tref>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>If the passed <tref>IRI</tref> is <tref>null</tref>, we simply
        return <tref>null</tref>. Otherwise, we first try to find a <tref>term</tref>
        that the <tref>IRI</tref> or <tref>keyword</tref> can be compacted to if
        it is relative to <tref title="active context">active context's</tref>
        <tref>vocabulary mapping</tref>. In order to select the most appropriate
        <tref>term</tref>, we may have to collect information about the passed
        <i>value</i>. This information includes which
        <tref title="container mapping">container mappings</tref>
        would be preferred for expressing the <i>value</i>, and what its
        <tref>type mapping</tref> or <tref>language mapping</tref> is. For
        <tref title="list object">JSON-LD lists</tref>, the <tref>type mapping</tref>
        or <tref>language mapping</tref> will be chosen based on the most
        specific values that work for all items in the list. Once this
        information is gathered, it is passed to the
        <a href="#term-selection">Term Selection algorithm</a>, which will
        return the most appropriate <tref>term</tref> to use.</p>

      <p>If no <tref>term</tref> was found that could be used to compact the
        <tref>IRI</tref>, an attempt is made to compact the <tref>IRI</tref> using the
        <tref title="active context">active context's</tref> <tref>vocabulary mapping</tref>,
        if there is one. If the <tref>IRI</tref> could not be compacted, an
        attempt is made to find a <tref>compact IRI</tref>. If there is no
        appropriate <tref>compact IRI</tref>, the <tref>IRI</tref> is
        transformed to a <tref>relative IRI</tref> using the document's
        <tref>base IRI</tref>. Finally, if the <tref>IRI</tref> or
        <tref>keyword</tref> still could not be compacted, it is returned
        as is.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>This algorithm takes three required inputs and three optional inputs.
        The required inputs are an <tref>active context</tref>, an <tref>inverse context</tref>,
        and the <i>iri</i> to be compacted. The optional inputs are a <i>value</i> associated
        with the <i>iri</i>, a <i>vocab</i> flag which specifies whether the
        passed <i>iri</i> should be compacted using the
        <tref title="active context">active context's</tref>
        <tref>vocabulary mapping</tref>, and a <i>reverse</i> flag which specifies whether
        a <tref>reverse property</tref> is being compacted. If not passed, <i>value</i> is set to
        <tref>null</tref> and <i>vocab</i> and <i>reverse</i> are both set to
        <code>false</code>.</p>

      <ol class="algorithm">
        <li>If <i>iri</i> is <tref>null</tref>, return <tref>null</tref>.</li>
        <li>If <i>vocab</i> is <tref>true</tref> and <i>iri</i> is a
          key in <tref>inverse context</tref>:
          <ol class="algorithm">
            <li>Initialize <i>default language</i> to
              <tref title="active context">active context's</tref>
              <tref>default language</tref>, if it has one, otherwise to
              <code>@none</code>.</li>
            <li>Initialize <i>containers</i> to an empty <tref>array</tref>. This
              <tref>array</tref> will be used to keep track of an ordered list of
              preferred <tref title="container mapping">container mappings</tref>
              for a <tref>term</tref>, based on what is compatible with
              <i>value</i>.</li>
            <li>Initialize <i>type/language</i> to <code>@language</code>,
              and <i>type/language value</i> to <code>@null</code>. These two
              variables will keep track of the preferred
              <tref>type mapping</tref> or <tref>language mapping</tref> for
              a <tref>term</tref>, based on what is compatible with <i>value</i>.</li>
            <li>If <i>value</i> is a <tref>JSON object</tref> that contains the
              key <code>@index</code>, then append the value <code>@index</code>
              to <i>containers</i>.</li>
            <li>If <i>reverse</i> is <tref>true</tref>, set <i>type/language</i>
              to <code>@type</code>, <i>type/language value</i> to
              <code>@reverse</code>, and append <code>@set</code> to <i>containers</i>.</li>
            <li>Otherwise, if <i>value</i> is a <tref>list object</tref>, then set
              <i>type/language</i> and <i>type/language value</i>
              to the most specific values that work for all items in
              the list as follows:
              <ol class="algorithm">
                <li>If <code>@index</code> is a not key in <i>value</i>, then
                  append <code>@list</code> to <i>containers</i>.</li>
                <li>Initialize <i>list</i> to the <tref>array</tref> associated
                  with the key <code>@list</code> in <i>value</i>.</li>
                <li>Initialize <i>common type</i> and <i>common language</i> to <tref>null</tref>. If
                  <i>list</i> is empty, set <i>common language</i> to
                  <i>default language</i>.</li>
                <li>For each <i>item</i> in <i>list</i>:
                  <ol class="algorithm">
                    <li>Initialize <i>item language</i> to <code>@none</code> and
                      <i>item type</i> to <code>@none</code>.</li>
                    <li>If <i>item</i> contains the key <code>@value</code>:
                      <ol class="algorithm">
                        <li>If <i>item</i> contains the key <code>@language</code>,
                          then set <i>item language</i> to its associated
                          value.</li>
                        <li>Otherwise, if <i>item</i> contains the key
                          <code>@type</code>, set <i>item type</i> to its
                          associated value.</li>
                        <li>Otherwise, set <i>item language</i> to
                          <code>@null</code>.</li>
                      </ol>
                    </li>
                    <li>Otherwise, set <i>item type</i> to <code>@id</code>.</li>
                    <li>If <i>common language</i> is <tref>null</tref>, set it
                      to <i>item language</i>.</li>
                    <li>Otherwise, if <i>item language</i> does not equal
                      <i>common language</i> and <i>item</i> contains the
                      key <code>@value</code>, then set <i>common language</i>
                      to <code>@none</code> because list items have conflicting
                      languages.</li>
                    <li>If <i>common type</i> is <tref>null</tref>, set it
                      to <i>item type</i>.</li>
                    <li>Otherwise, if <i>item type</i> does not equal
                      <i>common type</i>, then set <i>common type</i>
                      to <code>@none</code> because list items have conflicting
                      types.</li>
                    <li>If <i>common language</i> is <code>@none</code> and
                      <i>common type</i> is <code>@none</code>, then
                      stop processing items in the list because it has been
                      detected that there is no common language or type amongst
                      the items.</li>
                  </ol>
                </li>
                <li>If <i>common language</i> is <tref>null</tref>, set it to
                  <code>@none</code>.</li>
                <li>If <i>common type</i> is <tref>null</tref>, set it to
                  <code>@none</code>.</li>
                <li>If <i>common type</i> is not <code>@none</code> then set
                  <i>type/language</i> to <code>@type</code> and
                  <i>type/language value</i> to <i>common type</i>.</li>
                <li>Otherwise, set <i>type/language value</i> to
                  <i>common language</i>.</li>
              </ol>
            </li>
            <li>Otherwise:
              <ol class="algorithm">
                <li>If <i>value</i> is a <tref>value object</tref>:
                  <ol class="algorithm">
                    <li>If <i>value</i> contains the key <code>@language</code>
                      and does not contain the key <code>@index</code>,
                      then set <i>type/language value</i> to its associated
                      value and append <code>@language</code> to
                      <i>containers</i>.</li>
                    <li>Otherwise, if <i>value</i> contains the key
                      <code>@type</code>, then set <i>type/language value</i> to
                      its associated value and set <i>type/language</i> to
                      <code>@type</code>.</li>
                  </ol>
                </li>
                <li>Otherwise, set <i>type/language</i> to <code>@type</code>
                  and set <i>type/language value</i> to <code>@id</code>.</li>
                <li>Append <code>@set</code> to <i>containers</i>.</li>
              </ol>
            </li>
            <li>Append <code>@none</code> to <i>containers</i>. This represents
              the non-existence of a <tref>container mapping</tref>, and it will
              be the last <tref>container mapping</tref> value to be checked as it
              is the most generic.</li>
            <li>If <i>type/language value</i> is <tref>null</tref>, set it to
              <code>@null</code>. This is the key under which <tref>null</tref> values
              are stored in the <tref>inverse context</tref> <i>entry</i>.</li>
            <li>Initialize <i>preferred values</i> to an empty <tref>array</tref>.
              This <tref>array</tref> will indicate, in order, the preferred values for
              a <tref title="term">term's</tref> <tref>type mapping</tref> or
              <tref>language mapping</tref>.</li>
            <li>If <i>type/language value</i> is <code>@reverse</code>, append
              <code>@reverse</code> to <i>preferred values</i>.</li>
            <li>If <i>type/language value</i> is <code>@id</code> or <code>@reverse</code>
              and <i>value</i> has an <code>@id</code> member:
              <ol class="algorithm">
                <li>If the result of using the
                  <a href="#iri-compaction">IRI compaction algorithm</a>,
                  passing <tref>active context</tref>, <tref>inverse context</tref>,
                  the value associated with the <code>@id</code> key in <i>value</i> for
                  <i>iri</i>, <tref>true</tref> for <i>vocab</i>, and
                  <tref>true</tref> for <i>document relative</i> has a
                  <tref>term definition</tref> in the <tref>active context</tref>
                  with an <tref>IRI mapping</tref> that equals the value associated
                  with the <code>@id</code> key in <i>value</i>,
                  then append <code>@vocab</code>, <code>@id</code>, and
                  <code>@none</code>, in that order, to <i>preferred values</i>.</li>
                <li>Otherwise, append <code>@id</code>, <code>@vocab</code>, and
                  <code>@none</code>, in that order, to <i>preferred values</i>.</li>
              </ol>
            </li>
            <li>Otherwise, append <i>type/language value</i> and <code>@none</code>, in
              that order, to <i>preferred values</i>.</li>
            <li>Initialize <i>term</i> to the result of the
              <a href="#term-selection">Term Selection algorithm</a>, passing
              <tref>inverse context</tref>, <i>iri</i>, <i>containers</i>,
              <i>type/language</i>, and <i>preferred values</i>.</li>
            <li>If <i>term</i> is not <tref>null</tref>, return <i>term</i>.</li>
          </ol>
        </li>
        <li>At this point, there is no simple <tref>term</tref> that <i>iri</i>
          can be compacted to. If <i>vocab</i> is <tref>true</tref> and
          <tref>active context</tref> has a <tref>vocabulary mapping</tref>:
          <ol class="algorithm">
            <li>If <i>iri</i> begins with the
              <tref title="vocabulary mapping">vocabulary mapping's</tref> value
              but is longer, then initialize <i>suffix</i> to the substring
              of <i>iri</i> that does not match. If <i>suffix</i> does not
              have a <tref>term definition</tref> in <tref>active context</tref>,
              then return <i>suffix</i>.</li>
          </ol>
        </li>
        <li>The <i>iri</i> could not be compacted using the
          <tref title="active context">active context's</tref> <tref>vocabulary mapping</tref>.
          Try to create a <tref>compact IRI</tref>, starting by initializing
          <i>compact IRI</i> to <tref>null</tref>. This variable will be used to
          tore the created <tref>compact IRI</tref>, if any.</li>
        <li>For each key <tref>term</tref> and value <tref>term definition</tref> in
          the <tref>active context</tref>:
          <ol class="algorithm">
            <li>If the <tref>term</tref> contains a colon (<code>:</code>),
              then continue to the next <tref>term</tref> because
              <tref title="term">terms</tref> with colons can't be
              used as <tref title="prefix">prefixes</tref>.</li>
            <li>If the <tref>term definition</tref> is <tref>null</tref>,
              its <tref>IRI mapping</tref> equals <i>iri</i>, or its
              <tref>IRI mapping</tref> is not a substring at the beginning of
              <i>iri</i>, the <tref>term</tref> cannot be used as a <tref>prefix</tref>
              because it is not a partial match with <i>iri</i>.
              Continue with the next <tref>term</tref>.</li>
            <li>Initialize <i>candidate</i> by concatenating <tref>term</tref>,
              a colon (<code>:</code>), and the substring of <i>iri</i>
              that follows after the value of the
              <tref title="term definition">term definition's</tref>
              <tref>IRI mapping</tref>.</li>
            <li>If either <i>compact IRI</i> is <tref>null</tref> or <i>candidate</i> is
              shorter or the same length but lexicographically less than
              <i>compact IRI</i> and <i>candidate</i> does not have a
              <tref>term definition</tref> in <tref>active context</tref> or if the
              <tref>term definition</tref> has an <tref>IRI mapping</tref>
              that equals <i>iri</i> and <i>value</i> is <tref>null</tref>,
              set <i>compact IRI</i> to <i>candidate</i>.</li>
          </ol>
        </li>
        <li>If <i>compact IRI</i> is not <tref>null</tref>, return <i>compact IRI</i>.</li>
        <li>If <i>vocab</i> is <tref>false</tref> then
          transform <i>iri</i> to a <tref>relative IRI</tref> using
          the document's base <tref>IRI</tref>.</li>
        <li>Finally, return <i>iri</i> as is.</li>
      </ol>
    </section>
  </section> <!-- end of IRI Compaction -->

  <section>
    <h2>Term Selection</h2>

    <p>This algorithm, invoked via the <a href="#iri-compaction">IRI Compaction algorithm</a>,
      makes use of an <tref title="active context">active context's</tref>
      <tref>inverse context</tref> to find the <tref>term</tref> that is best
      used to <tref title="compaction">compact</tref> an <tref>IRI</tref>. Other
      information about a value associated with the <tref>IRI</tref> is given,
      including which <tref title="container mapping">container mappings</tref>
      and which <tref>type mapping</tref> or <tref>language mapping</tref> would
      be best used to express the value.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>The <tref title="inverse context">inverse context's</tref> entry for
        the <tref>IRI</tref> will be first searched according to the preferred
        <tref title="container mapping">container mappings</tref>, in the order
        that they are given. Amongst <tref title="term">terms</tref> with a matching
        <tref>container mapping</tref>, preference will be given to those
        with a matching <tref>type mapping</tref> or <tref>language mapping</tref>,
        over those without a <tref>type mapping</tref> or
        <tref>language mapping</tref>. If there is no <tref>term</tref>
        with a matching <tref>container mapping</tref> then the <tref>term</tref>
        without a <tref>container mapping</tref> that matches the given
        <tref>type mapping</tref> or <tref>language mapping</tref> is selected. If
        there is still no selected <tref>term</tref>, then a <tref>term</tref>
        with no <tref>type mapping</tref> or <tref>language mapping</tref> will
        be selected if available. No <tref>term</tref> will be selected that
        has a conflicting <tref>type mapping</tref> or <tref>language mapping</tref>.
        Ties between <tref title="term">terms</tref> that have the same
        mappings are resolved by first choosing the shortest terms, and then by
        choosing the lexicographically least term. Note that these ties are
        resolved automatically because they were previously resolved when the
        <a href="#inverse-context-creation">Inverse Context Creation algorithm</a>
        was used to create the <tref>inverse context</tref>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>This algorithm has five required inputs. They are:
        an <tref>inverse context</tref>, a <tref>keyword</tref> or <tref>IRI</tref>
        <i>iri</i>, an <tref>array</tref> <i>containers</i> that represents an
        ordered list of preferred <tref title="container mapping">container mappings</tref>,
        a <tref>string</tref> <i>type/language</i> that indicates whether
        to look for a <tref>term</tref> with a matching <tref>type mapping</tref>
        or <tref>language mapping</tref>, and an <tref>array</tref> representing
        an ordered list of <i>preferred values</i> for the <tref>type mapping</tref>
        or <tref>language mapping</tref> to look for.</p>

      <ol class="algorithm">
        <li>Initialize <i>container map</i> to the value associated with
          <i>iri</i> in the <tref>inverse context</tref>.</li>
        <li>For each item <i>container</i> in <i>containers</i>:
          <ol class="algorithm">
            <li>If <i>container</i> is not a key in <i>container map</i>, then
              there is no <tref>term</tref> with a matching
              <tref>container mapping</tref> for it, so continue to the next
              <i>container</i>.</li>
            <li>Initialize <i>type/language map</i> to the value associated
              with the <i>container</i> member in <i>container map</i>.</li>
            <li>Initialize <i>value map</i> to the value associated
              with <i>type/language</i> member in <i>type/language map</i>.</li>
            <li>For each <i>item</i> in <i>preferred values</i>:
              <ol class="algorithm">
                <li>If <i>item</i> is not a key in <i>value map</i>,
                  then there is no <tref>term</tref> with a matching
                  <tref>type mapping</tref> or <tref>language mapping</tref>,
                  so continue to the next <i>item</i>.</li>
                <li>Otherwise, a matching term has been found, return the value
                  associated with the <i>item</i> member in
                  <i>value map</i>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>No matching term has been found. Return <tref>null</tref>.</li>
      </ol>
    </section>
  </section> <!-- end of Term Selection -->

  <section>
    <h2>Value Compaction</h2>

    <p><tref>Expansion</tref> transforms all values into <tref>expanded form</tref>
      in JSON-LD. This algorithm performs the opposite operation, transforming
      a value into <tdef>compacted form</tdef>. This algorithm compacts a
      value according to the <tref>term definition</tref> in the given
      <tref>active context</tref> that is associated with the value's associated
      <tref>active property</tref>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>The <i>value</i> to compact has either an <code>@id</code> or an
        <code>@value</code> member.</p>

      <p>For the former case, if the <tref>type mapping</tref> of
        <tref>active property</tref> is set to <code>@id</code> or <code>@vocab</code>
        and <i>value</i> consists of only an <code>@id</code> member and, if
        the <tref>container mapping</tref> of <tref>active property</tref>
        is set to <code>@index</code>, an <code>@index</code> member, <i>value</i>
        can be compacted to a <tref>string</tref> by returning the result of
        using the <a href="#iri-compaction">IRI Compaction algorithm</a>
        to compact the value associated with the <code>@id</code> member.
        Otherwise, <i>value</i> cannot be compacted and is returned as is.</p>

      <p>For the latter case, it might be possible to compact <i>value</i>
        just into the value associated with the <code>@value</code> member.
        This can be done if the <tref>active property</tref> has a matching
        <tref>type mapping</tref> or <tref>language mapping</tref> and there
        is either no <code>@index</code> member or the <tref>container mapping</tref>
        of <tref>active property</tref> is set to <code>@index</code>. It can
        also be done if <code>@value</code> is the only member in <i>value</i>
        (apart an <code>@index</code> member in case the <tref>container mapping</tref>
        of <tref>active property</tref> is set to <code>@index</code>) and
        either its associated value is not a <tref>string</tref>, there is
        no <tref>default language</tref>, or there is an explicit
        <tref>null</tref> <tref>language mapping</tref> for the
        <tref>active property</tref>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>This algorithm has four required inputs: an <tref>active context</tref>, an
        <tref>inverse context</tref>,  an <tref>active property</tref>, and a <i>value</i>
        to be compacted.</p>

      <ol class="algorithm">
        <li>Initialize <i>number members</i> to the number of members
          <i>value</i> contains.</li>
        <li>If <i>value</i> has an <code>@index</code> member and the
          <tref>container mapping</tref> associated to <tref>active property</tref>
          is set to <code>@index</code>, decrease <i>number members</i> by
          <code>1</code>.</li>
        <li>If <i>number members</i> is greater than <code>2</code>, return
          <i>value</i> as it cannot be compacted.</li>
        <li>If <i>value</i> has an <code>@id</code> member:
          <ol class="algorithm">
            <li>If <i>number members</i> is <code>1</code> and
              the <tref>type mapping</tref> of <tref>active property</tref>
              is set to <code>@id</code>, return the result of using the
              <a href="#iri-compaction">IRI compaction algorithm</a>,
              passing <tref>active context</tref>, <tref>inverse context</tref>,
              and the value of the <code>@id</code> member for <i>iri</i>.</li>
            <li>Otherwise, if <i>number members</i> is <code>1</code> and
              the <tref>type mapping</tref> of <tref>active property</tref>
              is set to <code>@vocab</code>, return the result of using the
              <a href="#iri-compaction">IRI compaction algorithm</a>,
              passing <tref>active context</tref>, <tref>inverse context</tref>,
              the value of the <code>@id</code> member for <i>iri</i>, and
              <tref>true</tref> for <i>vocab</i>.</li>
            <li>Otherwise, return <i>value</i> as is.</li>
          </ol>
        </li>
        <li>Otherwise, if <i>value</i> has an <code>@type</code> member whose
          value matches the <tref>type mapping</tref> of <tref>active property</tref>,
          return the value associated with the <code>@value</code> member
          of <i>value</i>.</li>
        <li>Otherwise, if <i>value</i> has an <code>@language</code> member whose
          value matches the <tref>language mapping</tref> of
          <tref>active property</tref>, return the value associated with the
          <code>@value</code> member of <i>value</i>.</li>
        <li>Otherwise, if <i>number members</i> equals <code>1</code> and either
          the value of the <code>@value</code> member is not a <tref>string</tref>,
          or the <tref>active context</tref> has no <tref>default language</tref>,
          or the <tref>language mapping</tref> of <tref>active property</tref>
          is set to <tref>null</tref>,, return the value associated with the
          <code>@value</code> member.</li>
        <li>Otherwise, return <i>value</i> as is.</li>
      </ol>
    </section>
  </section> <!-- end of Value Compaction algorithm -->
</section> <!-- end of Compaction section -->


<section>
  <h1>Flattening Algorithms</h1>

  <section>
    <h2>Flattening Algorithm</h2>

    <p>This algorithm flattens an expanded JSON-LD document by collecting all
      properties of a <tref>node</tref> in a single <tref>JSON object</tref>
      and labeling all <tref title="blank node">blank nodes</tref> with
      <tref title="blank node identifier">blank node identifiers</tref>.
      This resulting uniform shape of the document, may drastically simplify
      the code required to process JSON-LD data in certain applications.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>First, a <i>node map</i> is generated using the
        <a href="#node-map-generation">Node Map Generation algorithm</a>
        which collects all properties of a <tref>node</tref> in a single
        <tref>JSON object</tref>. In the next step, the <i>node map</i> is
        converted to a JSON-LD document in
        <tref href="../json-ld/#flattened-document-form">flattened document form</tref>.
        Finally, if a <tref>context</tref> has been passed, the flattened document
        is compacted using the <a href="#compaction-algorithm">Compaction algorithm</a>
        before being returned.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes two input variables, an <i>element</i> to flatten and
        an optional <i>context</i> used to compact the flattened document. If not
        passed, <i>context</i> is set to <tref>null</tref>.</p>

      <p>This algorithm generates new <tref title="blank node identifier">blank node identifiers</tref>
        and relabels existing <tref title="blank node identifier">blank node identifiers</tref>.
        The used <a href="#generate-blank-node-identifier">Generate Blank Node Identifier algorithm</a>
        keeps an <i>identifier map</i> and a <i>counter</i> to ensure consistent
        relabeling and avoid collisions. Thus, before this algorithm is run,
        the <i>identifier map</i> is reset and the <i>counter</i> is initialized
        to <code>0</code>.</p>

      <ol class="algorithm">
        <li>Initialize <i>node map</i> to a <tref>JSON object</tref> consisting of
          a single member whose key is <code>@default</code> and whose value is
          an empty <tref>JSON object</tref>.</li>
        <li>Perform the <a href="#node-map-generation">Node Map Generation algorithm</a>, passing
          <i>element</i> and <i>node map</i>.</li>
        <li>Initialize <i>default graph</i> to the value of the <code>@default</code>
          member of <i>node map</i>, which is a <tref>JSON object</tref> representing
          the <tref>default graph</tref>.</li>
        <li>For each key-value pair <i>graph name</i>-<i>graph</i> in <i>node map</i>
          where <i>graph name</i> is not <code>@default</code>,  perform the following steps:
          <ol class="algorithm">
            <li>If <i>default graph</i> does not have a <i>graph name</i> member, create
              one and initialize its value to a <tref>JSON object</tref> consisting of an
              <code>@id</code> member whose value is set to <i>graph name</i>.</li>
            <li>Reference the value associated with the <i>graph name</i> member in
              <i>default graph</i> using the variable <i>entry</i>.</li>
            <li>Add an <code>@graph</code> member to <i>entry</i> and set it to an
              empty <tref>array</tref>.</li>
            <li>For each <i>id</i>-<i>node</i> pair in <i>graph</i> ordered by <i>id</i>,
              add <i>node</i> to the <code>@graph</code> member of <i>entry</i>,
              unless the only member of <i>node</i> is <code>@id</code>.</li>
          </ol>
        </li>
        <li>Initialize an empty <tref>array</tref> <i>flattened</i>.</li>
        <li>For each <i>id</i>-<i>node</i> pair in <i>default graph</i> ordered by <i>id</i>,
          add <i>node</i> to <i>flattened</i>,
          unless the only member of <i>node</i> is <code>@id</code>.</li>
        <li>If <i>context</i> is <tref>null</tref>, return <i>flattened</i>.</li>
        <li>Otherwise, return the result of compacting <i>flattened</i> according the
          <a href="#compaction-algorithm">Compaction algorithm</a> passing <i>context</i>
          ensuring that the compaction result has only the <code>@graph</code> keyword (or its alias)
          at the top-level other than <code>@context</code>, even if the context is empty or if there is only one element to
          put in the <code>@graph</code> <tref>array</tref>. This ensures that the returned
          document has a deterministic structure.</li>
      </ol>
    </section>
  </section> <!-- end of Flattening Algorithm -->

  <section>
    <h2>Node Map Generation</h2>

    <p>This algorithm creates a <tref>JSON object</tref> <i>node map</i> holding an indexed
      representation of the <tref title="graph">graphs</tref> and <tref title="node">nodes</tref>
      represented in the passed expanded document. All <tref title="node">nodes</tref> that are not
      uniquely identified by an IRI get assigned a (new) <tref>blank node identifier</tref>.
      The resulting <i>node map</i> will have a member for every graph in the document whose
      value is another object with a member for every <tref>node</tref> represented in the document.
      The default graph is stored under the <code>@default</code> member, all other graphs are
      stored under their <tref>graph name</tref>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>The algorithm recursively runs over an expanded JSON-LD document to
        collect all <tref title="property">properties</tref> of a <tref>node</tref>
        in a single <tref>JSON object</tref>. The algorithm constructs a
        <tref>JSON object</tref> <i>node map</i> whose keys represent the
        <tref title="graph name">graph names</tref> used in the document
        (the <tref>default graph</tref> is stored under the key <code>@default</code>)
        and whose associated values are <tref title="JSON object">JSON objects</tref>
        which index the <tref title="node">nodes</tref> in the
        <tref title="graph">graph</tref>. If a
        <tref title="property">property's</tref> value is a <tref>node object</tref>,
        it is replaced by a <tref>node object</tref> consisting of only an
        <code>@id</code> member. If a <tref>node object</tref> has no <code>@id</code>
        member or it is identified by a <tref>blank node identifier</tref>,
        a new <tref>blank node identifier</tref> is generated. This relabeling
        of <tref title="blank node identifier">blank node identifiers</tref> is
        also done for <tref title="property">properties</tref> and values of
        <code>@type</code>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes as input an expanded JSON-LD document <i>element</i> and a reference to
        a <tref>JSON object</tref> <i>node map</i>. Furthermore it has the optional parameters
        <tref>active graph</tref> (which defaults to <code>@default</code>), an <tref>active subject</tref>,
        <tref>active property</tref>, and a reference to a <tref>JSON object</tref> <i>list</i>. If
        not passed, <tref>active subject</tref>, <tref>active property</tref>, and <i>list</i> are
        set to <tref>null</tref>.</p>

      <ol class="algorithm">
        <li>If <i>element</i> is an array, process each <i>item</i> in <i>element</i>
          as follows and then return:
          <ol class="algorithm">
            <li>Run this algorithm recursively by passing <i>item</i> for <i>element</i>,
              <i>node map</i>, <tref>active graph</tref>, <tref>active subject</tref>,
              <tref>active property</tref>, and <i>list</i>.</li>
          </ol>
        </li>
        <li>Otherwise <i>element</i> is a <tref>JSON object</tref>. Reference the
          <tref>JSON object</tref> which is the value of the <tref>active graph</tref>
          member of <i>node map</i> using the variable <i>graph</i>. If the
          <tref>active subject</tref> is <tref>null</tref>, set <i>node</i> to <tref>null</tref>
          otherwise reference the <tref>active subject</tref> member of <i>graph</i> using the
          variable <i>node</i>.</li>
        <li>If <i>element</i> has an <code>@type</code> member, perform for each
          <i>item</i> the following steps:
          <ol class="algorithm">
            <li>If <i>item</i> is a <tref>blank node identifier</tref>, replace it with a newly
              <a href="#generate-blank-node-identifier">generated blank node identifier</a>
              passing <i>item</i> for <i>identifier</i>.</li>
          </ol>
        </li>
        <li>If <i>element</i> has an <code>@value</code> member, perform the following steps:
          <ol class="algorithm">
            <li>If <i>list</i> is <tref>null</tref>:
              <ol class="algorithm">
                <li>If <i>node</i> does not have an <tref>active property</tref> member,
                  create one and initialize its value to an <tref>array</tref>
                  containing <i>element</i>.</li>
                <li>Otherwise, compare <i>element</i> against every item in the
                  <tref>array</tref> associated with the <tref>active property</tref>
                  member of <i>node</i>. If there is no item equivalent to <i>element</i>,
                  append <i>element</i> to the <tref>array</tref>. Two
                  <tref title="JSON object">JSON objects</tref> are considered
                  equal if they have equivalent key-value pairs.</li>
              </ol>
            </li>
            <li>Otherwise, append <i>element</i> to the <code>@list</code> member of <i>list</i>.</li>
          </ol>
        </li>
        <li>Otherwise, if <i>element</i> has an <code>@list</code> member, perform
          the following steps:
          <ol class="algorithm">
            <li>Initialize a new <tref>JSON object</tref> <i>result</i> consisting of a single member
              <code>@list</code> whose value is initialized to an empty <tref>array</tref>.</li>
            <li>Recursively call this algorithm passing the value of <i>element's</i>
              <code>@list</code> member for <i>element</i>, <tref>active graph</tref>,
              <tref>active subject</tref>, <tref>active property</tref>, and
              <i>result</i> for <i>list</i>.</li>
            <li>Append <i>result</i> to the value of the <tref>active property</tref> member
              of <i>node</i>.</li>
          </ol>
        </li>
        <li>Otherwise <i>element</i> is a <tref>node object</tref>, perform
          the following steps:
          <ol class="algorithm">
            <li>If <i>element</i> has an <code>@id</code> member, set <i>id</i>
              to its value and remove the member from <i>element</i>. If <i>id</i>
              is a <tref>blank node identifier</tref>, replace it with a newly
              <a href="#generate-blank-node-identifier">generated blank node identifier</a>
              passing <i>id</i> for <i>identifier</i>.</li>
            <li>Otherwise, set <i>id</i> to the result of the
              <a href="#generate-blank-node-identifier">Generate Blank Node Identifier algorithm</a>
              passing <tref>null</tref> for <i>identifier</i>.</li>
            <li>If <i>graph</i> does not contain a member <i>id</i>, create one and initialize
              its value to a <tref>JSON object</tref> consisting of a single member <code>@id</code> whose
              value is <i>id</i>.</li>
            <li>If <tref>active property</tref> is not <tref>null</tref>, perform the following steps:
              <ol class="algorithm">
                <li>Create a new <tref>JSON object</tref> <i>reference</i> consisting of a single member
                  <code>@id</code> whose value is <i>id</i>.</li>
                <li>If <i>list</i> is <tref>null</tref>:
                  <ol class="algorithm">
                    <li>If <i>node</i> does not have an <tref>active property</tref> member,
                      create one and initialize its value to an <tref>array</tref>
                      containing <i>reference</i>.</li>
                    <li>Otherwise, compare <i>reference</i> against every item in the
                      <tref>array</tref> associated with the <tref>active property</tref>
                      member of <i>node</i>. If there is no item equivalent to <i>reference</i>,
                      append <i>reference</i> to the <tref>array</tref>. Two
                      <tref title="JSON object">JSON objects</tref> are considered
                      equal if they have equivalent key-value pairs.</li>
                  </ol>
                </li>
                <li>Otherwise, append <i>element</i> to the <code>@list</code> member of <i>list</i>.</li>
              </ol>
            </li>
            <li>Reference the value of the <i>id</i> member of <i>graph</i> using the
              variable <i>node</i>.</li>
            <li>If <i>element</i> has an <code>@type</code> key, append
              each item of its associated <tref>array</tref> to the
              <tref>array</tref> associated with the <code>@type</code> key of
              <i>node</i> unless it is already in that <tref>array</tref>. Finally
              remove the <code>@type</code> member from <i>element</i>.</li>
            <li>If <i>element</i> has an <code>@index</code> member, set the <code>@index</code>
              member of <i>node</i> to its value. If <tref>node</tref> has already an
              <code>@index</code> member with a different value, a
              <code class="error"><a href="#idl-def-JsonLdErrorCode.conflicting-indexes">conflicting indexes</a></code>
              error has been detected and processing is aborted. Otherwise, continue by
              removing the <code>@index</code> member from <i>element</i>.</li>
            <li>If <i>element</i> has an <code>@reverse</code> member:
              <ol class="algorithm">
                <li>Create a <tref>JSON object</tref> <i>referenced node</i> with a single member <code>@id</code> whose
                  value is <i>id</i>.</li>
                <li>Set <i>reverse map</i> to the value of the <code>@reverse</code> member of
                  <i>element</i>.</li>
                <li>For each key-value pair <i>property</i>-<i>values</i> in <i>reverse map</i>:
                  <ol class="algorithm">
                    <li>For each <i>value</i> of <i>values</i>:
                      <ol class="algorithm">
                        <li>If <i>value</i> has a <i>property</i> member, append <i>referenced node</i> to
                          its value; otherwise create a <i>property</i> member whose value is an
                          <tref>array</tref> containing <i>referenced node</i>.</li>
                        <li>Recursively invoke this algorithm passing <i>value</i> for
                          <i>element</i>, <i>node map</i>, and <tref>active graph</tref>.</li>
                      </ol>
                    </li>
                  </ol>
                </li>
                <li>Remove the <code>@reverse</code> member from <i>element</i>.</li>
              </ol>
            </li>
            <li>If <i>element</i> has an <code>@graph</code> member, recursively invoke this
              algorithm passing the value of the <code>@graph</code> member for <i>element</i>,
              <i>node map</i>, and <i>id</i> for <tref>active graph</tref> before removing
              the <code>@graph</code> member from <i>element</i>.</li>
            <li>Finally, for each key-value pair <i>property</i>-<i>value</i> in <i>element</i> ordered by
              <i>property</i> perform the following steps:
              <ol class="algorithm">
                <li>If <i>property</i> is a <tref>blank node identifier</tref>, replace it with a newly
                  <a href="#generate-blank-node-identifier">generated blank node identifier</a>
                  passing <i>property</i> for <i>identifier</i>.</li>
                <li>If <i>node</i> does not have a <i>property</i> member, create one and initialize
                  its value to an empty <tref>array</tref>.</li>
                <li>Recursively invoke this algorithm passing <i>value</i> for <i>element</i>,
                  <i>node map</i>, <tref>active graph</tref>, <i>id</i> for <tref>active subject</tref>,
                  and <i>property</i> for <tref>active property</tref>.</li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
    </section>
  </section> <!-- end of Node Map Generation -->

  <section>
    <h2>Generate Blank Node Identifier</h2>

    <p>This algorithm is used to generate new
      <tref title="blank node identifier">blank node identifiers</tref> or to
      relabel an existing <tref>blank node identifier</tref> to avoid collision
      by the introduction of new ones.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>The simplest case is if there exists already a <tref>blank node identifier</tref>
        in the <i>identifier map</i> for the passed <i>identifier</i>, in which
        case it is simply returned. Otherwise, a new <tref>blank node identifier</tref>
        is generated by concatenating the string <code>_:b</code> and the
        <i>counter</i>. If the passed <i>identifier</i> is not <tref>null</tref>,
        an entry is created in the <i>identifier map</i> associating the
        <i>identifier</i> with the <tref>blank node identifier</tref>. Finally,
        the <i>counter</i> is increased by one and the new
        <tref>blank node identifier</tref> is returned.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes a single input variable <i>identifier</i> which may
        be <tref>null</tref>. Between its executions, the algorithm needs to
        keep an <i>identifier map</i> to relabel existing
        <tref title="blank node identifier">blank node identifiers</tref>
        consistently and a <i>counter</i> to generate new
        <tref title="blank node identifier">blank node identifiers</tref>. The
        <i>counter</i> is initialized to <code>0</code> by default.</p>

      <ol class="algorithm">
        <li>If <i>identifier</i> is not <tref>null</tref> and has an entry in the
          <i>identifier map</i>, return the mapped identifier.</li>
        <li>Otherwise, generate a new <tref>blank node identifier</tref> by concatenating
          the string <code>_:b</code> and <i>counter</i>.</li>
        <li>Increment <i>counter</i> by <code>1</code>.</li>
        <li>If <i>identifier</i> is not <tref>null</tref>, create a new entry
          for <i>identifier</i> in <i>identifier map</i> and set its value
          to the new <tref>blank node identifier</tref>.</li>
        <li>Return the new <tref>blank node identifier</tref>.</li>
      </ol>
    </section>
  </section> <!-- end of Generate Blank Node Identifier -->
</section> <!-- end of Flattening section -->


<section>
  <h1>RDF Serialization/Deserialization Algorithms</h1>

  <p>This section describes algorithms to deserialize a JSON-LD document to an
    <tref>RDF dataset</tref> and vice versa. The algorithms are designed for in-memory
    implementations with random access to <tref>JSON object</tref> elements.</p>

  <p>Throughout this section, the following vocabulary
    <tref title="prefix">prefixes</tref> are used in
    <tref title="compact iri">compact IRIs</tref>:</p>

  <table class="simple">
    <thead>
      <th>Prefix</th>
      <th>IRI</th>
    </thead>
    <tbody>
      <tr>
        <td>rdf</td>
        <td>http://www.w3.org/1999/02/22-rdf-syntax-ns#</td>
      </tr>
      <tr>
        <td>rdfs</td>
        <td> http://www.w3.org/2000/01/rdf-schema#</td>
      </tr>
      <tr>
        <td>xsd</td>
        <td>http://www.w3.org/2001/XMLSchema#</td>
      </tr>
    </tbody>
  </table>

  <section>
    <h2>Deserialize JSON-LD to RDF algorithm</h2>

    <p>This algorithm deserializes a JSON-LD document to an <tref>RDF dataset</tref>.
      Please note that RDF does not allow a <tref>blank node</tref> to be used
      as a <tref>property</tref>, while JSON-LD does.  Therefore, by default
      RDF triples that would have contained blank nodes as properties are
      discarded when interpreting JSON-LD as RDF.</p>

    <div class="issue atrisk" id="at-risk-3" data-number="3" title="Allow blank nodes to be used as properties">
      <p class="atrisk-head">Note: This feature is
        <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a> and
        may be removed from this specification based on feedback. Please send feedback to
        <a href="mailto:public-rdf-comments@w3.org">public-rdf-comments@w3.org</a>.
        For the current status see
        <a href="http://www.w3.org/2011/rdf-wg/wiki/JSON-LD_Features_at_Risk">features "at risk" in JSON-LD 1.0</a></p>
      <p>RDF graphs do not allow <tref title="blank node">blank nodes</tref> to be used
        as an <tref>RDF predicate</tref>, while JSON-LD does.
        Unless the <i>produce generalized RDF</i> flag is set, this algorithm will exclude
        triples including a <tref>blank node</tref> <tref>RDF predicate</tref>.</p>
    </div>

    <section class="informative">
      <h3>Overview</h3>

      <p>The JSON-LD document is expanded and converted to a <i>node map</i> using the
        <a href="#node-map-generation">Node Map Generation algorithm</a>.
        This allows each graph represented within the document to be
        extracted and flattened, making it easier to process each
        <tref>node object</tref>. Each graph from the <i>node map</i>
        is processed to extract <tref title="rdf triple">RDF triples</tref>,
        to which any (non-default) graph name is applied to create an
        <tref>RDF dataset</tref>. Each <tref>node object</tref> in the
        <i>node map</i> has an <code>@id</code> member which corresponds to the
        <tref title="RDF subject">RDF subject</tref>, the other members
        represent <tref title="RDF predicate">RDF predicates</tref>. Each
        member value is either an <tref>IRI</tref> or
        <tref>blank node identifier</tref> or can be transformed to an
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">RDF literal</tref>
        to generate an <tref>RDF triple</tref>. <tref title="list">Lists</tref>
        are transformed into an
        <tref href="http://www.w3.org/TR/rdf-schema/#ch_collectionvocab">RDF Collection</tref>
        using the <a href="#list-to-rdf-conversion">List to RDF Conversion algorithm.</a></p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes a JSON-LD document <i>element</i> and returns an
        <tref>RDF dataset</tref>. Unless the <i>produce generalized RDF</i> flag
        is set to <tref>true</tref>, <tref title="RDF triple">RDF triples</tref>
        containing a <tref>blank node</tref> <tref title="rdf predicate">predicate</tref>
        are excluded from output.</p>

      <p>This algorithm generates new <tref title="blank node identifier">blank node identifiers</tref>
        and relabels existing <tref title="blank node identifier">blank node identifiers</tref>.
        The used <a href="#generate-blank-node-identifier">Generate Blank Node Identifier algorithm</a>
        keeps an <i>identifier map</i> and a <i>counter</i> to ensure consistent
        relabeling and avoid collisions. Thus, before this algorithm is run,
        the <i>identifier map</i> is reset and the <i>counter</i> is initialized
        to <code>0</code>.</p>

      <ol class="algorithm">
        <li>Expand <i>element</i> according to the
          <a href="#expansion-algorithm">Expansion algorithm</a>.</li>
        <li>Generate a <i>node map</i> according to the
          <a href="#node-map-generation">Node Map Generation algorithm</a>.</li>
        <li>Initialize an empty <tref>RDF dataset</tref> <i>dataset</i>.</li>
        <li>For each <i>graph name</i> and <i>graph</i> in <i>node map</i>
          ordered by <i>graph name</i>:
          <ol class="algorithm">
            <li>If <i>graph name</i> is a <tref>relative IRI</tref>, continue
              with the next <i>graph name</i>-<i>graph</i> pair.</li>
            <li>Initialize <i>triples</i> as an empty <tref>array</tref>.</li>
            <li>For each <i>subject</i> and <i>node</i> in <i>graph</i> ordered
              by <i>subject</i>:
              <ol class="algorithm">
                <li>If <i>subject</i> is a <tref>relative IRI</tref>, continue
                  with the next <i>subject</i>-<i>node</i> pair.</li>
                <li>For each <i>property</i> and <i>values</i> in <i>node</i>
                  ordered by <i>property</i>:
                  <ol class="algorithm">
                    <li>If <i>property</i> is <code>@type</code>, then for each
                      <i>type</i> in <i>values</i>, append a <tref>triple</tref>
                      composed of <i>subject</i>, <code>rdf:type</code>,
                      and <i>type</i> to <i>triples</i>.</li>
                    <li>Otherwise, if <i>property</i> is a <tref>keyword</tref>
                      continue with the next <i>property</i>-<i>values</i> pair.</li>
                    <li>Otherwise, if <i>property</i> is a <tref>blank node identifier</tref> and
                      the <i>produce generalized RDF</i> flag is not <tref>true</tref>,
                      continue with the next <i>property</i>-<i>values</i> pair.</li>
                    <li>Otherwise, if <i>property</i> is a <tref>relative IRI</tref>,
                      continue with the next <i>property</i>-<i>values</i> pair.</li>
                    <li>Otherwise, <i>property</i> is an <tref>absolute IRI</tref> or
                      <tref>blank node identifier</tref>. For each <i>item</i>
                      in <i>values</i>:
                      <ol class="algorithm">
                        <li>If <i>item</i> is a <tref>list object</tref>, initialize
                          <i>list triples</i> as an empty <tref>array</tref> and
                          <i>list head</i> to the result of the <a
                          href="#list-to-rdf-conversion">List Conversion algorithm</a>, passing
                          the value associated with the <code>@list</code> key from
                          <i>item</i> and <i>list triples</i>. Append first a
                          <tref>triple</tref> composed of <i>subject</i>,
                          <i>property</i>, and <i>list head</i> to <i>triples</i> and
                          finally append all <tref title="triple">triples</tref> from
                          <i>list triples</i> to <i>triples</i>.</li>
                        <li>Otherwise, <i>item</i> is a <tref>value object</tref>
                          or a <tref>node object</tref>. Append a <tref>triple</tref>
                          composed of <i>subject</i>, <i>property</i>, and
                          the result of using the
                          <a href="#object-to-rdf-conversion">Object to RDF Conversion algorithm</a>
                          passing <i>item</i> to <i>triples</i>, unless the result is
                          <tref>null</tref>, indicating a <tref>relative IRI</tref> that has
                          to be ignored.</li>
                      </ol>
                    </li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>If <i>graph name</i> is <code>@default</code>, add
              <i>triples</i> to the <tref>default graph</tref> in <i>dataset</i>.</li>
            <li>Otherwise, create a <tref>named graph</tref> in <i>dataset</i>
              composed of <i>graph name</i> and add <i>triples</i>.</li>
          </ol>
        </li>
        <li>Return <i>dataset</i>.</li>
      </ol>
    </section>
  </section> <!-- end of Deserialize JSON-LD to RDF algorithm -->

  <section>
    <h3>Object to RDF Conversion</h3>

    <p>This algorithm takes a <tref>node object</tref> or <tref>value object</tref>
      and transforms it into an
      <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-resource">RDF resource</tref>
      to be used as the <tref>object</tref> of an <tref>RDF triple</tref>. If a
      <tref>node object</tref> containing a <tref>relative IRI</tref> is passed to
      the algorithm, <tref>null</tref> is returned which then causes the resulting
      <tref>RDF triple</tref> to be ignored.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p><tref title="value object">Value objects</tref> are transformed to
        <tref title="RDF literal">RDF literals</tref> as described in
        <a class="sectionRef" href="#data-round-tripping">Data Round Tripping</a>
        whereas <tref title="node object">node objects</tref> are transformed
        to <tref title="IRI">IRIs</tref>,
        <tref title="blank node identifier">blank node identifiers</tref>,
        or <tref>null</tref>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes as its sole argument <i>item</i> which must be
        either a <tref>value object</tref> or <tref>node object</tref>.</p>

      <ol class="algorithm">
        <li>If <i>item</i> is a <tref>node object</tref> and the value of
          its <code>@id</code> member is a <tref>relative IRI</tref>, return
          <tref>null</tref>.</li>
        <li>If <i>item</i> is a <tref>node object</tref>, return the
          <tref>IRI</tref> or <tref>blank node identifier</tref> associated
          with its <code>@id</code> member.</li>
        <li>Otherwise, <i>item</i> is a <tref>value object</tref>. Initialize
          <i>value</i> to the value associated with the <code>@value</code>
          member in <i>item</i>.
        <li>Initialize <i>datatype</i> to the value associated with the
          <code>@type</code> member of <i>item</i> or  <tref>null</tref> if
          <i>item</i> does not have such a member.</li>
        <li>If <i>value</i> is <tref>true</tref> or
          <tref>false</tref>, set <i>value</i> to the <tref>string</tref>
          <code>true</code> or <code>false</code> which is the
          <tref>canonical lexical form</tref> as described in
          <a class="sectionRef" href="#data-round-tripping">Data Round Tripping</a>
          If <i>datatype</i> is <tref>null</tref>, set it to
          <code>xsd:boolean</code>.</li>
        <li>Otherwise, if <i>value</i> is a <tref>number</tref> with a non-zero fractional
          part (the result of a modulo&#8209;1 operation) or <i>value</i> is a <tref>number</tref>
          and <i>datatype</i> equals <code>xsd:double</code>, convert <i>value</i> to a
          <tref>string</tref> in <tref>canonical lexical form</tref> of
          an <code>xsd:double</code> as defined in [[!XMLSCHEMA11-2]]
          and described in
          <a class="sectionRef" href="#data-round-tripping">Data Round Tripping</a>.
          If <i>datatype</i> is <tref>null</tref>, set it to
          <code>xsd:double</code>.</li>
        <li>Otherwise, if <i>value</i> is a <tref>number</tref> with no non-zero
          fractional part (the result of a modulo&#8209;1 operation) or <i>value</i>
          is a <tref>number</tref> and <i>datatype</i>
          equals <code>xsd:integer</code>, convert <i>value</i> to a
          <tref>string</tref> in <tref>canonical lexical form</tref> of
          an <code>xsd:integer</code> as defined in [[!XMLSCHEMA11-2]]
          and described in
          <a class="sectionRef" href="#data-round-tripping">Data Round Tripping</a>.
          If <i>datatype</i> is <tref>null</tref>, set it to
          <code>xsd:integer</code>.</li>
        <li>Otherwise, if <i>datatype</i> is <tref>null</tref>, set it to
          <code>xsd:string</code> or <code>rdf:langString</code>, depending on if
          item has an <code>@language</code> member.</li>
        <li>Initialize <i>literal</i> as an <tref>RDF literal</tref> using
          <i>value</i> and <i>datatype</i>. If <i>item</i> has an
          <code>@language</code> member, add the value associated with the
          <code>@language</code> key as the language tag of <i>literal</i>.</li>
        <li>Return <i>literal</i>.</li>
        </li>
      </ol>
    </section>
  </section> <!-- end of Object to RDF Conversion -->

  <section>
    <h3>List to RDF Conversion</h3>

    <p>List Conversion is the process of taking a <tref>list object</tref>
      and transforming it into an
      <tref href="http://www.w3.org/TR/rdf-schema/#ch_collectionvocab">RDF Collection</tref>
      as defined in RDF Semantics [[!RDF-MT]].</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>For each element of the <tref>list</tref> a new <tref>blank node identifier</tref>
        is allocated which is used to generate <code>rdf:first</code> and
        <code>rdf:rest</code> <tref title="RDF triple">triples</tref>. The
        algorithm returns the list head, which is either the first allocated
        <tref>blank node identifier</tref> or <code>rdf:nil</code> if the
        <tref>list</tref> is empty. If a list element represents a <tref>relative IRI</tref>,
        the corresponding <code>rdf:first</code> triple is omitted.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>The algorithm takes two inputs: an <tref>array</tref> <i>list</i>
        and an empty <tref>array</tref> <i>list triples</i> used for returning
        the generated <tref title="RDF triple">triples</tref>.</p>

      <ol class="algorithm">
        <li>If <i>list</i> is empty, return <code>rdf:nil</code>.</li>
        <li>Otherwise, create an <tref>array</tref> <i>bnodes</i> composed of a
          <a href="#generate-blank-node-identifier">newly generated blank node identifier</a>
          for each entry in <i>list</i>.</li>
        <li>Initialize an empty <tref>array</tref> <i>list triples</i>.</li>
        <li>For each pair of <i>subject</i> from <i>bnodes</i> and <i>item</i> from <i>list</i>:
          <ol class="algorithm">
            <li>Initialize <i>object</i> to the result of using the
              <a href="#object-to-rdf-conversion">Object to RDF Conversion algorithm</a>
              passing <i>item</i> to <i>list triples</i>.</li>
            <li>Unless <i>object</i> is <tref>null</tref>, append a <tref>triple</tref>
              composed of <i>subject</i>, <code>rdf:first</code>, and <i>object</i>.</li>
            <li>Set <i>rest</i> as the next entry in <i>bnodes</i>, or if that
              does not exist, <code>rdf:nil</code>. Append a
              <tref>triple</tref> composed of <i>subject</i>,
              <code>rdf:rest</code>, and <i>rest</i> to <i>list triples</i>.</li>
          </ol>
        </li>
        <li>Return the first <tref>blank node</tref> from <i>bnodes</i> or
          <code>rdf:nil</code> if <i>bnodes</i> is empty.</li>
      </ol>
    </section>
  </section> <!-- end of List to RDF -->

  <section>
    <h2>Serialize RDF as JSON-LD Algorithm</h2>

    <p>This algorithm serializes an <tref>RDF dataset</tref> consisting of a
      <tref>default graph</tref> and zero or more
      <tref title="named graph">named graphs</tref> into a JSON-LD document.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p>Iterate through each graph in the dataset, converting each
        <tref title="rdf collection">RDF Collection</tref> into a <tref>list</tref>
        and generating a JSON-LD document in expanded form for all
        <tref title="RDF literal">RDF literals</tref>, <tref title="IRI">IRIs</tref>
        and <tref title="blank node identifier">blank node identifiers</tref>.
        If the <i>use native types</i> flag is set to <tref>true</tref>,
        <tref title="RDF literal">RDF literals</tref> with a
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
        that equals <code>xsd:integer</code> or <code>xsd:double</code> are converted
        to a <tref title="number">JSON numbers</tref> and <tref title="RDF literal">RDF literals</tref>
        with a <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
        that equals <code>xsd:boolean</code> are converted to <tref>true</tref> or
        <tref>false</tref> based on their
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</tref>
        as described in
        <a class="sectionRef" href="#data-round-tripping">Data Round Tripping</a>.</p>
    </section>

    <section>
      <h2>Algorithm</h2>

      <p>The algorithm takes two required inputs: an <tref>RDF dataset</tref> and a flag
        <i>use native types</i> that defaults to <tref>false</tref>.</p>

      <ol class="algorithm">
        <li>Initialize <i>default graph</i> to an empty <tref>JSON object</tref>.</li>
        <li>Initialize <i>graph map</i> to a <tref>JSON object</tref> consisting
          of a single member <code>@default</code> whose value references
          <i>default graph</i>.</li>
        <li>For each <i>graph</i> in <tref>RDF dataset</tref>:
          <ol class="algorithm">
            <li>If <i>graph</i> is the <tref>default graph</tref>,
              set <i>name</i> to <code>@default</code>, otherwise to the
              <tref>graph name</tref> associated with <i>graph</i>.</li>
            <li>If <i>graph map</i> has no <i>name</i> member, create one and set
              its value to an empty <tref>JSON object</tref>.</li>
            <li>If <i>graph</i> is not the <tref>default graph</tref> and
              <i>default graph</i> does not have a <i>name</i> member,
              create such a member and initialize its value to a new
              <tref>JSON object</tref> with a single member <code>@id</code>
              whose value is <i>name</i>.</li>
            <li>Reference the value of the <i>name</i> member in <i>graph map</i>
              using the variable <i>node map</i>.</li>
            <li>For each <tref>RDF triple</tref> in <i>graph</i>
              consisting of <i>subject</i>, <i>predicate</i>, and <i>object</i>:
              <ol class="algorithm">
                <li>If <i>node map</i> does not have a <i>subject</i> member,
                  create one and initialize its value to a new <tref>JSON object</tref>
                  consisting of a single member <code>@id</code> whose value is
                  set to <i>subject</i>.</li>
                <li>Reference the value of the <i>subject</i> member in <i>node map</i>
                  using the variable <i>node</i>.</li>
                <li>If <i>object</i> is an <tref>IRI</tref> or <tref>blank node identifier</tref>,
                  and <i>node map</i> does not have an <i>object</i> member,
                  create one and initialize its value to a new <tref>JSON object</tref>
                  consisting of a single member <code>@id</code> whose value is
                  set to <i>object</i>.</li>
                <li>If <i>predicate</i> equals <code>rdf:type</code>, and <i>object</i>
                  is an <tref>IRI</tref> or <tref>blank node identifier</tref>,
                  append <i>object</i> to the value of the <code>@type</code>
                  member of <i>node</i>; unless such an item already exists.
                  If no such member exists, create one
                  and initialize it to an <tref>array</tref> whose only item is
                  <i>object</i>. Finally, continue to the next
                  <tref>RDF triple</tref>.</li>
                <li>Set <i>value</i> to the result of using the
                  <a href="#rdf-to-object-conversion">RDF to Object Conversion algorithm</a>,
                  passing <i>object</i> and <i>use native types</i>.</li>
                <li>If <i>node</i> does not have an <i>predicate</i> member, create one
                  and initialize its value to an empty <tref>array</tref>.</li>
                <li>If there is no item equivalent to <i>value</i> in the <tref>array</tref>
                  associated with the <i>predicate</i> member of <i>node</i>, append a
                  reference to <i>value</i> to the <tref>array</tref>. Two JSON objects
                  are considered equal if they have equivalent key-value pairs.</li>
                <li>If <i>object</i> is a <tref>blank node identifier</tref> or <tref>IRI</tref>,
                  it might represent the list node:
                  <ol class="algorithm">
                    <li>If the <i>object</i> member of <i>node map</i> has no
                      <code>usages</code> member, create one and initialize it to
                      an empty <tref>array</tref>.</li>
                    <li>Reference the <code>usages</code> member of the <i>object</i>
                      member of <i>node map</i> using the variable <i>usages</i>.</li>
                    <li>Append a new <tref>JSON object</tref> consisting of three
                      members, <code>node</code>, <code>property</code>, and <code>value</code>
                      to the <i>usages</i> <tref>array</tref>. The <code>node</code> member
                      is set to a reference to <i>node</i>, <code>property</code> to <i>predicate</i>,
                      and <code>value</code> to a reference to <i>value</i>.</li>
                  </ol>
                </li>
              </ol>
            </li>
          </ol>
        </li>
        <li>For each <i>name</i> and <i>graph object</i> in <i>graph map</i>:
          <ol class="algorithm">
            <li>If <i>graph object</i> has no <code>rdf:nil</code> member, continue
              with the next <i>name</i>-<i>graph object</i> pair as the graph does
              not contain any lists that need to be converted.</li>
            <li>Initialize <i>nil</i> to the value of the <code>rdf:nil</code> member
              of <i>graph object</i>.</li>
            <li>For each item <i>usage</i> in the <code>usages</code> member of
              <i>nil</i>, perform the following steps:
              <ol class="algorithm">
                <li>Initialize <i>node</i> to the value of the value of the
                  <code>node</code> member of <i>usage</i>, <i>property</i> to
                  the value of the <code>property</code> member of <i>usage</i>,
                  and <i>head</i> to the value of the <code>value</code> member
                  of <i>usage</i>.</li>
                <li>Initialize two empty <tref title="array">arrays</tref> <i>list</i>
                  and <i>list nodes</i>.</li>
                <li>While <i>property</i> equals <code>rdf:rest</code>, the value
                  associated to the <code>usages</code> member of <i>node</i> has
                  exactly 1 entry, <i>node</i> has a <code>rdf:first</code> and
                  <code>rdf:rest</code> property, both of which have as value an
                  <tref>array</tref> consisting of a single element, and <i>node</i>
                  has no other members apart from an optional <code>@type</code>
                  member whose value is an array with a single item equal to
                  <code>rdf:List</code>, <i>node</i> represents a well-formed list
                  node. Perform the following steps to traverse the list backwards
                  towards its head:
                  <ol class="algorithm">
                    <li>Append the only item of <code>rdf:first</code> member of
                      <i>node</i> to the <i>list</i> <tref>array</tref>.</li>
                    <li>Append the value of the <code>@id</code> member of
                      <i>node</i> to the <i>list nodes</i> <tref>array</tref>.</li>
                    <li>Initialize <i>node usage</i> to the only item of the
                      <code>usages</code> member of <i>node</i>.</li>
                    <li>Set <i>node</i> to the value of the <code>node</code> member
                      of <i>node usage</i>, <i>property</i> to the value of the
                      <code>property</code> member of <i>node usage</i>, and
                      <i>head</i> to the value of the <code>value</code> member
                      of <i>node usage</i>.</li>
                    <li>If the <code>@id</code> member of <i>node</i> is an
                      <tref>IRI</tref> instead of a <tref>blank node identifier</tref>,
                      exit the while loop.</li>
                  </ol>
                </li>
                <li>If <i>property</i> equals <code>rdf:first</code>, i.e., the
                  detected list is nested inside another list
                  <ol class="algorithm">
                    <li>and the value of the <code>@id</code> of <i>node</i> equals
                      <code>rdf:nil</code>, i.e., the detected list is empty,
                      continue with the next <i>usage</i> item. The
                      <code>rdf:nil</code> node cannot be converted to a
                      <tref>list object</tref> as it would result in a list of
                      lists, which isn't supported.</li>
                    <li>Otherwise, the list consists of at least one item. We preserve the
                      head node and transform the rest of the linked list to a
                      <tref>list object</tref>.</li>
                    <li>Set <i>head id</i> to the value of the <code>@id</code>
                      member of <i>head</i>.</li>
                    <li>Set <i>head</i> to the value of the <i>head id</i> member of
                      <i>graph object</i> so that all it's properties can be accessed.</li>
                    <li>Then, set <i>head</i> to the only item in the value of the
                      <code>rdf:rest</code> member of <i>head</i>.</li>
                    <li>Finally, remove the last item of the <i>list</i> <tref>array</tref>
                      and the last item of the <i>list nodes</i> <tref>array</tref>.</li>
                  </ol>
                </li>
                <li>Remove the <code>@id</code> member from <i>head</i>.</li>
                <li>Reverse the order of the <i>list</i> <tref>array</tref>.</li>
                <li>Add a <code>@list</code> member to <i>head</i> and initialize
                  its value to the <i>list</i> <tref>array</tref>.</li>
                <li>For each item <i>node id</i> in <i>list nodes</i>, remove the
                  <i>node id</i> member from <i>graph object</i>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Initialize an empty <tref>array</tref> <i>result</i>.</li>
        <li>For each <i>subject</i> and <i>node</i> in <i>default graph</i>
          ordered by <i>subject</i>:
          <ol class="algorithm">
            <li>If <i>graph map</i> has a <i>subject</i> member:
              <ol class="algorithm">
                <li>Add a <code>@graph</code> member to <i>node</i> and initialize
                  its value to an empty <tref>array</tref>.</li>
                <li>For each key-value pair <i>s</i>-<i>n</i> in the <i>subject</i>
                  member of <i>graph map</i> ordered by <i>s</i>, append <i>n</i>
                  to the <code>@graph</code> member of <i>node</i> after
                  removing its <code>usages</code> member, unless the only
                  remaining member of <i>n</i> is <code>@id</code>.</li>
              </ol>
            </li>
            <li>Append <i>node</i> to <i>result</i> after removing its
              <code>usages</code> member, unless the only remaining member of
              <i>node</i> is <code>@id</code>.</li>
          </ol>
        </li>
        <li>Return <i>result</i>.</li>
      </ol>
    </section>
  </section> <!-- end of Serialize RDF as JSON-LD Algorithm -->

  <section>
    <h2>RDF to Object Conversion</h2>

    <p>This algorithm transforms an RDF literal to a JSON-LD <tref>value object</tref>
      and a RDF blank node or IRI to an JSON-LD <tref>node object</tref>.</p>

    <section class="informative">
      <h3>Overview</h3>

      <p><tref title="RDF literal">RDF literals</tref> are transformed to
        <tref title="value object">value objects</tref> whereas <tref title="IRI">IRIs</tref> and
        <tref title="blank node identifier">blank node identifiers</tref> are
        transformed to <tref title="node object">node objects</tref>.
        If the <i>use native types</i> flag is set to <tref>true</tref>,
        <tref title="RDF literal">RDF literals</tref> with a
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
        that equals <code>xsd:integer</code> or <code>xsd:double</code> are converted
        to a <tref title="number">JSON numbers</tref> and <tref title="RDF literal">RDF literals</tref>
        with a <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
        that equals <code>xsd:boolean</code> are converted to <tref>true</tref> or
        <tref>false</tref> based on their
        <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</tref>
        as described in
        <a class="sectionRef" href="#data-round-tripping">Data Round Tripping</a>.</p>
    </section>

    <section>
      <h3>Algorithm</h3>

      <p>This algorithm takes two required inputs: a <i>value</i> to be converted
        to a <tref>JSON object</tref> and a flag <i>use native types</i>.</p>

      <ol class="algorithm">
        <li>If <i>value</i> is an <tref>IRI</tref> or a
          <tref>blank node identifier</tref>, return a new <tref>JSON object</tref>
          consisting of a single member <code>@id</code> whose value is set to
          <i>value</i>.</li>
        <li>Otherwise <i>value</i> is an
          <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">RDF literal</tref>:
          <ol class="algorithm">
            <li>Initialize a new empty <tref>JSON object</tref> result.</li>
            <li>Initialize <i>converted value</i> to <i>value</i>.</li>
            <li>Initialize <i>type</i> to <tref>null</tref></li>
            <li>If <i>use native types</i> is <tref>true</tref>
              <ol class="algorithm">
                <li>If the
                  <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
                  of <i>value</i> equals <code>xsd:string</code>, set
                  <i>converted value</i> to the
                  <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</tref>
                  of <i>value</i>.</li>
                <li>Otherwise, if the
                  <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
                  of <i>value</i> equals <code>xsd:boolean</code>, set
                  <i>converted value</i> to <tref>true</tref> if the
                  <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</tref>
                  of <i>value</i> matches <code>true</code>, or <tref>false</tref>
                  if it matches <code>false</code>. If it matches neither,
                  set <i>type</i> to <code>xsd:boolean</code>.</li>
                <li>Otherwise, if the
                  <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
                  of <i>value</i> equals <code>xsd:integer</code> or
                  <code>xsd:double</code> and its
                  <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</tref>
                  is a valid <code>xsd:integer</code> or <code>xsd:double</code>
                  according [[!XMLSCHEMA11-2]], set <i>converted value</i>
                  to the result of converting the
                  <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-lexical-form">lexical form</tref>
                  to a JSON <tref>number</tref>.</li>
              </ol>
            </li>
            <li>Otherwise, if <i>value</i> is a
              <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-string">language-tagged string</tref>
              add a member <code>@language</code> to <i>result</i> and set its value to the
              <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tag">language tag</tref>
              of <i>value</i>.</li>
            <li>Otherwise, set <i>type</i> to the
              <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
              of <i>value</i>, unless it equals <code>xsd:string</code> which is ignored.</li>
            <li>Add a member <code>@value</code> to <i>result</i> whose value
              is set to <i>converted value</i>.</li>
            <li>If <i>type</i> is not <tref>null</tref>, add a member <code>@type</code>
              to <i>result</i> whose value is set to <i>type</i>.</li>
            <li>Return <i>result</i>.</li>
          </ol>
        </li>
      </ol>
    </section>
  </section>

  <section>
    <h2>Data Round Tripping</h2>

    <p>When <a href="#deserialize-json-ld-to-rdf-algorithm">deserializing JSON-LD to RDF</a>
      JSON-native <tref title="number">numbers</tref> are automatically
      type-coerced to <code>xsd:integer</code> or <code>xsd:double</code>
      depending on whether the <tref>number</tref> has a non-zero fractional part
      or not (the result of a modulo&#8209;1 operation), the boolean values
      <tref>true</tref> and <tref>false</tref> are coerced to <code>xsd:boolean</code>,
      and <tref title="string">strings</tref> are coerced to <code>xsd:string</code>.
      The numeric or boolean values themselves are converted to
      <tdef>canonical lexical form</tdef>, i.e., a deterministic string
      representation as defined in [[!XMLSCHEMA11-2]].</p>

    <p>The <tref>canonical lexical form</tref> of an <em>integer</em>, i.e., a
      <tref>number</tref> with no non-zero fractional part or a <tref>number</tref>
      coerced to <code>xsd:integer</code>, is a finite-length sequence of decimal
      digits (<code>0-9</code>) with an optional leading minus sign; leading
      zeros are prohibited. In JavaScript, implementers can use the following
      snippet of code to convert an integer to
      <tref>canonical lexical form</tref>:</p>

    <pre class="example" data-transform="updateExample"
         title="Sample integer serialization implementation in JavaScript">
    <!--
    (value).toFixed(0).toString()
    -->
    </pre>

    <p>The <tref>canonical lexical form</tref> of a <em>double</em>, i.e., a
      <tref>number</tref> with a non-zero fractional part or a <tref>number</tref>
      coerced to <code>xsd:double</code>, consists of a mantissa followed by the
      character <code>E</code>, followed by an exponent. The mantissa is a
      decimal number and the exponent is an integer. Leading zeros and a
      preceding plus sign (<code>+</code>) are prohibited in the exponent.
      If the exponent is zero, it is indicated by <code>E0</code>. For the
      mantissa, the preceding optional plus sign is prohibited and the
      decimal point is required. Leading and trailing zeros are prohibited
      subject to the following: number representations must be normalized
      such that there is a single digit which is non-zero to the left of
      the decimal point and at least a single digit to the right of the
      decimal point unless the value being represented is zero. The
      canonical representation for zero is <code>0.0E0</code>.
      <code>xsd:double</code>'s value space is defined by the IEEE
      double-precision 64-bit floating point type [[!IEEE-754-1985]] whereas
      the value space of JSON <tref title="number">numbers</tref> is not
      specified; when deserializing JSON-LD to RDF the mantissa is rounded to
      15&nbsp;digits after the decimal point. In JavaScript, implementers
      can use the following snippet of code to convert a double to
      <tref>canonical lexical form</tref>:</p>

    <pre class="example" data-transform="updateExample"
         title="Sample floating point number serialization implementation in JavaScript">
    <!--
    (value).toExponential(15).replace(/(\d)0*e\+?/,'$1E')
    -->
    </pre>

    <p>The <tref>canonical lexical form</tref> of the <em>boolean</em>
      values <tref>true</tref> and <tref>false</tref> are the strings
      <code>true</code> and <code>false</code>.</p>

    <p>When JSON-native <tref title="number">numbers</tref> are deserialized
      to RDF, lossless data round-tripping cannot be guaranteed, as rounding
      errors might occur. When
      <a href="#serialize-rdf-as-json-ld-algorithm">serializing RDF as JSON-LD</a>,
      similar rounding errors might occur. Furthermore, the datatype or the lexical
      representation might be lost. An <code>xsd:double</code> with a value
      of <code>2.0</code> will, e.g., result in an <code>xsd:integer</code>
      with a value of <code>2</code> in <tref>canonical lexical form</tref>
      when converted from RDF to JSON-LD and back to RDF. It is important
      to highlight that in practice it might be impossible to losslessly
      convert an <code>xsd:integer</code> to a <tref>number</tref> because
      its value space is not limited. While the JSON specification [[RFC4627]]
      does not limit the value space of <tref title="number">numbers</tref>
      either, concrete implementations typically do have a limited value
      space.</p>

    <p>To ensure lossless round-tripping the
      <a href="#serialize-rdf-as-json-ld-algorithm">Serialize RDF as JSON-LD algorithm</a>
      specifies a <i>use native types</i> flag which controls whether
      <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">RDF literals</tref>
      with a <tref href="http://www.w3.org/TR/rdf11-concepts/#dfn-datatype-iri">datatype IRI</tref>
      equal to <code>xsd:integer</code>, <code>xsd:double</code>, or
      <code>xsd:boolean</code> are converted to their JSON-native
      counterparts. If the <i>use native types</i> flag is set to
      <tref>false</tref>, all literals remain in their original string
      representation.</p>

    <p>Some JSON serializers, such as PHP's native implementation in some versions,
      backslash-escape the forward slash character. For example, the value
      <code>http://example.com/</code> would be serialized as <code>http:\/\/example.com\/</code>.
      This is problematic as other JSON parsers might not understand those escaping characters.
      There is no need to backslash-escape forward slashes in JSON-LD. To aid
      interoperability between JSON-LD processors, forward slashes MUST NOT be
      backslash-escaped.</p>
  </section> <!-- end of Data Round Tripping -->
</section>


<section>
  <h2>The Application Programming Interface</h2>

  <p>This API provides a clean mechanism that enables developers to convert
    JSON-LD data into a variety of output formats that are often easier to
    work with. A conformant <tref>JSON-LD API Implementation</tref> MUST
    implement the entirety of the following API.</p>

  <p>The JSON-LD API uses <tref title="Promise">Promises</tref> to represent
    the result of the various asynchronous operations.
    <tdef title="Promise">Promises</tdef> are defined in
    <cite><a href="http://dom.spec.whatwg.org/#promises">section&nbsp;4 Promises</a></cite>
    of [[!DOM-WHATWG]].</p>

    <div class="issue atrisk" id="at-risk-8" data-number="8" title="Properly referencing the DOM Promises spec">
      <p class="atrisk-head">Note: This feature is
        <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a> and may
        be removed or modified heavily from the feature described in this specification
        based on reviewer feedback. Please send feedback to
        <a href="mailto:public-rdf-comments@w3.org">public-rdf-comments@w3.org</a>.
        For the current status see
        <a href="http://www.w3.org/2011/rdf-wg/wiki/JSON-LD_Features_at_Risk">features "at risk" in JSON-LD 1.0</a></p>
      <p>The JSON-LD API specification currently only refers to the "Promise" interface and does not attempt to provide any details on the specific implementation of Promises. That is, it does not reference whether or not '.then()' must be specified. This is done in order to allow for some implementation flexibility in the event the DOM Promises spec changes. The editors of the WHATWG DOM specification have asserted that the Promise interface is ready to be incorporated into specifications. The issue relates to how to properly refer to a spec living in the WHATWG as a living standard as well as how to ensure that the interface provided by the spec is stable.</p>
    </div>

  <section>
    <h3>The <a>JsonLdProcessor</a> Interface</h3>

    <p>The <a>JsonLdProcessor</a> interface is the high-level programming structure
      that developers use to access the JSON-LD transformation methods.</p>

    <p>It is important to highlight that conformant
      <tref title="JSON-LD API Implementation">JSON-LD API Implementations</tref>
      MUST NOT modify the input parameters. If an error is detected, the Promise is
      rejected passing a <a>JsonLdError</a> with the corresponding error
      <code class="idlMemberName"><a href="#widl-JsonLdError-code">code</a></code>
      and processing is stopped.</p>

    <p>If the <code class="idlMemberName"><a href="#widl-JsonLdOptions-documentLoader">documentLoader</a></code>
      option is specified, a conformant <tref>JSON-LD Processor</tref> MUST use it to dereference remote documents
      and contexts. The <code class="idlMemberName"><a href="#widl-RemoteDocument-documentUrl">documentUrl</a></code>
      in the returned <code class="idlMemberName"><a href="#idl-def-RemoteDocument">RemoteDocument</a></code>
      is used as <tref>base IRI</tref> and the
      <code class="idlMemberName"><a href="#widl-RemoteDocument-contextUrl">contextUrl</a></code>
      is used instead of looking at the HTTP Link Header directly. For the sake of simplicity, none of the algorithms
      in this document mention this directly. <tref title="JSON-LD API Implementation">JSON-LD API Implementations</tref>
      are not required to implement the
      <code class="idlMemberName"><a href="#widl-JsonLdOptions-documentLoader">documentLoader</a></code> option.</p>

    <dl title="[Constructor] interface JsonLdProcessor" class="idl">
      <dt>Promise compact()</dt>
      <dd>
        <p><a href="#compaction">Compacts</a> the given <i>input</i> using the
          <i>context</i> according to the steps in the
          <a href="#compaction-algorithm">Compaction algorithm</a>:</p>

        <ol class="algorithm">
          <li>Create a new <tref>Promise</tref> <i>promise</i> and return it. The
            following steps are then executed asynchronously.</li>
          <li>If the passed <i>input</i> is a <span class="idlParamType">DOMString</span>
            representing the <tref>IRI</tref> of a remote document, dereference it.
            If the retrieved document's content type is neither <code>application/json</code>,
            nor <code>application/ld+json</code>, nor any other media type using a
            <code>+json</code> suffix as defined in [[RFC6839]]
            or if the document cannot be parsed as JSON, reject the <i>promise</i> passing an
            <code class="error"><a href="#idl-def-JsonLdErrorCode.loading-document-failed">loading document failed</a></code>
            error.</li>
          <li>Initialize a new empty <tref>active context</tref>. The <tref>base IRI</tref>
            of the <tref>active context</tref> is set to the IRI of the currently being processed
            document, if available; otherwise to <tref>null</tref>. If set, the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-base">base</a></code> option
            overrides the <tref>base IRI</tref>.</li>
          <li>If an
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            has been passed, update the <tref>active context</tref> using the
            <a href="#context-processing-algorithm">Context Processing algorithm</a>, passing the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            as <tref>local context</tref>. If
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            is a <tref>JSON object</tref> having a <code>@context</code> member, pass that member's value instead.</li>
          <li>If the <i>input</i> has been retrieved, the response has an HTTP Link Header [[!RFC5988]]
            using the <code>http://www.w3.org/ns/json-ld#context</code> link relation
            and a content type of <code>application/json</code> or any media type
            with a <code>+json</code> suffix as defined in [[RFC6839]] except
            <code>application/ld+json</code>, update the <tref>active context</tref> using the
            <a href="#context-processing-algorithm">Context Processing algorithm</a>, passing the
            context referenced in the HTTP Link Header as <tref>local context</tref>. The
            HTTP Link Header is ignored for documents served as <code>application/ld+json</code> If
            multiple HTTP Link Headers using the <code>http://www.w3.org/ns/json-ld#context</code>
            link relation are found, the <i>promise</i> is rejected with a <a>JsonLdError</a> whose code is set to
            <code class="error"><a href="#idl-def-JsonLdErrorCode.multiple-context-link-headers">multiple context link headers</a></code>
            and processing is terminated.</li>
          <li>Set <i>expanded</i> to the result of using the
            <a href="#expansion-algorithm">Expansion algorithm</a>, passing the
            <tref>active context</tref> and <i>input</i> as <i>element</i>.</li>
          <li>If <i>context</i> is a <tref>JSON object</tref> having a <code>@context</code> member, set
            <i>context</i> to that member's value.</li>
          <li>Set <i>compacted</i> to the result of using the
            <a href="#compaction-algorithm">Compaction algorithm</a>, passing
            <i>context</i>, <i>expanded</i> as <i>element</i>, and if passed, the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-compactArrays">compactArrays</a></code>
            flag in <i>options</i>.</li>
          <li>Fulfill the <i>promise</i> passing <i>compacted</i>.</li>
        </ol>

        <dl class="parameters">
          <dt>any input</dt>
           <dd>The JSON-LD object or array of JSON-LD objects to perform the compaction upon or an
            <tref>IRI</tref> referencing the JSON-LD document to compact.</dd>
          <dt>JsonLdContext context</dt>
          <dd>The context to use when compacting the <code>input</code>;
            it can be specified by using a <tref>JSON object</tref>, an
            <tref>IRI</tref>, or an array consisting of
            <tref>JSON object</tref>s and <tref>IRI</tref>s.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options to configure the algorithms. This allows, e.g.,
            to set the input document's base <tref>IRI</tref>.</dd>
        </dl>
      </dd>

      <dt>Promise expand()</dt>
      <dd>
        <p><a href="#expansion">Expands</a> the given <i>input</i> according to
          the steps in the <a href="#expansion-algorithm">Expansion algorithm</a>:</p>

        <ol class="algorithm">
          <li>Create a new <tref>Promise</tref> <i>promise</i> and return it. The
            following steps are then executed asynchronously.</li>
          <li>If the passed <i>input</i> is a <span class="idlParamType">DOMString</span>
            representing the <tref>IRI</tref> of a remote document, dereference it.
            If the retrieved document's content type is neither <code>application/json</code>,
            nor <code>application/ld+json</code>, nor any other media type using a
            <code>+json</code> suffix as defined in [[RFC6839]], reject the <i>promise</i> passing an
            <code class="error"><a href="#idl-def-JsonLdErrorCode.loading-document-failed">loading document failed</a></code>
            error.</li>
          <li>Initialize a new empty <tref>active context</tref>. The <tref>base IRI</tref>
            of the <tref>active context</tref> is set to the IRI of the currently being processed
            document, if available; otherwise to <tref>null</tref>. If set, the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-base">base</a></code> option
            overrides the <tref>base IRI</tref>.</li>
          <li>If an
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            has been passed, update the <tref>active context</tref> using the
            <a href="#context-processing-algorithm">Context Processing algorithm</a>, passing the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            as <tref>local context</tref>. If
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            is a <tref>JSON object</tref> having a <code>@context</code> member, pass that member's value instead.</li>
          <li>If the <i>input</i> has been retrieved, the response has an HTTP Link Header [[!RFC5988]]
            using the <code>http://www.w3.org/ns/json-ld#context</code> link relation
            and a content type of <code>application/json</code> or any media type
            with a <code>+json</code> suffix as defined in [[RFC6839]] except
            <code>application/ld+json</code>, update the <tref>active context</tref> using the
            <a href="#context-processing-algorithm">Context Processing algorithm</a>, passing the
            context referenced in the HTTP Link Header as <tref>local context</tref>. The
            HTTP Link Header is ignored for documents served as <code>application/ld+json</code> If
            multiple HTTP Link Headers using the <code>http://www.w3.org/ns/json-ld#context</code>
            link relation are found, the <i>promise</i> is rejected with a <a>JsonLdError</a> whose code is set to
            <code class="error"><a href="#idl-def-JsonLdErrorCode.multiple-context-link-headers">multiple context link headers</a></code>
            and processing is terminated.</li>
          <li>Set <i>expanded</i> to the result of using the
            <a href="#expansion-algorithm">Expansion algorithm</a>, passing the
            <tref>active context</tref> and <i>input</i> as <i>element</i>.</li>
          <li>Fulfill the <i>promise</i> passing <i>expanded</i>.</li>
        </ol>

        <dl class="parameters">
          <dt>any input</dt>
          <dd>The JSON-LD object or array of JSON-LD objects to perform the expansion upon or an
            <tref>IRI</tref> referencing the JSON-LD document to expand.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options to configure the used algorithms such. This allows, e.g.,
            to set the input document's base <tref>IRI</tref>.</dd>
        </dl>
      </dd>

      <dt>Promise flatten()</dt>
      <dd>
        <p><a href="#flattening">Flattens</a> the given <i>input</i> and
          <a href="#compaction">compacts</a> it using the passed <i>context</i>
          according to the steps in the <a href="#flattening-algorithm">Flattening algorithm</a>:</p>

        <ol class="algorithm">
          <li>Create a new <tref>Promise</tref> <i>promise</i> and return it. The
            following steps are then executed asynchronously.</li>
          <li>If the passed <i>input</i> is a <span class="idlParamType">DOMString</span>
            representing the <tref>IRI</tref> of a remote document, dereference it.
            If the retrieved document's content type is neither <code>application/json</code>,
            nor <code>application/ld+json</code>, nor any other media type using a
            <code>+json</code> suffix as defined in [[RFC6839]], reject the <i>promise</i> passing an
            <code class="error"><a href="#idl-def-JsonLdErrorCode.loading-document-failed">loading document failed</a></code>
            error.</li>
          <li>Initialize a new empty <tref>active context</tref>. The <tref>base IRI</tref>
            of the <tref>active context</tref> is set to the IRI of the currently being processed
            document, if available; otherwise to <tref>null</tref>. If set, the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-base">base</a></code> option
            overrides the <tref>base IRI</tref>.</li>
          <li>If an
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            has been passed, update the <tref>active context</tref> using the
            <a href="#context-processing-algorithm">Context Processing algorithm</a>, passing the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            as <tref>local context</tref>. If
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-expandContext">expandContext</a></code>
            is a <tref>JSON object</tref> having a <code>@context</code> member, pass that member's value instead.</li>
          <li>If the <i>input</i> has been retrieved, the response has an HTTP Link Header [[!RFC5988]]
            using the <code>http://www.w3.org/ns/json-ld#context</code> link relation
            and a content type of <code>application/json</code> or any media type
            with a <code>+json</code> suffix as defined in [[RFC6839]] except
            <code>application/ld+json</code>, update the <tref>active context</tref> using the
            <a href="#context-processing-algorithm">Context Processing algorithm</a>, passing the
            context referenced in the HTTP Link Header as <tref>local context</tref>. The
            HTTP Link Header is ignored for documents served as <code>application/ld+json</code> If
            multiple HTTP Link Headers using the <code>http://www.w3.org/ns/json-ld#context</code>
            link relation are found, the <i>promise</i> is rejected with a <a>JsonLdError</a> whose code is set to
            <code class="error"><a href="#idl-def-JsonLdErrorCode.multiple-context-link-headers">multiple context link headers</a></code>
            and processing is terminated.</li>
          <li>Set <i>expanded</i> to the result of using the
            <a href="#expansion-algorithm">Expansion algorithm</a>, passing the
            <tref>active context</tref> and <i>input</i> as <i>element</i>.</li>
          <li>If <i>context</i> is a <tref>JSON object</tref> having a <code>@context</code> member, set
            <i>context</i> to that member's value.</li>
          <li>Initialize an empty <i>identifier map</i> and a <i>counter</i> (set to <code>0</code>)
            to be used by the
            <a href="#generate-blank-node-identifier">Generate Blank Node Identifier algorithm</a>.</li>
          <li>Set <i>flattened</i> to the result of using the
            <a href="#flattening-algorithm">Flattening algorithm</a>, passing
            <i>expanded</i> as <i>element</i>, <i>context</i>, and if passed, the
            <code class="idlMemberName"><a href="#widl-JsonLdOptions-compactArrays">compactArrays</a></code>
            flag in <i>options</i> (which is internally passed to the
            <a href="#compaction-algorithm">Compaction algorithm</a>).</li>
          <li>Fulfill the <i>promise</i> passing <i>flattened</i>.</li>
        </ol>

        <dl class="parameters">
          <dt>any input</dt>
           <dd>The JSON-LD object or array of JSON-LD objects or an <tref>IRI</tref>
            referencing the JSON-LD document to flatten.</dd>
          <dt>optional JsonLdContext? context</dt>
          <dd>The context to use when compacting the flattened <code>input</code>;
            it can be specified by using a <tref>JSON object</tref>, an
            <tref>IRI</tref>, or an array consisting of <tref>JSON object</tref>s
            and <tref>IRI</tref>s. If not
            passed or <tref>null</tref> is passed, the result will not be compacted
            but kept in expanded form.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options to configure the used algorithms such. This allows, e.g.,
            to set the input document's base <tref>IRI</tref>.</dd>
        </dl>
      </dd>
    </dl>

    <div class='idl' title='typedef (object or DOMString or (object or DOMString)[]) JsonLdContext'>
      <p>The <a>JsonLdContext</a> type is used to refer to a value that
        that may be a <tref>JSON object</tref>, a <tref>string</tref> representing an
        <tref>IRI</tref>, or an array of <tref title="JSON object">JSON objects</tref>
        and <tref title="string">strings</tref>.</p>
    </div>
  </section> <!-- end of JsonLdProcessor -->

  <section>
    <h3>The <a>JsonLdOptions</a> Type</h3>

    <p>The <a>JsonLdOptions</a> type is used to pass various options to the
      <a>JsonLdProcessor</a> methods.</p>

    <dl title="dictionary JsonLdOptions" class="idl">
      <dt>DOMString? base</dt>
      <dd>The base IRI to use when expanding or compacting the document. If set, this overrides
        the input document's IRI.</dd>
      <dt>boolean compactArrays = true</dt>
      <dd>If set to <code>true</code>, the JSON-LD processor replaces arrays with just
        one element with that element during compaction. If set to <code>false</code>,
        all arrays will remain arrays even if they have just one element.
      </dd>
      <dt>LoadDocumentCallback documentLoader = null</dt>
      <dd>The callback of the loader to be used to retrieve remote documents and contexts.
        If specified, it MUST be used to retrieve remote documents and contexts; otherwise,
        if not specified, the processor's built-in loader MUST be used.</dd>
      <dt>(object? or DOMString) expandContext = null</dt>
      <dd>A context that is used to initialize the active context when expanding a document.</dd>
      <dt>DOMString processingMode = "json-ld-1.0"</dt>
      <dd>If set to <code>json-ld-1.0</code>, the JSON-LD processor MUST produce
        exactly the same results as the algorithms defined in this specification.
        If set to another value, the JSON-LD processor is allowed to extend
        or modify the algorithms defined in this specification to enable
        application-specific optimizations. The definition of such
        optimizations is beyond the scope of this specification and thus
        not defined. Consequently, different implementations MAY implement
        different optimizations. Developers MUST NOT define modes beginning
        with <code>json-ld</code> as they are reserved for future versions
        of this specification.</dd>
    </dl>
  </section> <!-- end JsonLdOptions -->

  <section>
    <h3>Remote Document and Context Retrieval</h3>

    <p>Developers can utilize a callback to control how remote documents and contexts are retrieved
      by <tref title="JSON-LD API Implementation">JSON-LD API Implementations</tref>.
      This section details the parameters of that callback and the data structure
      used to return the retrieved context.</p>

    <section>
      <h3>LoadDocumentCallback</h3>

      <p>The <a>LoadDocumentCallback</a> defines a callback that custom document loaders
        have to implement to be used to retrieve remote documents and contexts.</p>

      <dl title="callback LoadDocumentCallback = Promise" class="idl">
        <dt>DOMString url</dt>
        <dd>The URL of the remote document or context to load.</dd>
      </dl>

      <p>All errors MUST result in the <tref>Promise</tref> being rejected with
        a <a>JsonLdError</a> whose code is set to
        <code class="error"><a href="#idl-def-JsonLdErrorCode.loading-document-failed">loading document failed</a></code>
        or <code class="error"><a href="#idl-def-JsonLdErrorCode.multiple-context-link-headers">multiple context link headers</a></code>
        as described in the next section.</p>
    </section>

    <section>
      <h3>RemoteDocument</h3>

      <p>The <a>RemoteDocument</a> type is used by a <a>LoadDocumentCallback</a>
        to return information about a remote document or context.</p>

      <dl title="dictionary RemoteDocument" class="idl">
        <dt>DOMString contextUrl = null</dt>
        <dd>If available, the value of the HTTP Link Header [[!RFC5988]] using the
          <code>http://www.w3.org/ns/json-ld#context</code> link relation in the
          response. If the response's content type is <code>application/ld+json</code>,
          the HTTP Link Header MUST be ignored. If multiple HTTP Link Headers using
          the <code>http://www.w3.org/ns/json-ld#context</code> link relation are found,
          the <tref>Promise</tref> of the <a>LoadDocumentCallback</a> MUST be rejected with
          a <a>JsonLdError</a> whose code is set to
          <code class="error"><a href="#idl-def-JsonLdErrorCode.multiple-context-link-headers">multiple context link headers</a></code>.</dd>
        <dt>DOMString documentUrl</dt>
        <dd>The final URL of the loaded document. This is important
          to handle HTTP redirects properly.</dd>
        <dt>any document</dt>
        <dd>The retrieved document. This can either be the raw payload or the already
          parsed document.</dd>
      </dl>
    </section>
  </section> <!-- end of Remote Document and Context Retrieval -->

  <section>
    <h3>Error Handling</h3>

    <p>This section describes the datatype definitions used within the
      JSON-LD API for error handling.</p>

    <section>
      <h4>JsonLdError</h4>

      <p>The <a>JsonLdError</a> type is used to report processing errors.</p>

      <dl title="dictionary JsonLdError" class="idl">
        <dt>JsonLdErrorCode code</dt>
        <dd>a string representing the particular error type, as described in
          the various algorithms in this document.</dd>
        <dt>DOMString? message = null</dt>
        <dd>an optional error message containing additional debugging information.
          The specific contents of error messages are outside the scope of this
          specification.</dd>
      </dl>
    </section>

    <section>
      <h4>JsonLdErrorCode</h4>
      <p>The <a>JsonLdErrorCode</a> represents the collection of valid JSON-LD error
        codes.</p>

      <div class="issue atrisk" id="at-risk-4" data-number="4" title="Lists of lists and partial list conversion from RDF">
        <p class="atrisk-head">Note: This feature is
          <a href="http://www.w3.org/2005/10/Process-20051014/tr#cfi">"at risk"</a> and may
          be removed from this specification based on feedback. Please send feedback to
          <a href="mailto:public-rdf-comments@w3.org">public-rdf-comments@w3.org</a>.
          For the current status see
          <a href="http://www.w3.org/2011/rdf-wg/wiki/JSON-LD_Features_at_Risk">features "at risk" in JSON-LD 1.0</a></p>
       <p>The JSON-LD algorithms have been updated to support conversion of lists
          of lists to <tref title="list object">list objects</tref> by preserving
          the blank node head of the inner list. Lists of lists can, however, not be
          represented directly in JSON-LD using the <code>@list</code> construct;
          they have to be represented as a set of interlinked node objects using
          RDF's rdf:first and rdf:rest properties. Implementors are asked to pay
          particular attention to the feature and provide feedback on lists of lists
          and partial lists. The feature may remain in the specification, or it may
          be removed after further implementation experience has been gathered.
          Similarly, partial list conversion in the RDF algorithms have been marked
          as a feature at risk and may be removed from the specification based
          on implementation feedback.</p>
      </div>

      <dl title="enum JsonLdErrorCode" class="idl">
        <dt>loading document failed</dt>
        <dd>The document could not be loaded or parsed as JSON.</dd>
        <dt>list of lists</dt>
        <dd>A list of lists was detected. List of lists are not supported in
          this version of JSON-LD due to the algorithmic complexity.</dd>
        <dt>invalid @index value</dt>
        <dd>An <code>@index</code> member was encountered whose value was
          not a <tref>string</tref>.</dd>
        <dt>conflicting indexes</dt>
        <dd>Multiple conflicting indexes have been found for the same node.</dd>
        <dt>invalid @id value</dt>
        <dd>An <code>@id</code> member was encountered whose value was not a
          <tref>string</tref>.</dd>
        <dt>invalid local context</dt>
        <dd>In invalid <tref>local context</tref> was detected.</dd>
        <dt>multiple context link headers</dt>
        <dd>Multiple HTTP Link Headers [[!RFC5988]] using the
          <code>http://www.w3.org/ns/json-ld#context</code> link relation
          have been detected.</dd>
        <dt>loading remote context failed</dt>
        <dd>There was a problem encountered loading a remote context.</dd>
        <dt>invalid remote context</dt>
        <dd>No valid context document has been found for a referenced,
         remote context.</dd>
        <dt>recursive context inclusion</dt>
        <dd>A cycle in remote context inclusions has been detected.</dd>
        <dt>invalid base IRI</dt>
        <dd>An invalid <tref>base IRI</tref> has been detected, i.e., it is
          neither an <tref>absolute IRI</tref> nor <tref>null</tref>.</dd>
        <dt>invalid vocab mapping</dt>
        <dd>An invalid <tref>vocabulary mapping</tref> has been detected, i.e.,
          it is neither an <tref>absolute IRI</tref> nor <tref>null</tref>.</dd>
        <dt>invalid default language</dt>
        <dd>The value of the <tref>default language</tref> is not a <tref>string</tref>
          or <tref>null</tref> and thus invalid.</dd>
        <dt>keyword redefinition</dt>
        <dd>A <tref>keyword</tref> redefinition has been detected.</dd>
        <dt>invalid term definition</dt>
        <dd>An invalid <tref>term definition</tref> has been detected.</dd>
        <dt>invalid reverse property</dt>
        <dd>An invalid reverse property definition has been detected.</dd>
        <dt>invalid IRI mapping</dt>
        <dd>A <tref>local context</tref> contains a <tref>term</tref> that has
          an invalid or missing <tref>IRI mapping</tref>.</dd>
        <dt>cyclic IRI mapping</dt>
        <dd>A cycle in <tref title="IRI mapping">IRI mappings</tref> has been detected.</dd>
        <dt>invalid keyword alias</dt>
        <dd>An invalid <tref>keyword</tref> alias definition has been
          encountered.</dd>
        <dt>invalid type mapping</dt>
        <dd>An <code>@type</code> member in a <tref>term definition</tref>
          was encountered whose value could not be expanded to an
          <tref>absolute IRI</tref>.</dd>
        <dt>invalid language mapping</dt>
        <dd>An <code>@language</code> member in a <tref>term definition</tref>
          was encountered whose value was neither a <tref>string</tref> nor
          <tref>null</tref> and thus invalid.</dd>
        <dt>colliding keywords</dt>
        <dd>Two properties which expand to the same keyword have been detected.
          This might occur if a <tref>keyword</tref> and an alias thereof
          are used at the same time.</dd>
        <dt>invalid container mapping</dt>
        <dd>An <code>@container</code> member was encountered whose value was
          not one of the following <tref title="string">strings</tref>:
          <code>@list</code>, <code>@set</code>, or <code>@index</code>.</dd>
        <dt>invalid type value</dt>
        <dd>An invalid value for an <code>@type</code> member has been detected,
          i.e., the value was neither a <tref>string</tref> nor an <tref>array</tref>
          of <tref title="string">strings</tref>.</dd>
        <dt>invalid value object</dt>
        <dd>A <tref>value object</tref> with disallowed members has been
          detected.</dd>
        <dt>invalid value object value</dt>
        <dd>An invalid value for the <code>@value</code> member of a
          <tref>value object</tref> has been detected, i.e., it is neither
          a <tref>scalar</tref> nor <tref>null</tref>.</dd>
        <dt>invalid language-tagged string</dt>
        <dd>A <tref>language-tagged string</tref> with an invalid language
          value was detected.</dd>
        <dt>invalid language-tagged value</dt>
        <dd>A <tref>number</tref>, <tref>true</tref>, or <tref>false</tref> with an
          associated language tag was detected.</dd>
        <dt>invalid typed value</dt>
        <dd>A <tref>typed value</tref> with an invalid type was detected.</dd>
        <dt>invalid set or list object</dt>
        <dd>A <tref>set object</tref> or <tref>list object</tref> with
          disallowed members has been detected.</dd>
        <dt>invalid language map value</dt>
        <dd>An invalid value in a <tref href="../json-ld/#dfn-language-map">language map</tref>
          has been detected. It has to be a <tref>string</tref> or an <tref>array</tref> of
          <tref title="string">strings</tref>.</dd>
        <dt>compaction to list of lists</dt>
        <dd>The compacted document contains a list of lists as multiple
          lists have been compacted to the same term.</dd>
        <dt>invalid reverse property map</dt>
        <dd>An invalid reverse property map has been detected. No
          <tref title="keyword">keywords</tref> apart from <code>@context</code>
          are allowed in reverse property maps.</dd>
        <dt>invalid @reverse value</dt>
        <dd>An invalid value for an <code>@reverse</code> member has been detected,
          i.e., the value was not a <tref>JSON object</tref>.</dd>
        <dt>invalid reverse property value</dt>
        <dd>An invalid value for a reverse property has been detected. The value of an inverse
          property must be a <tref>node object</tref>.</dd>
      </dl>
    </section>
  </section> <!-- end of Error Handling -->
</section> <!-- end of The Application Programming Interfaces -->

<section class="appendix informative">
  <h2>Acknowledgements</h2>

  <p>A large amount of thanks goes out to the JSON-LD Community Group
    participants who worked through many of the technical issues on the mailing
    list and the weekly telecons - of special mention are Niklas Lindström,
    François Daoust, Lin Clark, and Zdenko 'Denny' Vrandečić.
    The editors would like to thank Mark Birbeck, who provided a great deal of
    the initial push behind the JSON-LD work via his work on RDFj.
    The work of Dave Lehn and Mike Johnson are appreciated for reviewing,
    and performing several implementations of the specification. Ian Davis is
    thanked for his work on RDF/JSON. Thanks also to Nathan Rixham,
    Bradley P. Allen, Kingsley Idehen, Glenn McDonald, Alexandre Passant,
    Danny Ayers, Ted Thibodeau Jr., Olivier Grisel, Josh Mandel, Eric Prud'hommeaux,
    David Wood, Guus Schreiber, Pat Hayes, Sandro Hawke, and Richard Cyganiak
    for their input on the specification.</p>
</section>

</body>
</html>
