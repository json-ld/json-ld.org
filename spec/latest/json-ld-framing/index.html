<!DOCTYPE html>
<html>
<head>
<title>JSON-LD Framing 1.0</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<!--
  === NOTA BENE ===
  For the three scripts below, if your spec resides on dev.w3 you can check them
  out in the same tree and use relative links so that they'll work offline,
  -->
<script type="text/javascript" src="../respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
    var preProc = {
          apply:  function(c) {
                    // extend the bibliography entries
                    berjon.biblio["MICRODATA"] = "<cite><a href=\"http://www.w3.org/TR/2012/WD-microdata-20120329/\">HTML Microdata</a></cite> Ian Hickson Editor. World Wide Web Consortium (work in progress). 29 March 2012. This edition of the HTML Microdata specification is http://www.w3.org/TR/2012/WD-microdata-20120329/. The <a href=\"http://www.w3.org/TR/microdata/\">latest edition of HTML Microdata</a> is available at http://www.w3.org/TR/microdata/";
                    berjon.biblio["JSON-LD"] = "<cite><a href=\"http://json-ld.org/spec/ED/json-ld-syntax/20120522/\">The JSON-LD Syntax</a></cite> Manu Sporny, Gregg Kellogg, Markus Lanthaler Editors. World Wide Web Consortium (work in progress). 22 May 2012. Editor's Draft. This edition of the JSON-LD Syntax specification is http://json-ld.org/spec/ED/json-ld-syntax/20120522/. The <a href=\"http://json-ld.org/spec/latest/json-ld-syntax/\">latest edition of the JSON-LD Syntax</a> is available at http://json-ld.org/spec/latest/json-ld-syntax/";
                    berjon.biblio["JSON-LD-API"] = "<cite><a href=\"http://json-ld.org/spec/ED/json-ld-api/20120524/\">The JSON-LD API 1.0</a></cite> Manu Sporny, Gregg Kellogg, Dave Longley, Markus Lanthaler, Editors. World Wide Web Consortium (work in progress). 24 May 2012. Editor's Draft. This edition of the JSON-LD Syntax specification is http://json-ld.org/spec/ED/json-ld-api/20120524/. The <a href=\"http://json-ld.org/spec/latest/json-ld-api/\">latest edition of the JSON-LD Syntax</a> is available at http://json-ld.org/spec/latest/json-ld-api/";
                    berjon.biblio["JSON-POINTER"] = "<cite><a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-02\">JSON Pointer</a></cite> P. Bryan, Ed. IETF Draft. URL: <a href=\"http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-02\">http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-02</a>";
                    berjon.biblio["RDF-NORMALIZATION"] = "<cite><a href=\"http://json-ld.org/spec/ED/rdf-graph-normalization/20111016/\">RDF Graph Normalization</a></cite> Manu Sporny, Dave Longley Editors. World Wide Web Consortium (work in progress). 16 October 2011. Editor's Draft. This edition of the RDF Graph Normalization specification is http://json-ld.org/spec/ED/rdf-graph-normalization/20111016/. The <a href=\"http://json-ld.org/spec/latest/rdf-graph-normalization/\">latest edition of RDF Graph Normalization</a> is available at http://json-ld.org/spec/latest/rdf-graph-normalization/";
                    berjon.biblio["IEEE-754-1985"] = "IEEE. <cite>IEEE Standard for Binary Floating-Point Arithmetic.</cite> See <a href=\"http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html\">http://standards.ieee.org/reading/ieee/std_public/description/busarch/754-1985_desc.html</a>";
                    berjon.biblio["RDF-CONCEPTS"] = "<cite><a href=\"http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/\">RDF 1.1 Concepts and Abstract Syntax</a></cite> Richard Cyganiak, David Wood, Editors. World Wide Web Consortium (work in progress). 30 May 2012. Editor's Draft. This edition of the JSON-LD Syntax specification is http://www.w3.org/TR/2011/WD-rdf11-concepts-20110830/. The <a href=\"http://www.w3.org/TR/rdf11-concepts/\">latest edition of the JSON-LD Syntax</a> is available at http://www.w3.org/TR/rdf11-concepts/";
                    berjon.biblio["WEBIDL"] = "<cite><a href=\"http://www.w3.org/TR/2012/CR-WebIDL-20120419/\">Web IDL</a></cite> Cameron McCormack, Editor. World Wide Web Consortium. 19 April 2012. Candidate Recommendataion. This edition of Web IDL is http://www.w3.org/TR/2012/CR-WebIDL-20120419/. The <a href=\"http://dev.w3.org/2006/webapi/WebIDL/\">latest edition of Web IDL</a> is available at http://dev.w3.org/2006/webapi/WebIDL/";

                    // process the document before anything else is done
                    var refs = document.querySelectorAll('adef') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'dfn' ) ;
                        var tit = item.getAttribute('title') ;
                        if (!tit) {
                            tit = con;
                        }
                        sp.className = 'adef' ;
                        sp.title=tit ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    refs = document.querySelectorAll('aref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'aref' ;
                        sp.setAttribute('title', con);
                        sp.innerHTML = '@'+con ;
                        p.replaceChild(sp, item) ;
                    }
                    // local datatype references
                    refs = document.querySelectorAll('ldtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'datatype idlType';
                        sp.title = ref ;
                        sp.setAttribute('href', '#idl-def-' + ref);
                        sp.innerHTML = '<code>' + con + '</code>';
                        p.replaceChild(sp, item) ;
                    }
                    // external datatype references
                    refs = document.querySelectorAll('dtref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_') ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        sp.className = 'externalDFN';
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now do terms
                    refs = document.querySelectorAll('tdef') ;
                    var tdefs = [];
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( tdefs[ref]) {
                          throw "Duplicate definition of term '" + ref + "'" ;
                        }

                        var sp = document.createElement( 'dfn' ) ;
                        tdefs[ref] = sp ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                    // now term references
                    refs = document.querySelectorAll('tref') ;
                    for (var i = 0; i < refs.length; i++) {
                        var item = refs[i];
                        if (!item) continue ;
                        var p = item.parentNode ;
                        var con = item.innerHTML ;
                        var ref = item.getAttribute('title') ;
                        if (!ref) {
                            ref = item.textContent ;
                        }
                        if (ref) {
                            ref = ref.replace(/\s+/g, '_').toLowerCase() ;
                        }

                        if ( !tdefs[ref]) {
                          throw "Reference to undefined term '" + ref + "'" ;
                        }
                        var sp = document.createElement( 'a' ) ;
                        var id = item.textContent ;
                        sp.className = 'tref' ;
                        sp.title = ref ;
                        sp.innerHTML = con ;
                        p.replaceChild(sp, item) ;
                    }
                }
        } ;


      var respecConfig = {
          doRDFa: "1.1",
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "CG-DRAFT",
          //publishDate:          "2010-04-29",
          copyrightStart:       "2010",

          // the specification's short name, as in http://www.w3.org/TR/short-name/
          shortName:            "json-ld-framing",
          subtitle:             "An Application Programming Interface for the JSON-LD Syntax",
          // if you wish the publication date to be other than today, set this
          // publishDate:  "2009-08-06",

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          previousPublishDate:  "2012-05-24",
          previousMaturity:     "ED",
          //previousDiffURI:      "http://json-ld.org/spec/ED/json-ld-framing/20120524/",

          // if there a publicly available Editor's Draft, this is the link
          edDraftURI:           "http://json-ld.org/spec/latest/json-ld-framing/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // if you want to have extra CSS, append them to this list
          // it is recommended that the respec.css stylesheet be kept
          // extraCSS: [],

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Manu Sporny", url: "http://manu.sporny.org/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
              { name: "Dave Longley", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
              { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
                company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
          ],

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          authors:  [
              { name: "Dave Longley", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"},
              { name: "Manu Sporny", url: "http://digitalbazaar.com/",
                company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/" },
              { name: "Gregg Kellogg", url: "http://greggkellogg.net/",
                company: "Kellogg Associates", companyURL: "http://kellogg-assoc.com/" },
              { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
                company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
          ],

          // name of the WG
          wg:           "Linking Data in JSON Community Group",

          // URI of the public WG page
          wgURI:        "http://json-ld.org/",

          // name (with the @w3c.org) of the public mailing to which comments are due
          wgPublicList: "public-linked-json@w3c.org",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI:  "",
          maxTocLevel: 4,
          preProcess: [ preProc ],
          //alternateFormats: [ {uri: "diff-20120524.html", label: "diff to previous version"} ],
      };

      function _esc(s) {
          s = s.replace(/&/g,'&amp;');
          s = s.replace(/>/g,'&gt;');
          s = s.replace(/"/g,'&quot;');
          s = s.replace(/</g,'&lt;');
          return s;
      }

      function updateExample(doc, content) {
        // perform transformations to make it render and prettier
        content = content.replace(/<!--/, '');
        content = content.replace(/-->/, '');
        content = _esc(content);
        content = content.replace(/\*\*\*\*([^*]*)\*\*\*\*/g, '<span class="diff">$1</span>') ;
        return content ;
      }
//]]>
  </script>
<style type="text/css">
.diff { font-weight:bold; color:#0a3; }
</style>
</head>

<body>
<section id="abstract">
<p>JSON-LD Framing allows developers to query by example and
  force a specific tree layout to a JSON-LD document.</p>
</section>

<section id='sotd'>
<p>This document is an experimental work in progress.</p>
<!-- <p>
This document has been reviewed by W3C Members, by software
developers, and by other W3C groups and interested parties, and is
endorsed by the Director as a W3C Recommendation. It is a stable
document and may be used as reference material or cited from another
document. W3C's role in making the Recommendation is to draw attention
to the specification and to promote its widespread deployment. This
enhances the functionality and interoperability of the Web.
</p> -->
</section>

<section>
<h1>Introduction</h1>
<p>A JSON-LD document is a representation of a directed graph. A single
  directed graph can have many different serializations, each expressing
  exactly the same information. Developers typically work with trees, represented as
  <tref>JSON object</tref>s. While mapping a graph to
  a tree can be done, the layout of the end result must be specified in advance.
  A <tdef>Frame</tdef> can be used by a developer on a JSON-LD document to
  specify a deterministic layout for a graph.</p>

<section>
<h2>How to Read this Document</h2>

<p>
This document is a detailed specification for a serialization of Linked
Data in JSON. The document is primarily intended for the following audiences:
</p>

<ul>
  <li>Authors who want to query JSON-LD documents to create representations
    more appropriate for a given use case.</li>
  <li>Software developers that want to implement processors and APIs for
  JSON-LD.</li>
</ul>

<p>
To understand the basics in this specification you must first be familiar with
JSON, which is detailed in [[!RFC4627]]. You must also understand the
JSON-LD Syntax [[!JSON-LD]], which is the base syntax used by all of the
algorithms in this document,
and the JSON-LD API [[!JSON-LD-API]]. To understand the API and how it is
intended to operate  in a programming environment, it is useful to have working
knowledge of the JavaScript programming language [[ECMA-262]] and
WebIDL [[!WEBIDL]]. To understand how JSON-LD maps to RDF, it is helpful to be
familiar with the basic RDF concepts [[!RDF-CONCEPTS]].</p>

<p>
  Examples may contain references to existing vocabularies and use <tref>prefix</tref>es to refer to vocabularies. The following is a list of all vocabularies and their <tref>prefix</tref> abbreviations, as used in this document:
</p>
<ul>
  <li>The <a href="http://purl.org/dc/terms/">Dublin Core</a>
  vocabulary (abbreviation: <code>dc</code>, e.g., <code>dc:title</code>)</li>
  <li>The <a href="http://xmlns.com/foaf/0.1/">Friend of a Friend</a>
  vocabulary (abbreviation: <code>foaf</code>, e.g., <code>foaf:knows</code>)</li>
  <li>The <a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#">RDF</a>
  vocabulary (abbreviation: <code>rdf</code>, e.g., <code>rdf:type</code>)</li>
  <li>The <a href="http://www.w3.org/2001/XMLSchema#">XSD</a>
  vocabulary (abbreviation: <code>xsd</code>, e.g., <code>xsd:integer</code>)</li>
</ul>

<p>
  JSON [[RFC4627]] defines several terms which are used throughout this document:
  <dl>
    <dt><tdef>JSON object</tdef></dt><dd>
      An object structure is represented as a pair of curly brackets surrounding zero or
      more name/value pairs. A name is a <tref>string</tref>. A single colon comes after
      each name, separating the name from the value. A single comma separates a value
      from a following name. The names within an object SHOULD be unique.
    </dd>
    <dt><tdef>array</tdef></dt>
    <dd>
      An array is an ordered collection of values. An array structure is represented as square brackets surrounding zero or more values (or elements). Elements are separated by commas.  Within JSON-LD, array order is not preserved by default, unless
      specific markup is provided. This is because the basic data model of JSON-LD is a <tref>linked data graph</tref>, which is inherently unordered.
    </dd>
    <dt><tdef>string</tdef></dt><dd>
      A string is a sequence of zero or more Unicode characters, wrapped in double quotes, using backslash escapes. A
      character is represented as a single character string.
    </dd>
    <dt><tdef>number</tdef></dt>
    <dd>
      A number is similar to that used in most programming languages, except that the octal and hexadecimal formats are not used and that leading zeros are not allowed.</dd>
    <dt><tdef>true</tdef> and <tdef>false</tdef></dt><dd>
      Boolean values.
    </dd>
    <dt><tdef>null</tdef></dt><dd>
      The use of the <tref>null</tref> value within JSON-LD is used to ignore or reset values.
    </dd>
    <dt><tdef>subject definition</tdef></dt><dd>
      A <tref>JSON object</tref> used to represent a <tref>subject</tref> and one or more properties
      of that subject. A <tref>JSON object</tref> is a subject definition if it does not contain the keys
      <code>@value</code>, <code>@list</code> or <code>@set</code> and it has one or more keys other than <code>@id</code>.</dd>
    <dt><tdef>subject reference</tdef></dt><dd>
      A <tref>JSON object</tref> used to reference a subject having only the <code>@id</code> key.</dd>
  </dl>
</p>
</section>

<section>
<h2>Linked Data</h2>
<p>
The following definition for <tref>Linked Data</tref> is the one that will
be used for this specification.
</p>
<ol>
  <li><tdef>Linked Data</tdef> is a set of documents, each containing a representation of a <tref>linked data graph</tref>.</li>
  <li>A <tdef>linked data graph</tdef> is an unordered labeled directed graph, where <tref title="node">nodes</tref> are <tref>subject</tref>s or <tref>object</tref>s, and edges are properties.
    A linked data graph may be named using a <tdef>graph name</tdef>.
    A <tref>linked data graph</tref> is a generalized representation of a
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-graph">RDF graph</a></cite>
    as defined in [[!RDF-CONCEPTS]].</li>
  <li>A <tdef>node</tdef> may be an <tref>IRI</tref>, <tref>blank node</tref>, or <tref>literal</tref>.</li>
  <li>An <tdef><abbr title="Internationalized Resource Identifier">IRI</abbr></tdef> (an Internationalized Resource Identifier) is described in [[!RFC3987]])
    and the use with JSON-LD conforms to the definition of
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-iri">IRI</a></cite> in [[!RDF-CONCEPTS]].</li>
  <li>A <tdef>dataset</tdef> represents a collection of
    <tref title="linked data graph">linked data graphs</tref>. It is comprized of
    a <tdef>default graph</tdef>, which does not have a name,
    and zero or more <tdef title="named graph">named graphs</tdef> each named using
    a <tref>node</tref> See
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#section-multigraph">Abstract Syntax for Working with Multiple Graphs</a></cite>
    in [[!RDF-CONCEPTS]].</li>
  <li>A <tdef>subject</tdef> is any <tref>node</tref> in a <tref>linked data graph</tref> with at least one outgoing edge.</li>
  <li>An <tdef>object</tdef> is a <tref>node</tref> in a <tref>linked data graph</tref> with at least one incoming edge.</li>
  <li>An object MAY be a <tref>subject</tref> and <tref>object</tref> at the same time.</li>
  <li>A <tdef>property</tdef> is an edge of the <tref>linked data graph</tref>.
    Also known as a <tdef>predicate</tdef> in [[!RDF-CONCEPTS]].</li>
  <li>A <tref>property</tref> SHOULD be an <tref>IRI</tref>. To be converted
    to or from RDF, a <tref>property</tref> MUST be an <tref>IRI</tref></li>
  <li>A <tdef>blank node</tdef> is a <tref>node</tref> which is neither an <tref>IRI</tref> nor a <tref>literal</tref>
    but represents an unknown <tref>node</tref>, which may be either an <tref>IRI</tref> or a <tref>literal</tref>.
    Within a document, a <tref>blank node</tref> may have an identifier used for intra-document reference
    purposes only. See [[!RDF-CONCEPTS]] for a further description of
  <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-blank-node">blank nodes</a></cite>.</li>
  <li>An <tref>IRI</tref> <tref>node</tref> in a <tref>linked data graph</tref> SHOULD be identify a <tref>Linked Data</tref> <em>resource</em> describing the <tref>subject</tref>, <tref>object</tref> or <tref>property</tref>.</li>
  <li>A <tdef>literal</tdef> is used to identify values such as numbers and dates.
    A <tref>literal</tref> may be an <tref>object</tref> in a <tref>linked data graph</tref>.
    See [[!RDF-CONCEPTS]] for a further definition of
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-literal">literal</a></cite>.</li>
  <li>A <tdef>Quad</tdef> contains a <tref>subject</tref>, <tref>predicate</tref>, <tref>object</tref>,
    and optionally a <tref>graph name</tref>.
    See [[!RDF-CONCEPTS]] definition for
    <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-rdf-triple">RDF triple</a></cite>,
    which most closely aligns to <a>Quad</a>.</li>
</ol>
</section>

<section>
  <h2>Contributing</h2>

  <p>There are a number of ways that one may participate in the development of
    this specification:</p>

  <ul>
    <li>Technical discussion typically occurs on the public mailing list:
      <a href="http://lists.w3.org/Archives/Public/public-linked-json/">public-linked-json@w3.org</a></li>

    <li><a href="http://json-ld.org/minutes/">Public teleconferences</a> are held
      on Tuesdays at 1500UTC on the second and fourth week of each month.</li>

    <li>Specification bugs and issues should be reported in the
      <a href="https://github.com/json-ld/json-ld.org/issues">issue tracker</a>.</li>

    <li><a href="https://github.com/json-ld/json-ld.org/tree/master/spec">Source code</a> for the
      specification can be found on Github.</li>

    <li>The <a href="http://webchat.freenode.net/?channels=json-ld">#json-ld</a>
      IRC channel is available for real-time discussion on irc.freenode.net.</li>
  </ul>

</section>

</section>

<section>
  <h2>The Application Programming Interface</h2>

  <p>This API provides a clean mechanism that enables developers to convert
  JSON-LD data into a a variety of output formats that are easier to work with in
  various programming languages. If a JSON-LD API is provided in a programming
  environment, the entirety of the following API MUST be implemented.
  </p>

  <section>
    <h3>JsonLdProcessor</h3>
    <dl title="[NoInterfaceObject] interface JsonLdProcessor" class="idl">

      <dt>void frame()</dt>
      <dd>
        <a href="#framing">Frames</a> the given <code>input</code> using the
        <code>frame</code> according to the steps in the
        <a href="#framing-algorithm">Framing Algorithm</a>. The <code>input</code>
        is used to build the framed output and is returned if there are no errors.
        If there are no matches for the frame, <tref>null</tref> MUST be
        returned. Exceptions MUST be thrown if there are errors.

        <dl class="parameters">
          <dt>object or object[] or URL input</dt>
           <dd>The JSON-LD object or array of JSON-LD objects to perform the framing upon or an
            <tref>IRI</tref> referencing the JSON-LD document to frame.</dd>
          <dt>object or URL frame</dt>
          <dd>The frame to use when re-arranging the data of <code>input</code>; either
            in the form of an <tref>JSON object</tref> or as <tref>IRI</tref>.</dd>
          <dt>JsonLdCallback callback</dt>
          <dd>A callback that is called when processing is complete on
            the given <code>input</code>.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options that MAY affect the framing algorithm such as, e.g., the
            input document's base <tref>IRI</tref>.</dd>
        </dl>
      </dd>

      <dt>void flatten()</dt>
      <dd>
        <a href="#flattening">Flattens</a> the given <code>input</code> according to
        the steps in the <a href="#flattening-algorithm">Flattening Algorithm</a>. The
        <code>input</code> MUST be flattened and returned if there are
        no errors. If the flattening fails, an appropriate exception MUST be thrown.

        <p class="issue">It is still being discussed if the flatten() method should be
          added or not. See <a href="https://github.com/json-ld/json-ld.org/issues/109">ISSUE-109</a>.</p>

        <dl class="parameters">
          <dt>object or object[] or URL input</dt>
          <dd>The JSON-LD object or array of JSON-LD objects to flatten or an
            <tref>IRI</tref> referencing the JSON-LD document to flatten.</dd>
          <dt>string or URL graph</dt>
          <dd>The graph in the document that should be flattened. To return the default
            graph <code>@default</code> has to be passed, for the merged graph <code>@merged</code>
            and for any other graph the <tref>IRI</tref> identifying the graph has to be passed. The
            default value is <code>@merged</code>.</dd>
          <dt>ObjectOrURL? context</dt>
          <dd>An optional external context to use additionally to the context embedded in
            <code>input</code> when expanding the <code>input</code>.</dd>
          <dt>JsonLdCallback callback</dt>
          <dd>A callback that is called when processing is complete on
            the given <code>input</code>.</dd>
          <dt>optional JsonLdOptions options</dt>
          <dd>A set of options that MAY affect the expansion algorithm such as, e.g., the
            input document's base <tref>IRI</tref>.</dd>
        </dl>
      </dd>
    </dl>

  </section>

  <section>
    <h3>Callbacks</h3>
  <section>
    <h3>JsonLdCallback</h3>
    <p>The <a>JsonLdCallback</a> is used to return a processed JSON-LD representation
      as the result of processing an API method.</p>

    <p>See <dtref>JsonLdCallback</dtref> definition in [[!JSON-LD-API]].</p>

    <dl title="[NoInterfaceObject Callback] interface JsonLdCallback"
        class="idl">

      <dt>void jsonLd()</dt>
      <dd>This callback is invoked when processing is complete.
      <dl class="parameters">
         <dt>ObjectOrObjectArray jsonld</dt>
         <dd>The processed JSON-LD document.</dd>
      </dl>
      </dd>
    </dl>
  </section>
  </section>

  <section>
    <h3>Data Structures</h3>
    <p>This section describes datatype definitions used within the JSON-LD API.</p>

    <section>
    <h3>JsonLdOptions</h3>
    <p>The <a>JsonLdOptions</a> type is used to convert a set of options to an interface method.</p>
    <p>See <dtref>JsonLdOptions</dtref> definition in [[!JSON-LD-API]].</p>
    <dl title="typedef object JsonLdOptions" class="idl">
      <dt><a>URL</a> base</dt>
      <dd>The Base IRI to use when expanding the document. This overrides the value of
        <em>input</em> if it is a <a>URL</a> or if it is a <code>object</code> or <code>object[]</code>.</dd>
      <dt>boolean optimize</dt>
      <dd>If set to <code>true</code>, the JSON-LD processor is allowed to
        optimize the output of the <a href="#compaction-algorithm">Compaction Algorithm</a>
        to produce even compacter representations. The algorithm for compaction
        optimization is beyond the scope of this specification and thus
        not defined. Consequently, different implementations MAY implement
        different optimization algorithms.</dd>
      <dt>boolean noType</dt>
      <dd>If set to <code>true</code>, the JSON-LD processor will not use the
        <code>@type</code> property when generating the output, and will use the
        expanded <code>rdf:type</code> IRI as the property instead of <code>@type</code>.</dd>
    </dl>
    </section>
  </section>

</section>

<section>
<h1>Algorithms</h1>

<p>All algorithms described in this section are intended to operate on
language-native data structures. That is, the serialization to a text-based
JSON document isn't required as input or output to any of these algorithms and
language-native data structures MUST be used where applicable.</p>

<section>
  <h2>Syntax Tokens and Keywords</h2>

  <p>JSON-LD specifies a number of syntax tokens and <tdef>keyword</tdef>s that are using
  in all algorithms described in this section:</p>

  <dl>
  <dt><code>@context</code></dt><dd>Used to set the <tref>local context</tref>.</dd>
  <dt><code>@id</code></dt><dd>Sets the active subject.</dd>
  <dt><code>@language</code></dt><dd>Used to specify the language for a literal.</dd>
  <dt><code>@type</code></dt><dd>Used to set the type of the active subject or the datatype of a literal.</dd>
  <dt><code>@value</code></dt><dd>Used to specify the value of a literal.</dd>
  <dt><code>@container</code></dt><dd>Used to set the container of a particular value.</dd>
  <dt><code>@list</code></dt><dd>Used to express an ordered set of data.</dd>
  <dt><code>@set</code></dt><dd>Used to express an unordered set of data.</dd>
  <dt><code>@graph</code></dt><dd>Used to explicitly express a <tref>linked data graph</tref>.</dd>
  <dt><code>:</code></dt><dd>The separator for JSON keys and values that use <tref title="compact_iri">compact IRIs</tref>.</dd>
  <dt><code>@default</code></dt><dd>Used in <a href="#framing">Framing</a> to set the default value for
    an output property when the framed <tref>subject definition</tref> does not include such a property.</dd>
  <dt><code>@explicit</code></dt><dd>Used in <a href="#framing">Framing</a> to override the
    value of <tref>explicit inclusion flag</tref> within a specific frame.</dd>
  <dt><code>@omitDefault</code></dt><dd>Used in <a href="#framing">Framing</a> to override the
    value of <tref>omit default flag</tref> within a specific frame.</dd>
  <dt><code>@embed</code></dt><dd>Used in <a href="#framing">Framing</a> to override the
    value of <tref>object embed flag</tref> within a specific frame.</dd>
  <dt><code>@null</code></dt><dd>Used in <a href="#framing">Framing</a> when a value of <tref>null</tref>
    should be returned, which would otherwise be removed when <a href="#compaction">Compacting</a>.</dd>
  </dl>

  <p>All JSON-LD tokens and keywords are case-sensitive.</p>
</section>

<section>
  <h2>Algorithm Terms</h2>
  <dl>
    <dt><tdef>initial context</tdef></dt>
    <dd>
      a context that is specified to the algorithm before processing begins. The contents of the
      initial context is defined in <a href="#appendix-b">Appendix B</a>.
    </dd>
    <dt><tdef>active subject</tdef></dt>
    <dd>
      the currently active subject that the processor should use when
      processing.
    </dd>
    <dt><tdef>active property</tdef></dt>
    <dd>
      the currently active property that the processor should use when
      processing. The active property is represented in the original lexical form, which
      is used for finding coercion mappings in the <tref>active context</tref>.
    </dd>
    <dt><tdef>active object</tdef></dt>
    <dd>
      the currently active object that the processor should use when
      processing.
    </dd>
    <dt><tdef>active context</tdef></dt>
    <dd>
      a context that is used to resolve <tref>term</tref>s while the processing
      algorithm is running. The <tref>active context</tref> is the context
      contained within the <tref>processor state</tref>.
    </dd>
    <dt><tdef>compact IRI</tdef></dt>
    <dd>
      a compact IRI is has the form of <tref>prefix</tref> and <em>suffix</em> and is used as a way
      of expressing an IRI without needing to define separate <tref>term</tref> definitions for
      each IRI contained within a common vocabulary identified by <tref>prefix</tref>.
    </dd>
    <dt><tdef>local context</tdef></dt>
    <dd>
      a context that is specified within a <tref>JSON object</tref>,
      specified via the <code>@context</code> <tref>keyword</tref>.
    </dd>
    <dt><tdef>processor state</tdef></dt>
    <dd>
      the <tref>processor state</tref>, which includes the <tref>active
      context</tref>, <tref>active subject</tref>, and
      <tref>active property</tref>. The <tref>processor state</tref> is managed
      as a stack with elements from the previous <tref>processor state</tref>
      copied into a new <tref>processor state</tref> when entering a new
      <tref>JSON object</tref>.
    </dd>
    <dt><tdef>JSON-LD input</tdef></dt>
    <dd>
      The JSON-LD data structure that is provided as input to the algorithm.
    </dd>
    <dt><tdef>JSON-LD output</tdef></dt>
    <dd>
      The JSON-LD data structure that is produced as output by the algorithm.
    </dd>
    <dt><tdef>term</tdef></dt><dd>
      A <tref>term</tref> is a short word defined in a context that MAY be expanded to an <tref>IRI</tref>
    </dd>
    <dt><tdef>prefix</tdef></dt><dd>
      A <tref>prefix</tref> is a <tref>term</tref> that expands to a vocabulary base IRI. It
      is typically used along with a <em>suffix</em> to form a <tref>compact IRI</tref> to create an IRI
      within a vocabulary.
    </dd>
    <dt><tdef>language-tagged literal</tdef></dt><dd>
      A <tref>language-tagged literal</tref> is a <tref>literal</tref> without a datatype, including
      a language.
      See <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-language-tagged-literal">languaged-tagged literal</a></cite> in [[!RDF-CONCEPTS]].
    </dd>
    <dt><tdef>typed literal</tdef></dt><dd>
      A <tref>typed literal</tref> is a <tref>literal</tref> with an associated <tref>IRI</tref>
      which indicates the literal's datatype.
      See <cite><a href="http://www.w3.org/TR/rdf11-concepts/#dfn-typed-literal">languaged-tagged literal</a></cite> in [[!RDF-CONCEPTS]].
    </dd>
  </dl>
</section>

<section>
<h3>Generate Blank Node Identifier</h3>
<p>This algorithm is used by the <a href="#framing-algorithm">Framing Algorithm</a> to deterministically name
  <tref>blank node</tref> identifiers. It uses a <em>identifier map</em> and <em>prefix</em>
  and takes a possibly <tref>null</tref> identifier and returns a new identifier based on <em>prefix</em>.</p>
<p>The variable <em>next identifier</em> is initialized to <em>prefix</em> appended with <code>0</code>.</p>

<ol class="algorithm">
  <li>If the old identifier is not null and is in <em>identifier map</em> return the mapped identifier.</li>
  <li>Otherwise, if old identifier is not null, create a new entry in <em>identifier map</em> initialized
    to the current value of <em>next identifier</em>. Increment <em>next identifier</em> by adding one
    to the integer suffix. Return the mapped identifier.</li>
  <li>Otherwise, increment <em>next identifier</em> by adding one to the integer suffix and return its
    original value.</li>
</ol>
</section>

<section>
<h2>Framing</h2>
<p>Framing is the process of taking a JSON-LD document, which expresses a
  graph of information, and applying a specific graph layout
  (called a <tref>Frame</tref>).</p>

<p>Framing makes use of the <a href="#subject-map-generation">Subject Map Generation</a> algorithm
  to place each object defined in the JSON-LD document into a flat list of objects, allowing
  them to be operated upon by the framing algorithm.</p>

<section>
<h3>Framing Algorithm Terms</h3>

<dl>
  <dt><tdef>input frame</tdef></dt>
  <dd>the initial <tref>frame</tref> provided to the framing algorithm.</dd>
  <dt><tdef>framing context</tdef></dt>
  <dd>a context containing a <tref>map of embeds</tref>, the
    <tref>object embed flag</tref>, the
    <tref>explicit inclusion flag</tref> and the
    <tref>omit default flag</tref>.</dd>
  <dt><tdef>map of embeds</tdef></dt>
  <dd>a map that tracks if a subject is to be embedded in the output of the
    <a href="#framing-algorithm">Framing Algorithm</a>; it maps a subject
    <code>@id</code> to a parent <tref>JSON object</tref> and property
    or parent array.</dd>
  <dt><tdef>object embed flag</tdef></dt>
  <dd>a flag specifying that objects should be directly embedded in the output,
    instead of being referred to by their IRI.</dd>
  <dt><tdef>explicit inclusion flag</tdef></dt>
  <dd>a flag specifying that for properties to be included in the output, they
    must be explicitly declared in the <tref>framing context</tref>.</dd>
  <dt><tdef>omit default flag</tdef></dt>
  <dd>a flag specifying that properties that are missing from the
    <tref>JSON-LD input</tref>, but present in the <tref>input frame</tref>
    should be omitted from the output.</dd>
  <dt><tdef>map of flattened subjects</tdef></dt>
  <dd>a map of subjects that is the result of the
    <a href="#subject-map-generation">Subject Map Generation algorithm</a>.</dd>
</dl>
</section>

<section>
<h3>Framing Algorithm</h3>

<p class="issue">This algorithm is a work in progress. Presently, it only works
  for documents without named graphs.</p>

<p>The framing algorithm takes an <tref>JSON-LD input</tref> (<strong>expanded input</strong>)
  and an <tref>input frame</tref> (<strong>expanded frame</strong>) that have been expanded
  according to the <a href="#expansion-algorithm">Expansion Algorithm</a>, and a number of
  options and produces <tref>JSON-LD output</tref>.</p>

<p>Create <tref>framing context</tref> using <tref>null</tref> for the <tref>map of embeds</tref>,
    the <tref>object embed flag</tref> set to <tref>true</tref>, the
    <tref>explicit inclusion flag</tref> set to <tref>false</tref>, and the
    <tref>omit default flag</tref> set to <tref>false</tref> along with <tref>map of flattened subjects</tref>
    set to the <code>@merged</code> property of the result of performing the
    <a href="#subject-map-generation">Subject Map Generation</a> algorithm on
    <strong>expanded input</strong>. Also create <em>results</em> as an empty <tref>array</tref>.</p>

<p>Invoke the recursive algorithm using <tref>framing context</tref> (<em>state</em>),
  the <tref>map of flattened subjects</tref> (<em>subjects</em>),
  <strong>expanded frame</strong> (<em>frame</em>), <em>result</em> as <em>parent</em>, and
  <tref>null</tref> as <tref>active property</tref>.</p>

<p>The following series of steps is the recursive
  portion of the framing algorithm:</p>

<ol class="algorithm">
  <li>Validate <em>frame</em>.</li>
  <li>Create a set of matched subjects by filtering <em>subjects</em> checking
    the <tref>map of flattened subjects</tref> against <em>frame</em>:
    <ol class="algorithm">
      <li>If <em>frame</em> has a <code>@type</code> property containing
        one or more <tref title="iri">IRIs</tref> match any <tref>subject definition</tref>
        with a <code>@type</code> property including any of those <tref title="iri">IRIs</tref>.</li>
      <li>Otherwise, if <em>frame</em> has a <code>@type</code> property only
        a empty <tref>JSON object</tref>, matches any <tref>subject definition</tref>
        with a <code>@type</code> property, regardless of the actual values.</li>
      <li>Otherwise, match if the <tref>subject definition</tref> contains all of the
        non-<tref>keyword</tref> properties in <em>frame</em>.</li>
    </ol>
  </li>
  <li>Get values for <em>embedOn</em> and <em>explicitOn</em> by looking in <em>frame</em>
    for the keys <code>@embed</code> and <code>@explicit</code> using the current values
    for <tref>object embed flag</tref> and <tref>explicit inclusion flag</tref> from <em>state</em> if not found.</li>
  <li>For each <em>id</em> and <em>subject</em> from the set of matched subjects, ordered by <em>id</em>:
    <ol class="algorithm">
      <li>If the <tref>active property</tref> is <tref>null</tref>, set the <tref>map of embeds</tref> in
        <em>state</em> to an empty map.</li>
      <li>Initialize <em>output</em> with <code>@id</code> and <em>id</em>.</li>
      <li>Initialize <em>embed</em> with <em>parent</em> and <tref>active property</tref> to
        <em>property</em>.</li>
      <li>If <em>embedOn</em> is <tref>true</tref>, and <em>id</em> is in <tref>map of embeds</tref>
        from <em>state</em>:
        <ol class="algorithm">
          <li>Set <em>existing</em> to the value of <em>id</em> in <tref>map of embeds</tref>
            and set <em>embedOn</em> to <tref>false</tref>.</li>
          <li>If <em>existing</em> has a <em>parent</em> which is an <tref>array</tref> containing a
            <tref>JSON object</tref> with <code>@id</code> equal to <em>id</em>, <em>element</em> has
            already been embedded and can be overwritten, so set <em>embedOn</em> to <tref>true</tref>.</li>
          <li>Otherwise, <em>existing</em> has a <em>parent</em> which is a <tref>subject definition</tref>.
            Set <em>embedOn</em> to <tref>true</tref> if any of the items in <em>parent</em> <em>property</em>
            is a <tref>subject definition</tref>
            or <tref>subject reference</tref> for <em>id</em> because the embed can be overwritten.
          </li>
          <li>If <em>embedOn</em> is <tref>true</tref>, <em>existing</em> is already embedded but
            can be overwritten, so <a href="#remove-embed">Remove Embedded Definition</a> for <em>id</em>.
          </li>
        </ol>
      </li>
      <li>If <em>embedOn</em> is <tref>false</tref>, add <em>output</em> to <em>parent</em>
        by either appending to <em>parent</em> if it is an <tref>array</tref>, or appending
        to <tref>active property</tref> in <em>parent</em> otherwise.</li>
      <li>Otherwise:
        <ol class="algorithm">
          <li>Add <em>embed</em> to <tref>map of embeds</tref> for <em>id</em>.</li>
          <li>Process each <em>property</em> and <em>value</em> in the matched <em>subject</em>, ordered
            by <em>property</em>:
            <ol class="algorithm">
              <li>If <em>property</em> is a <tref>keyword</tref>, add <em>property</em> and a copy of <em>value</em>
                to <em>output</em> and continue with the next property from <em>subject</em>.</li>
              <li>If <em>property</em> is not in <em>frame</em>:
                <ol class="algorithm">
                  <li>If <em>explicitOn</em> is <tref>false</tref>, <a href="#embed-values">Embed values</a>
                    from <em>subject</em> in <em>output</em> using <em>subject</em> as <em>element</em> and
                    <em>property</em> as <em>active property</em>.</li>
                  <li>Continue to next property.</li>
                </ol>
              </li>
              <li id="frm-process-prop-item">Process each <em>item</em> from <em>value</em> as follows:
                <ol class="algorithm">
                  <li>If <em>item</em> is a <tref>JSON object</tref> with the key <code>@list</code>, then
                    create a <tref>JSON object</tref> named <em>list</em> with the key <code>@list</code> and
                    the value of an empty array. Append <em>list</em> to <em>property</em> in
                    <em>output</em>. Process each <em>listitem</em> in the <code>@list</code> array as follows:
                    <ol class="algorithm">
                      <li>If <em>listitem</em> is a <tref>subject reference</tref>
                        process <em>listitem</em> recursively using this algorithm passing a new map of
                        <em>subjects</em> that contains the <code>@id</code> of <em>listitem</em> as the key
                        and the <tref>subject definition</tref> from the original <tref>map of flattened subjects</tref>
                        as the value. Pass the first value from
                        <em>frame</em> for <em>property</em> as <em>frame</em>, <em>list</em>
                        as <em>parent</em>, and <code>@list</code> as <tref>active property</tref>.</li>
                      <li>Otherwise, append a copy of <em>listitem</em> to <code>@list</code> in <em>list</em>.</li>
                    </ol>
                  </li>
                  <li>If <em>item</em> is a <tref>subject reference</tref>
                    process <em>item</em> recursively using this algorithm passing a new map as
                    <em>subjects</em> that contains the <code>@id</code> of <em>item</em> as the key and
                    the <tref>subject definition</tref> from the original <tref>map of flattened subjects</tref>
                    as the value. Pass the first value from
                    <em>frame</em> for <em>property</em> as <em>frame</em>, <em>output</em>
                    as <em>parent</em>, and <em>property</em> as <tref>active property</tref>.
                  <div class="issue">Passing a <tref>subject reference</tref> doesn't work if this map
                    is used recursively. Presently pass <tref>subject definition</tref> from original
                    <tref>map of flattened subjects</tref>.</div></li>
                  <li>Otherwise, append a copy of <em>item</em> to <tref>active property</tref> in
                    <em>output</em>.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Process each <em>property</em> and <em>value</em> in <em>frame</em>,
            where <em>property</em> is not a <em>keyword</em>, ordered by <em>property</em>:
            <ol class="algorithm">
              <li>Set <em>property frame</em> to the first item in <em>value</em> or a newly created
                <tref>JSON object</tref> if <em>value</em> is empty.</li>
              <li>Skip to the next property in <em>frame</em> if <em>property</em> is in <em>output</em>
                or if <em>property frame</em> contains
                <code>@omitDefault</code> which is <tref>true</tref> or if it does not contain
                <code>@omitDefault</code> but the value of <tref>omit default flag</tref>
                <tref>true</tref>.</li>
              <li>Set the value of <em>property</em> in <em>output</em> to a new <tref>JSON object</tref>
                with a property <code>@preserve</code> and a value that is a copy of the value
                of <code>@default</code> in <em>frame</em> if it exists, or the string
                <code>@null</code> otherwise.</li>
            </ol>
          </li>
          <li>Add <em>output</em> to <em>parent</em>.
            If <em>parent</em> is an <tref>array</tref>, append <em>output</em>, otherwise
            append <em>output</em> to <tref>active property</tref> in <em>parent</em>.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>At the completion of the recursive algorithm, <em>results</em> will contain the top-level
  <tref>subject definition</tref>s.</p>
<p>The final two steps of the framing algorithm require
  <em>results</em> to be compacted according to the
  <a href="#compaction-algorithm">Compaction Algorithm</a> by using the
  context provided in the <tref>input frame</tref>. If the frame has no context, compaction
  is performed with an empty context (not a null context). The compaction result MUST use
  the <code>@graph</code> keyword at the top-level, even if the context is empty or if there
  is only one element to put in the <code>@graph</code> array. Subsequently, replace all key-value
  pairs where the key is <code>@preserve</code> with the value from the key-pair. If the value
  from the key-pair is <code>@null</code>, replace the value with <tref>null</tref>. If,
  after replacement, an array contains only the value <tref>null</tref> remove the value, leaving
  an empty array. The resulting value is the final <tref>JSON-LD output</tref>.</p>

<p class="issue">The algorithm needs to be updated to consider <code>@graph</code>. See
  <a href="https://github.com/json-ld/json-ld.org/issues/118">ISSUE-118</a> for details.</p>

</section>

<section>
<h3>Subject Map Generation</h3>
<p>The Subject Map Generation algorithm takes as input an expanded JSON-LD document and results in a <tref>JSON object</tref>
  <em>subjectMap</em> holding a flat representation of the graphs and <tref title="node">nodes</tref> represented in the document. All <tref title="node">nodes</tref> that are not
  uniquely identified by an IRI get assigned a (new) <tref>blank node</tref> identifier. The resulting <em>subjectMap</em>
  document will have a property for every graph in the document whose value is another object with a property for every
  <tref>node</tref> represented in the document. While the default graph is stored under the <code>@default</code> property and the merged graph
  under the <code>@merged</code> property, all other graphs are stored under their respective <tref title="IRI">IRIs</tref>.</p>

<p>The algorithm takes as input the expanded JSON-LD document as <em>element</em>, the initially empty <em>subjectMap</em>,
  <code>@default</code> as <em>graph</em>, and <tref>null</tref> as <em>list</em>.</p>

<ol class="algorithm">
  <li>If <em>element</em> is an array, process each entry in <em>element</em> recursively, using this algorithm
    and return.</li>
  <li>If <em>element</em> is not a <tref>JSON object</tref> or if it has a <code>@value</code> property,
    then if <em>list</em> is not <tref>null</tref>, append <em>element</em> to <em>list</em> and return.</li>
  <li>If the <code>@id</code> property exists and is an <tref>IRI</tref>, set <em>id</em> to its value, otherwise
    set it to a <tref>blank node</tref> identifier created by the
    <a href="#generate-blank-node-identifier">Generate Blank Node Identifier</a> algorithm.</li>
  <li>If <em>list</em> is not <tref>null</tref>, append a new <tref>subject reference</tref> to <em>list</em> using
    <em>id</em> at the value for <code>@id</code>.</li>
  <li>Let <em>subjects</em> be the value in <em>subjectMap</em> where the key is <em>graph</em>; if no such
    value exists, insert a new <tref>JSON object</tref> for the key <em>graph</em>. If <em>id</em> is not in
    <em>subjects</em>, create a new <tref>JSON object</tref> <em>subject</em> with <em>id</em> as the value
    for <code>@id</code>. Let <em>subject</em> be the value of <em>id</em> in <em>subjects</em>.</li>
  <li>For each <em>property</em> that is not <code>@id</code> and each <em>value</em> in <em>element</em> ordered
    by <em>property</em>:
    <ol class="algorithm">
      <li>If <em>property</em> is <code>@graph</code>, recursively call this algorithm passing <em>value</em>
        for <em>element</em>, <em>subjectMap</em>, <tref>null</tref> for <em>list</em> and if <em>graph</em>
        is <code>merged</code> use <em>graph</em>, otherwise use <em>id</em> for <em>graph</em> and then continue.</li>
      <li>If <em>property</em> is not <code>@type</code> and is a keyword, merge <code>property</code> and
        <code>value</code> into <code>subject</code> and then continue.</li>
      <li>For each value <em>v</em> in the array <em>value</em>:
        <ol class="algorithm">
          <li>If <em>v</em> is a <tref>subject definition</tref> or <tref>subject reference</tref>:
            <ol class="algorithm">
              <li>If the property <code>@id</code> is not an <tref>IRI</tref> or it does not exist,
                map <em>v</em> to a <a href="#generate-blank-node-identifier">new blank node identifier</a>
                to avoid collisions. If one does not already exist, add a <tref>subject reference</tref> for
                <em>v</em> into <em>subject</em> for <em>property</em>.</li>
              <li>Recursively call this algorithm passing <em>v</em> for <em>value</em>, <em>subjectMap</em>,
                <em>graph</em>, and <tref>null</tref> for <em>list</em>.</li>
            </ol>
          </li>
          <li>Otherwise if <em>v</em> has the property <code>@list</code> then recursively call this algorithm
            with the value of <code>@list</code> as <em>element</em>, <em>subjectMap</em>, <em>graph</em>, and
            a new array <em>flattenedList</em> as <em>list</em>. Create a new <tref>JSON object</tref> with the
            property <code>@list</code> set to <em>flattenedList</em> and add it to <em>subject</em> for
            <em>property</em>.</li>
          <li>Otherwise, if <em>property</em> is <code>@type</code> and <em>v</em> is not an <tref>IRI</tref>,
            generate a <a href="#generate-blank-node-identifier">new blank node identifier</a> and add it
            to <em>subject</em> for <em>property</em>.</li>
          <li>Otherwise, add <em>v</em> to <em>subject</em> for <em>property</em>.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>After the above outlined algorithm has been executed, the subject map for all graphs including the default graph are contained in
  <em>subjectMap</em>. To also create the subject map for the merged graph, execute the algorithm again, but pass <code>merged</code>
  for <em>graph</em>.</p>

</section>

<section id="remove-embed">
<h3>Remove Embedded Definition</h3>
<p>This algorithm replaces an already embedded <tref>subject definition</tref> with a
  <tref>subject reference</tref>. It then recursively removes any entries in the
  <tref>map of embeds</tref> that had the removed <tref>subject definition</tref> in
  their parent chain.
  <div class="issue">About as clear as mud</div></p>
<p>The algorithm is invoked with a <tref>framing context</tref> and subject id <em>id</em>.</p>
<ol class="algorithm">
  <li>Find <em>embed</em> from <tref>map of embeds</tref> for <em>id</em>.</li>
  <li>Let <em>parent</em> and <em>property</em> be from <em>embed</em>.</li>
  <li>If <em>parent</em> is an array, replace the <tref>subject definition</tref> that matches
    <em>id</em> with a <tref>subject reference</tref>. If parent is a <tref>JSON object</tref>,
    replace the <tref>subject definition</tref> for <em>property</em> that matches <em>id</em>
    with a <tref>subject reference</tref>.</li>
  <li>Remove dependents for <em>id</em> in <tref>map of embeds</tref>
    by scanning the map for entries with <em>parent</em> that have an <code>@id</code> of <em>id</em>,
    removing that definition from the map, and then removing the dependents for the <em>parent</em> id
    recursively by repeating this step. This step will terminate when there are no more embed
    entries containing the removed <tref>subject definition</tref>'s <code>@id</code> in their
    parent chain.</li>
</ol>
</section>

<section id="embed-values">
<h3>Embed Values</h3>
<p>This algorithm recursively embeds property values in <tref>subject definition</tref> <em>output</em>, given a
  <tref>framing context</tref>, input <tref>subject definition</tref> <em>element</em>, <tref>active property</tref>,
  and <em>output</em>.</p>
<ol class="algorithm">
  <li>For each <em>item</em> in <tref>active property</tref> of <em>element</em>:
    <ol class="algorithm">
      <li>If <em>item</em> is a <tref>JSON object</tref> with the key <code>@list</code>,
        then create a new <tref>JSON object</tref> with a key <code>@list</code> and
        a value of an empty array and add it to <em>output</em>, appending if <em>output</em>
        is an array, and appending to <tref>active property</tref> otherwise. Recursively call this
        algorithm passing <em>item</em> as <em>element</em>, <code>@list</code> as <tref>active property</tref>,
        and the new array as <em>output</em>. Continue to the next <em>item</em>.</li>
      <li>If <em>item</em> is a <tref>subject reference</tref>:
        <ol class="algorithm">
          <li>If <tref>map of embeds</tref> does not contain an entry for the <code>@id</code> of <em>item</em>:
            <ol class="algorithm">
              <li>Initialize <em>embed</em> with <em>output</em> as <em>parent</em> and
                <tref>active property</tref> as <em>property</em>
                and add to <tref>map of embeds</tref>.</li>
              <li>Initialize a new <tref>subject definition</tref> <em>o</em> to act as the
                embedded <tref>subject definition</tref>.</li>
              <li>For each <em>property</em> and <em>value</em> in the expanded definition for
                <em>item</em> in <em>subjects</em>:
                <ol class="algorithm">
                  <li>Add <em>property</em> and a copy of <em>value</em> to <em>o</em> if <em>property</em>
                    is a <tref>keyword</tref>.</li>
                  <li>Otherwise, recursively call this algorithm passing <em>value</em> as <em>element</em>,
                    <em>property</em> as <tref>active property</tref> and <em>o</em> as <em>output</em>.</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Set <em>item</em> to <em>o</em>.</li>
        </ol>
      </li>
    </ol>
  </li>
  <li>If <em>output</em> is an <tref>array</tref>, append a copy of <em>item</em>, otherwise
    append a copy of <em>item</em> to <tref>active property</tref> in <em>output</em>.</li>
</ol>
</section>
</section>

<section>
<h1>Flattening</h1>

<p>Flattening is the process of taking a JSON-LD document, <a href="#expansion">expanding</a>
  it, labeling all unlabeled nodes with a <tref>blank node</tref> identifier, and returning
  an array of the <tref title="node">nodes</tref> defined in the document.</p>

<p class="issue">It is still being discussed if the flatten() method should be added or not.
  See <a href="https://github.com/json-ld/json-ld.org/issues/109">ISSUE-109</a>.</p>

<p>For example, assume the following JSON-LD input document:</p>

<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "name": "http://xmlns.com/foaf/0.1/name",
    "knows": "foaf:knows"
  },
  "@id": "http://example.com/markus",
  "name": "Markus Lanthaler",
  "knows": {
    "name": "Manu Sporny"
  }
}
-->
</pre>

<p>Running the JSON-LD Flattening algorithm for the merged graph (<code>@merged</code>) against
  the JSON-LD input document provided above would result in the following output:</p>

<pre class="example" data-transform="updateExample">
<!--
[
  {
    "@id": "http://example.com/markus",
    "foaf:knows": [ { "@id": "_:t0" }
    ],
    "http://xmlns.com/foaf/0.1/name": [ { "@value": "Markus Lanthaler" } ]
  },
  {
    "@id": "_:t0",
    "http://xmlns.com/foaf/0.1/name": [ { "@value": "Manu Sporny" } ]
  }
]
-->
</pre>

<section>
<h2>Flattening Algorithm</h2>
<p>The algorithm takes two input variables, an <em>element</em> to flatten and the
  <em>graph</em> for which the <tref>node</tref> definitions should be returned. If <em>graph</em>
  is not set, it will default to <code>@merged</code> which represents the result of
  merging all graphs including the default graph (<code>@default</code>).</p>

<ol class="algorithm">
  <li>Expand <em>element</em> according the <a href="#expansion-algorithm">Expansion Algorithm</a>.</li>
  <li>Generate a <em>subjectMap</em> according the <a href="#subject-map-generation">Subject Map Generation Algorithm</a>.</li>
  <li>Initialize an empty array <em>result</em>.</li>
  <li>If <em>subjectMap</em> has no property <em>graph</em>, return <em>result</em>, otherwise set <em>definitions</em> to its value.</li>
  <li>Foreach <em>property</em> and <em>value</em> of of <em>definitions</em>:
    <ol class="algorithm">
      <li>Add <em>value</em> to <em>result</em>.</li>
    </ol>
  </li>
  <li>Return <em>result</em>.</li>
</ol>

</section>
</section>

</section>

<section class="appendix informative">
<h1>IANA Considerations</h1>

<p>This section is included merely for standards community review and will be
submitted to the Internet Engineering Steering Group if this specification
becomes a W3C Recommendation.</p>

<h3>application/ld-frame+json</h3>
<dl>
  <dt>Type name:</dt>
  <dd>application</dd>
  <dt>Subtype name:</dt>
  <dd>ld-frame+json</dd>
  <dt>Required parameters:</dt>
  <dd>None</dd>
  <dt>Optional parameters:</dt>
  <dd>None</dd>
  <dt>Encoding considerations:</dt>
  <dd>The same as the <code>application/json</code> MIME media type.</dd>
  <dt>Security considerations:</dt>
  <dd>Since a JSON-LD frame is intended to specify a deterministic layout
    for a JSON-LD graph, the serialization SHOULD NOT be passed through a
    code execution mechanism such as JavaScript's <code>eval()</code>
    function. It is RECOMMENDED that a conforming parser does not attempt to
    directly evaluate the JSON-LD frame and instead purely parse the
    input into a language-native data structure.</dd>
  <dt>Interoperability considerations:</dt>
  <dd>Not Applicable</dd>
  <dt>Published specification:</dt>
  <dd>The <a href="http://json-ld.org/spec/latest/">JSON-LD</a> specification.</dd>
  <dt>Applications that use this media type:</dt>
  <dd>Any programming environment that requires the exchange of
    directed graphs. Implementations of JSON-LD have been created for
    JavaScript, Python, Ruby, PHP and C++.
  </dd>
  <dt>Additional information:</dt>
  <dd>
    <dl>
      <dt>Magic number(s):</dt>
      <dd>Not Applicable</dd>
      <dt>File extension(s):</dt>
      <dd>.jsonldf</dd>
      <dt>Macintosh file type code(s):</dt>
      <dd>TEXT</dd>
    </dl>
  </dd>
  <dt>Person &amp; email address to contact for further information:</dt>
  <dd>Manu Sporny &lt;msporny@digitalbazaar.com&gt;</dd>
  <dt>Intended usage:</dt>
  <dd>Common</dd>
  <dt>Restrictions on usage:</dt>
  <dd>None</dd>
  <dt>Author(s):</dt>
  <dd>Manu Sporny, Gregg Kellogg, Markus Lanthaler, Dave Longley</dd>
  <dt>Change controller:</dt>
  <dd>W3C</dd>
</dl>

<p>Fragment identifiers have no meaning with
  <a href="#application-ld-frame-json">application/frame-ld+json</a> resources.</p>

</section>

<section class="appendix" id="appendix-b">
  <h1>Initial Context</h1>
  <p>The <tref>initial context</tref> is defined with the following default entries:</p>
<pre class="example" data-transform="updateExample">
<!--
{
  "@context": {
    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type": { "@type": "@id"}
  }
}
-->
</pre>
  <p>Processors MUST act as if the initial context is defined in the outer-most level when processing
    JSON-LD documents.</p>
  <p class="issue">Should we define other default prefixes?</p>
</section>

<section class="appendix">
<h1>Acknowledgements</h1>

<p>The editors would like to thank Mark Birbeck, who provided a great deal of
the initial push behind the JSON-LD work via his work on RDFj,
Dave Lehn and Mike Johnson who reviewed, provided feedback, and
performed several implementations of the specification, and Ian Davis, who
created RDF/JSON. Thanks also to Nathan Rixham, Bradley P. Allen,
Kingsley Idehen, Glenn McDonald, Alexandre Passant, Danny Ayers, Ted
Thibodeau Jr., Olivier Grisel, Niklas Lindström, and Richard
Cyganiak for their input on the specification.
</p>
</section>

</body>
</html>
